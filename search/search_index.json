{
    "docs": [
        {
            "location": "/", 
            "text": "Capture The Flag 101\n\n\nWelcome\n\n\nCapture The Flags, or CTFs, are a kind of computer security competition.\n\n\nTeams of competitors (or just individuals) are pitted against each other in a test of computer security skill.\n\n\nVery often CTFs are the beginning of one's cyber security career due to their team building nature and competetive aspect. In addition, there isn't a lot of commitment required beyond a weekend.\n\n\nIn this guide/wiki/handbook you'll learn the techniques, thought processes, and methodologies you need to succeed in Capture the Flag competitions.\n\n\n\n\n\n  \n\n    \n\n        \n\n            \n\n            \nForensics\n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \nCryptography\n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \nWeb Exploitation\n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \nReverse Engineering\n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \nBinary Exploitation", 
            "title": "Index"
        }, 
        {
            "location": "/#capture-the-flag-101", 
            "text": "", 
            "title": "Capture The Flag 101"
        }, 
        {
            "location": "/#welcome", 
            "text": "Capture The Flags, or CTFs, are a kind of computer security competition.  Teams of competitors (or just individuals) are pitted against each other in a test of computer security skill.  Very often CTFs are the beginning of one's cyber security career due to their team building nature and competetive aspect. In addition, there isn't a lot of commitment required beyond a weekend.  In this guide/wiki/handbook you'll learn the techniques, thought processes, and methodologies you need to succeed in Capture the Flag competitions.", 
            "title": "Welcome"
        }, 
        {
            "location": "/forensics/overview/", 
            "text": "Forensics\n\n\nForensics is the art of recovering the digital trail left on a computer. There are plently of methods to find data which is seemingly deleted, not stored, or worse, covertly recorded.\n\n\nAn important part of Forensics is having the right tools, as well as being familair with the following topics:\n\n\n\n\nFile Formats\n\n\nEXIF data\n\n\nWireshark \n PCAPs\n\n\nWhat is Wireshark\n\n\n\n\n\n\nStegonagraphy\n\n\nDisk Imaging", 
            "title": "Overview"
        }, 
        {
            "location": "/forensics/overview/#forensics", 
            "text": "Forensics is the art of recovering the digital trail left on a computer. There are plently of methods to find data which is seemingly deleted, not stored, or worse, covertly recorded.  An important part of Forensics is having the right tools, as well as being familair with the following topics:   File Formats  EXIF data  Wireshark   PCAPs  What is Wireshark    Stegonagraphy  Disk Imaging", 
            "title": "Forensics"
        }, 
        {
            "location": "/forensics/what-are-file-formats/", 
            "text": "File Formats\n\n\nFile Extensions are not the sole way to identify the type of a file, files have certain leading bytes called \nfile signatures\n which allow programs to parse the data in a consistent manner. Files can also contain additional \"hidden\" data called \nmetadata\n which can be useful in finding out information about the context of a file's data.\n\n\nFile Signatures\n\n\nFile signatures\n (also known as File Magic Numbers) are bytes within a file used to identify the format of the file. Generally they\u2019re 2-4 bytes long, found at the beginning of a file.\n\n\nWhat is it used for?\n\n\nFiles can sometimes come without an extension, or with incorrect ones. We use file signature analysis to identify the format (file type) of the file. Programs need to know the file type in order to open it properly.\n\n\nHow do you find the file signature?\n\n\nYou need to be able to look at the binary data that constitutes the file you\u2019re examining. To do this, you\u2019ll use a hexadecimal editor. Once you find the file signature, you can check it against file signature repositories \nsuch as Gary Kessler\u2019s\n.\n\n\nExample\n\n\n\n\nThe file above, when opened in a Hex Editor, begins with the bytes \nFFD8FFE0 00104A46 494600\n or in ASCII \n\u02c7\u00ff\u02c7\u2021  JFIF\n where \n\\x00\n and \n\\x10\n lack symbols. \n\n\nSearching in \nGary Kessler\u2019s\n database shows that this file signature belongs to a \nJPEG/JFIF graphics file\n, exactly what we suspect.", 
            "title": "What are File Formats"
        }, 
        {
            "location": "/forensics/what-are-file-formats/#file-formats", 
            "text": "File Extensions are not the sole way to identify the type of a file, files have certain leading bytes called  file signatures  which allow programs to parse the data in a consistent manner. Files can also contain additional \"hidden\" data called  metadata  which can be useful in finding out information about the context of a file's data.", 
            "title": "File Formats"
        }, 
        {
            "location": "/forensics/what-are-file-formats/#file-signatures", 
            "text": "File signatures  (also known as File Magic Numbers) are bytes within a file used to identify the format of the file. Generally they\u2019re 2-4 bytes long, found at the beginning of a file.", 
            "title": "File Signatures"
        }, 
        {
            "location": "/forensics/what-are-file-formats/#what-is-it-used-for", 
            "text": "Files can sometimes come without an extension, or with incorrect ones. We use file signature analysis to identify the format (file type) of the file. Programs need to know the file type in order to open it properly.", 
            "title": "What is it used for?"
        }, 
        {
            "location": "/forensics/what-are-file-formats/#how-do-you-find-the-file-signature", 
            "text": "You need to be able to look at the binary data that constitutes the file you\u2019re examining. To do this, you\u2019ll use a hexadecimal editor. Once you find the file signature, you can check it against file signature repositories  such as Gary Kessler\u2019s .", 
            "title": "How do you find the file signature?"
        }, 
        {
            "location": "/forensics/what-are-file-formats/#example", 
            "text": "The file above, when opened in a Hex Editor, begins with the bytes  FFD8FFE0 00104A46 494600  or in ASCII  \u02c7\u00ff\u02c7\u2021  JFIF  where  \\x00  and  \\x10  lack symbols.   Searching in  Gary Kessler\u2019s  database shows that this file signature belongs to a  JPEG/JFIF graphics file , exactly what we suspect.", 
            "title": "Example"
        }, 
        {
            "location": "/forensics/what-is-metadata/", 
            "text": "Metadata\n\n\nMetadata is data about data. Different types of files have different metadata. The metadata on a photo could include dates, camera information, GPS location, comments, etc. For music, it could include the title, author, track number and album.\n\n\nWhat kind of file metadata is useful?\n\n\nPotentially, any file metadata you can find could be useful.\n\n\nHow do I find it?\n\n\n\n\nNote\n\n\nEXIF Data is metadata attached to photos which can include location, time, and device information.\n\n\n\n\nOne of our favorite tools is exiftool, which displays metadata for an input file, including:\n- File size\n- Dimensions (width and height)\n- File type\n- Programs used to create (e.g. Photoshop)\n- OS used to create (e.g. Apple)\n\n\nRun command line: \nexiftool(-k).exe [filename]\n and you should see something like this:\n\n\n\n\nExample\n\n\nLet's take a look at File A's metadata with exiftool: \n\n\nFile type\n\n\n\n\nImage description\n\n\n\n\nMake and camera info\n\n\n\n\nGPS Latitude/Longitude\n\n\n\n\nTimestamps\n\n\nTimestamps are data that indicate the time of certain events (MAC):\n- Modification \u2013 when a file was modified\n- Access \u2013 when a file or entries were read or accessed\n- Creation \u2013 when files or entries were created\n\n\nTypes of timestamps\n\n\n\n\nModified\n\n\nAccessed\n\n\nCreated\n\n\nDate Changed (MFT)\n\n\nFilename Date Created (MFT)\n\n\nFilename Date Modified (MFT)\n\n\nFilename Date Accessed (MFT)\n\n\nINDX Entry Date Created\n\n\nINDX Entry Date Modified\n\n\nINDX Entry Date Accessed\n\n\nINDX Entry Date Changed\n\n\n\n\nWhy do we care?\n\n\nCertain events such as creating, moving, copying, opening, editing, etc. might affect the MAC times. If the MAC timestamps can be attained, a timeline of events could be created.\n\n\nTimeline Patterns\n\n\nThere are plenty more patterns than the ones introduced below, but these are the basics you should start with to get a good understanding of how it works, and to complete this challenge.\n\n\n\n\n\n\n\n\n\n\n\n\nExamples\n\n\nWe know that the BMP files fileA and fileD are the same, but that the JPEG files fileB and fileC are different somehow. So how can we find out what went on with these files?\n\n\n\n\nBy using time stamp information from the file system, we can learn that the BMP fileD was the original file, with fileA being a copy of the original. Afterward, fileB was created by modifying fileB, and fileC was created by modifying fileA in a different way.\n\n\nFollow along as we demonstrate.\n\n\nWe\u2019ll start by analyzing images in AccessData FTK Imager, where there\u2019s a Properties window that shows you some information about the file or folder you\u2019ve selected.\n\n\n\n\n\n\n\n\n\n\nHere are the extracted MAC times for fileA, fileB, fileC and fileD:\n\nNote, AccessData FTK Imager assumes that the file times on the drive are in UTC (Universal Coordinated Time). I subtracted four hours, since the USB was set up in Eastern Standard Time. This isn\u2019t necessary, but it helps me understand the times a bit better.\n\n\n\n\nHighlight timestamps that are the same, if timestamps are off by a few seconds, they should be counted as the same. This lets you see a clear difference between different timestamps. Then, highlight oldest to newest to help put them in order.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIdentify timestamp patterns.", 
            "title": "What is Metadata"
        }, 
        {
            "location": "/forensics/what-is-metadata/#metadata", 
            "text": "Metadata is data about data. Different types of files have different metadata. The metadata on a photo could include dates, camera information, GPS location, comments, etc. For music, it could include the title, author, track number and album.", 
            "title": "Metadata"
        }, 
        {
            "location": "/forensics/what-is-metadata/#what-kind-of-file-metadata-is-useful", 
            "text": "Potentially, any file metadata you can find could be useful.", 
            "title": "What kind of file metadata is useful?"
        }, 
        {
            "location": "/forensics/what-is-metadata/#how-do-i-find-it", 
            "text": "Note  EXIF Data is metadata attached to photos which can include location, time, and device information.   One of our favorite tools is exiftool, which displays metadata for an input file, including:\n- File size\n- Dimensions (width and height)\n- File type\n- Programs used to create (e.g. Photoshop)\n- OS used to create (e.g. Apple)  Run command line:  exiftool(-k).exe [filename]  and you should see something like this:", 
            "title": "How do I find it?"
        }, 
        {
            "location": "/forensics/what-is-metadata/#example", 
            "text": "Let's take a look at File A's metadata with exiftool:   File type   Image description   Make and camera info   GPS Latitude/Longitude", 
            "title": "Example"
        }, 
        {
            "location": "/forensics/what-is-metadata/#timestamps", 
            "text": "Timestamps are data that indicate the time of certain events (MAC):\n- Modification \u2013 when a file was modified\n- Access \u2013 when a file or entries were read or accessed\n- Creation \u2013 when files or entries were created", 
            "title": "Timestamps"
        }, 
        {
            "location": "/forensics/what-is-metadata/#types-of-timestamps", 
            "text": "Modified  Accessed  Created  Date Changed (MFT)  Filename Date Created (MFT)  Filename Date Modified (MFT)  Filename Date Accessed (MFT)  INDX Entry Date Created  INDX Entry Date Modified  INDX Entry Date Accessed  INDX Entry Date Changed", 
            "title": "Types of timestamps"
        }, 
        {
            "location": "/forensics/what-is-metadata/#why-do-we-care", 
            "text": "Certain events such as creating, moving, copying, opening, editing, etc. might affect the MAC times. If the MAC timestamps can be attained, a timeline of events could be created.", 
            "title": "Why do we care?"
        }, 
        {
            "location": "/forensics/what-is-metadata/#timeline-patterns", 
            "text": "There are plenty more patterns than the ones introduced below, but these are the basics you should start with to get a good understanding of how it works, and to complete this challenge.", 
            "title": "Timeline Patterns"
        }, 
        {
            "location": "/forensics/what-is-metadata/#examples", 
            "text": "We know that the BMP files fileA and fileD are the same, but that the JPEG files fileB and fileC are different somehow. So how can we find out what went on with these files?   By using time stamp information from the file system, we can learn that the BMP fileD was the original file, with fileA being a copy of the original. Afterward, fileB was created by modifying fileB, and fileC was created by modifying fileA in a different way.  Follow along as we demonstrate.  We\u2019ll start by analyzing images in AccessData FTK Imager, where there\u2019s a Properties window that shows you some information about the file or folder you\u2019ve selected.      Here are the extracted MAC times for fileA, fileB, fileC and fileD: Note, AccessData FTK Imager assumes that the file times on the drive are in UTC (Universal Coordinated Time). I subtracted four hours, since the USB was set up in Eastern Standard Time. This isn\u2019t necessary, but it helps me understand the times a bit better.   Highlight timestamps that are the same, if timestamps are off by a few seconds, they should be counted as the same. This lets you see a clear difference between different timestamps. Then, highlight oldest to newest to help put them in order.            Identify timestamp patterns.", 
            "title": "Examples"
        }, 
        {
            "location": "/forensics/what-is-wireshark/", 
            "text": "Wireshark\n\n\nWireshark\n is a network protocol analyzer which is often used in CTF challenges to look at recorded network traffic. Wireshark uses a filetype called PCAP to record traffic. PCAPs are often distributed in CTF challenges to provide recorded traffic history.\n\n\nInterface\n\n\nUpon opening Wireshark, you are greeted with the option to open a PCAP or begin capturing network traffic on your device.\n\n\n\n\nThe network traffic displayed initially shows the packets in order of which they were captured. You can filter packets by protocol, source IP address, destination IP address, length, etc. \n\n\n\n\nIn order to apply filters, simply enter the constraining factor, for example 'http', in the display filter bar. \n\n\n\n\nFilters can be chained together using '\n' notation. In order to filter by IP, ensure a double equals '==' is used. \n\n\n\n\nThe most pertinent part of a packet is its data payload and protocol information.\n\n\n\n\nDecrypting SSL Traffic\n\n\nBy default, Wireshark cannot decrypt SSL traffic on your device unless you grant it specific certificates.\n\n\nHigh Level SSL Handshake Overview\n\n\nIn order for a network session to be encrypted properly, the client and server must share a common secret for which they can use to encrypt and decrypt data without someone in the middle being able to guess. The SSL Handshake loosely follows this format:\n\n\n\n\nThe client sends a list of availble cipher suites it can use along with a random set of bytes referred to as client_random\n\n\nThe server sends back the cipher suite that will be used, such as TLS_DHE_RSA_WITH_AES_128_CBC_SHA, along with a random set of bytes referred to as server_random\n\n\nThe client generates a pre-master secret, encrypts it, then sends it to the server.\n\n\nThe server and client then generate a common master secret using the selected cipher suite\n\n\nThe client and server begin communicating using this common secret\n\n\n\n\nDecryption Requirements\n\n\nThere are several ways to be able to decrypt traffic.\n\n\n\n\nIf you have the client and server random values \nand\n the pre-master secret, the master secret can be generated and used to decrypt the traffic\n\n\nIf you have the master secret, traffic can be decrypted easily\n\n\nIf the cipher-suite uses RSA, you can factor \nn\n in the key in order to break the encryption on the encrypted pre-master secret and generate the master secret with the client and server randoms", 
            "title": "What is Wireshark"
        }, 
        {
            "location": "/forensics/what-is-wireshark/#wireshark", 
            "text": "Wireshark  is a network protocol analyzer which is often used in CTF challenges to look at recorded network traffic. Wireshark uses a filetype called PCAP to record traffic. PCAPs are often distributed in CTF challenges to provide recorded traffic history.", 
            "title": "Wireshark"
        }, 
        {
            "location": "/forensics/what-is-wireshark/#interface", 
            "text": "Upon opening Wireshark, you are greeted with the option to open a PCAP or begin capturing network traffic on your device.   The network traffic displayed initially shows the packets in order of which they were captured. You can filter packets by protocol, source IP address, destination IP address, length, etc.    In order to apply filters, simply enter the constraining factor, for example 'http', in the display filter bar.    Filters can be chained together using ' ' notation. In order to filter by IP, ensure a double equals '==' is used.    The most pertinent part of a packet is its data payload and protocol information.", 
            "title": "Interface"
        }, 
        {
            "location": "/forensics/what-is-wireshark/#decrypting-ssl-traffic", 
            "text": "By default, Wireshark cannot decrypt SSL traffic on your device unless you grant it specific certificates.", 
            "title": "Decrypting SSL Traffic"
        }, 
        {
            "location": "/forensics/what-is-wireshark/#high-level-ssl-handshake-overview", 
            "text": "In order for a network session to be encrypted properly, the client and server must share a common secret for which they can use to encrypt and decrypt data without someone in the middle being able to guess. The SSL Handshake loosely follows this format:   The client sends a list of availble cipher suites it can use along with a random set of bytes referred to as client_random  The server sends back the cipher suite that will be used, such as TLS_DHE_RSA_WITH_AES_128_CBC_SHA, along with a random set of bytes referred to as server_random  The client generates a pre-master secret, encrypts it, then sends it to the server.  The server and client then generate a common master secret using the selected cipher suite  The client and server begin communicating using this common secret", 
            "title": "High Level SSL Handshake Overview"
        }, 
        {
            "location": "/forensics/what-is-wireshark/#decryption-requirements", 
            "text": "There are several ways to be able to decrypt traffic.   If you have the client and server random values  and  the pre-master secret, the master secret can be generated and used to decrypt the traffic  If you have the master secret, traffic can be decrypted easily  If the cipher-suite uses RSA, you can factor  n  in the key in order to break the encryption on the encrypted pre-master secret and generate the master secret with the client and server randoms", 
            "title": "Decryption Requirements"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/", 
            "text": "Stegonagraphy\n\n\nStegonagraphy is the practice of hiding data in plain sight. Stegonagraphy is often embedded in images or audio.\n\n\nYou could send a picture of a cat to a friend and hide text inside. Looking at the image, there\u2019s nothing to make anyone think there\u2019s a message hidden inside it.\n\n\n\n\nYou could also hide a second image inside the first.\n\n\n\n\nStegonagraphy Detection\n\n\nSo we can hide text and an image, how do we find out if there is hidden data?\n\n\n\n\nFileA and FileD appear the same, but they\u2019re different. Also, FileD was modified after it was copied, so it\u2019s possible there might be steganography in it.\n\n\nFileB and FileC don\u2019t appear to have been modified after being created. That doesn\u2019t rule out the possibility that there\u2019s steganography in them, but you\u2019re more likely to find it in fileD. This brings up two questions:\n\n\n\n\nCan we determine that there is steganography in fileD?\n\n\nIf there is, what was hidden in it?\n\n\n\n\nLSB Stegonagraphy\n\n\nFile are made of bytes. Each byte is composed of eight bits.\n\n\n\n\nChanging the least-significant bit (LSB) doesn\u2019t change the value very much.\n\n\n\n\nSo we can modify the LSB without changing the file noticeably. By doing so, we can hide a message inside.\n\n\nLSB Stegonagraphy in Images\n\n\nLSB Stegonagraphy or \nLeast Significant Bit\n Stegonagraphy is a method of stegonagraphy where data is recorded in the lowest bit of a byte.\n\n\nSay an image has a pixel with an RGB value of (255, 255, 255), the bits of those RGB values will look like\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBy modifying the lowest, or least significant, bit, we can use the 1 bit space across every RGB value for every pixel to construct a message.\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe reason stegonagraphy is hard to detect by sight is because a 1 bit difference in color is insignificant as seen below.\n\n\n\n\nExample\n\n\nLet\u2019s say we have an image, and part of it contains the following binary:\n\n\n\n\nAnd let\u2019s say we want to hide the character y inside.\n\n\nFirst, we need to convert the hidden message to binary.\n\n\n\n\nNow we take each bit from the hidden message and replace the LSB of the corresponding byte with it.\n\n\n\n\nAnd again:\n\n\n\n\nAnd again:\n\n\n\n\nAnd again:\n\n\n\n\nAnd again:\n\n\n\n\nAnd again:\n\n\n\n\nAnd again:\n\n\n\n\nAnd once more:\n\n\n\n\nDecoding LSB steganography is exactly the same as encoding, but in reverse. For each byte, grab the LSB and add it to your decoded message. Once you\u2019ve gone through each byte, convert all the LSBs you grabbed into text or a file. (You can use your file signature knowledge here!)\n\n\nWhat other types of steganography are there?\n\n\nSteganography is hard for the defense side, because there\u2019s practically an infinite number of ways it could be carried out. Here are a few examples:\n- LSB steganography: different bits, different bit combinations\n- Encode in every certain number of bytes \n- Use a password\n- Hide in different places\n- Use encryption on top of steganography", 
            "title": "What is Stegonagraphy"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#stegonagraphy", 
            "text": "Stegonagraphy is the practice of hiding data in plain sight. Stegonagraphy is often embedded in images or audio.  You could send a picture of a cat to a friend and hide text inside. Looking at the image, there\u2019s nothing to make anyone think there\u2019s a message hidden inside it.   You could also hide a second image inside the first.", 
            "title": "Stegonagraphy"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#stegonagraphy-detection", 
            "text": "So we can hide text and an image, how do we find out if there is hidden data?   FileA and FileD appear the same, but they\u2019re different. Also, FileD was modified after it was copied, so it\u2019s possible there might be steganography in it.  FileB and FileC don\u2019t appear to have been modified after being created. That doesn\u2019t rule out the possibility that there\u2019s steganography in them, but you\u2019re more likely to find it in fileD. This brings up two questions:   Can we determine that there is steganography in fileD?  If there is, what was hidden in it?", 
            "title": "Stegonagraphy Detection"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#lsb-stegonagraphy", 
            "text": "File are made of bytes. Each byte is composed of eight bits.   Changing the least-significant bit (LSB) doesn\u2019t change the value very much.   So we can modify the LSB without changing the file noticeably. By doing so, we can hide a message inside.", 
            "title": "LSB Stegonagraphy"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#lsb-stegonagraphy-in-images", 
            "text": "LSB Stegonagraphy or  Least Significant Bit  Stegonagraphy is a method of stegonagraphy where data is recorded in the lowest bit of a byte.  Say an image has a pixel with an RGB value of (255, 255, 255), the bits of those RGB values will look like     1  1  1  1  1  1  1  1                 By modifying the lowest, or least significant, bit, we can use the 1 bit space across every RGB value for every pixel to construct a message.     1  1  1  1  1  1  1  0                 The reason stegonagraphy is hard to detect by sight is because a 1 bit difference in color is insignificant as seen below.", 
            "title": "LSB Stegonagraphy in Images"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#example", 
            "text": "Let\u2019s say we have an image, and part of it contains the following binary:   And let\u2019s say we want to hide the character y inside.  First, we need to convert the hidden message to binary.   Now we take each bit from the hidden message and replace the LSB of the corresponding byte with it.   And again:   And again:   And again:   And again:   And again:   And again:   And once more:   Decoding LSB steganography is exactly the same as encoding, but in reverse. For each byte, grab the LSB and add it to your decoded message. Once you\u2019ve gone through each byte, convert all the LSBs you grabbed into text or a file. (You can use your file signature knowledge here!)", 
            "title": "Example"
        }, 
        {
            "location": "/forensics/what-is-stegonagraphy/#what-other-types-of-steganography-are-there", 
            "text": "Steganography is hard for the defense side, because there\u2019s practically an infinite number of ways it could be carried out. Here are a few examples:\n- LSB steganography: different bits, different bit combinations\n- Encode in every certain number of bytes \n- Use a password\n- Hide in different places\n- Use encryption on top of steganography", 
            "title": "What other types of steganography are there?"
        }, 
        {
            "location": "/forensics/what-is-disk-imaging/", 
            "text": "Disk Imaging\n\n\nA forensic image is an electronic copy of a drive (e.g. a hard drive, USB, etc.). It\u2019s a bit-by-\u00adbit or bitstream file that\u2019s an exact, unaltered copy of the media being duplicated.\n\n\nWikipedia said that the most straight\u00adforward disk imaging method is to read a disk from start to finish and write the data to a forensics image format. \u201cThis can be a time-consuming process, especially for disks with a large capacity,\u201d Wikipedia said.\n\n\nTo prevent write access to the disk, you can use a write blocker. It\u2019s also common to calculate a cryptographic hash of the entire disk when imaging it. \u201cCommonly-used cryptographic hashes are MD5, SHA1 and/or SHA256,\u201d said Wikipedia. \u201cBy recalculating the integrity hash at a later time, one can determine if the data in the disk image has been changed. This by itself provides no protection against intentional tampering, but it can indicate that the data was altered, e.g. due to corruption.\u201d\n\n\nWhy image a disk? Forensic imaging:\n- Prevents tampering with the original data\u00ad evidence\n- Allows you to play around with the copy, without worrying about messing up the original\n\n\nForensic Image Extraction Exmple\n\n\nThis example uses the tool \nAccessData FTK Imager\n.\n\n\nStep 1\n: Go to \nFile \n Create Disk Image\n\n\n\n\nStep 2\n: Select \nPhysical Drive\n, because the USB or hard drive you\u2019re imaging is a physical device or drive.\n\n\n\n\nStep 3\n: Select the drive you\u2019re imaging. The 1000 GB is my computer hard drive; the 128 MB is the USB that I want to image.\n\n\n\n\nStep 4\n: Add a new image destination\n\n\n\n\nStep 5\n: Select whichever image type you want. Choose \nRaw (dd)\n if you\u2019re a beginner, since it\u2019s the most common type\n\n\n\n\nStep 6\n: Fill in all the evidence information\n\n\n\n\nStep 7\n: Choose where you want to store it\n\n\n\n\nStep 8\n: The image destination has been added. Now you can start the image extraction\n\n\n\n\nStep 9\n: Wait for the image to be extracted\n\n\n\n\nStep 10\n: This is the completed extraction\n\n\n\n\nStep 11\n: Add the image you just created so that you can view it\n\n\n\n\nStep 12\n: This time, choose image file, since that\u2019s what you just created\n\n\n\n\nStep 13\n: Enter the path of the image you just created\n\n\n\n\nStep 14\n: View the image.\n\n\n\n\nEvidence tree\nStructure of the drive image\n\n\nFile list\nList of all the files in the drive image folder\n\n\nProperties\nProperties of the file/folder being examined\n\n\nHex viewer\nView of the drive/folders/files in hexadecimal\n\n\n\n\n\n\nStep 15\n: To view files in the USB, go to \nPartition\n \n1\n \n \n[\nUSB\n \nname\n]\n \n \n[\nroot\n]\n in the Evidence Tree and look in the File List\n\n\n\n\nStep 16\n: Selecting fileA, fileB, fileC, or fileD gives us some properties of the files \n a preview of each photo\n\n\n\n\nStep 17\n: Extract files of interest for further analysis by selecting, right-clicking and choosing \nExport Files", 
            "title": "What is Disk Imaging"
        }, 
        {
            "location": "/forensics/what-is-disk-imaging/#disk-imaging", 
            "text": "A forensic image is an electronic copy of a drive (e.g. a hard drive, USB, etc.). It\u2019s a bit-by-\u00adbit or bitstream file that\u2019s an exact, unaltered copy of the media being duplicated.  Wikipedia said that the most straight\u00adforward disk imaging method is to read a disk from start to finish and write the data to a forensics image format. \u201cThis can be a time-consuming process, especially for disks with a large capacity,\u201d Wikipedia said.  To prevent write access to the disk, you can use a write blocker. It\u2019s also common to calculate a cryptographic hash of the entire disk when imaging it. \u201cCommonly-used cryptographic hashes are MD5, SHA1 and/or SHA256,\u201d said Wikipedia. \u201cBy recalculating the integrity hash at a later time, one can determine if the data in the disk image has been changed. This by itself provides no protection against intentional tampering, but it can indicate that the data was altered, e.g. due to corruption.\u201d  Why image a disk? Forensic imaging:\n- Prevents tampering with the original data\u00ad evidence\n- Allows you to play around with the copy, without worrying about messing up the original", 
            "title": "Disk Imaging"
        }, 
        {
            "location": "/forensics/what-is-disk-imaging/#forensic-image-extraction-exmple", 
            "text": "This example uses the tool  AccessData FTK Imager .  Step 1 : Go to  File   Create Disk Image   Step 2 : Select  Physical Drive , because the USB or hard drive you\u2019re imaging is a physical device or drive.   Step 3 : Select the drive you\u2019re imaging. The 1000 GB is my computer hard drive; the 128 MB is the USB that I want to image.   Step 4 : Add a new image destination   Step 5 : Select whichever image type you want. Choose  Raw (dd)  if you\u2019re a beginner, since it\u2019s the most common type   Step 6 : Fill in all the evidence information   Step 7 : Choose where you want to store it   Step 8 : The image destination has been added. Now you can start the image extraction   Step 9 : Wait for the image to be extracted   Step 10 : This is the completed extraction   Step 11 : Add the image you just created so that you can view it   Step 12 : This time, choose image file, since that\u2019s what you just created   Step 13 : Enter the path of the image you just created   Step 14 : View the image.   Evidence tree\nStructure of the drive image  File list\nList of all the files in the drive image folder  Properties\nProperties of the file/folder being examined  Hex viewer\nView of the drive/folders/files in hexadecimal    Step 15 : To view files in the USB, go to  Partition   1     [ USB   name ]     [ root ]  in the Evidence Tree and look in the File List   Step 16 : Selecting fileA, fileB, fileC, or fileD gives us some properties of the files   a preview of each photo   Step 17 : Extract files of interest for further analysis by selecting, right-clicking and choosing  Export Files", 
            "title": "Forensic Image Extraction Exmple"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/", 
            "text": "Memory Forensics\n\n\nThere are plenty of traces of someone's activity on a computer, but perhaps some of the most valuble information can be found within memory dumps, that is images taken of RAM. These dumps of data are often very large, but can be analyzed using a tool called \nVolatility\n\n\nVolatility Basics\n\n\nMemory forensics isn't all that complicated, the hardest part would be using your toolset correctly. A good workflow is as follows:\n\n\n\n\nRun \nstrings\n for clues\n\n\nIdentify the image profile (which OS, version, etc.)\n\n\nDump processes and look for suspicious processes\n\n\nDump data related interesting processes\n\n\nView data in a format relating to the process (Word: docx, Notepad: txt, Photoshop: psd, etc.)\n\n\n\n\nProfile Identification\n\n\nIn order to properly use Volatility you must supply a profile with \n--profile=PROFILE\n, therefore before any sleuthing, you need to determine the profile using imageinfo:\n\n\n$ python vol.py -f ~/image.raw imageinfo\nVolatility Foundation Volatility Framework \n2\n.4\nDetermining profile based on KDBG search...\n\n          Suggested Profile\n(\ns\n)\n : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory \n(\nKernel AS\n)\n\n                     AS Layer2 : FileAddressSpace \n(\n/Users/Michael/Desktop/win7_trial_64bit.raw\n)\n\n                      PAE \ntype\n : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors : \n1\n\n     Image Type \n(\nService Pack\n)\n : \n0\n\n                KPCR \nfor\n CPU \n0\n : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and \ntime\n : \n2012\n-02-22 \n11\n:29:02 UTC+0000\n     Image \nlocal\n date and \ntime\n : \n2012\n-02-22 \n03\n:29:02 -0800\n\n\n\n\n\nDump Processes\n\n\nIn order to view processes, the \npslist\n or \npstree\n or \npsscan\n command can be used.\n\n\n$ python vol.py -f ~/image.raw pslist --profile\n=\nWin7SP0x64 pstree\nVolatility Foundation Volatility Framework \n2\n.5\nOffset\n(\nV\n)\n          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------\n0xffffa0ee12532180 System                    \n4\n      \n0\n    \n108\n        \n0\n ------      \n0\n \n2018\n-04-22 \n20\n:02:33 UTC+0000\n0xffffa0ee1389d040 smss.exe                \n232\n      \n4\n      \n3\n        \n0\n ------      \n0\n \n2018\n-04-22 \n20\n:02:33 UTC+0000\n...\n0xffffa0ee128c6780 VBoxTray.exe           \n3324\n   \n1123\n     \n10\n        \n0\n      \n1\n      \n0\n \n2018\n-04-22 \n20\n:02:55 UTC+0000\n0xffffa0ee14108780 OneDrive.exe           \n1422\n   \n1123\n     \n10\n        \n0\n      \n1\n      \n1\n \n2018\n-04-22 \n20\n:02:55 UTC+0000\n0xffffa0ee14ade080 svchost.exe             \n228\n    \n121\n      \n1\n        \n0\n      \n1\n      \n0\n \n2018\n-04-22 \n20\n:14:43 UTC+0000\n0xffffa0ee1122b080 notepad.exe            \n2019\n   \n1123\n      \n1\n        \n0\n      \n1\n      \n0\n \n2018\n-04-22 \n20\n:14:49 UTC+0000\n\n\n\n\n\nProcess Memory Dump\n\n\nDumping the memory of a process can prove to be fruitful, say we want to dump the data from notepad.exe:\n\n\n$ python vol.py -f ~/image.raw --profile\n=\nWin7SP0x64 memdump -p \n2019\n -D dump/\nVolatility Foundation Volatility Framework \n2\n.4\n************************************************************************\nWriting System \n[\n     \n2019\n]\n to \n2019\n.dmp\n\n$ ls -alh dump/2019.dmp\n-rw-r--r--  \n1\n user  staff   111M Apr \n22\n \n20\n:47 dump/2019.dmp\n\n\n\n\n\nOther Useful Commands\n\n\nThere are plenty of commands\n that Volatility offers but some highlights include:\n\n\n\n\n$ python vol.py -f IMAGE --profile\n=\nPROFILE connections\n: view network connections\n\n\n$ python vol.py -f IMAGE --profile\n=\nPROFILE cmdscan\n: view commands that were run in cmd prompt", 
            "title": "What is Memory Forensics"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#memory-forensics", 
            "text": "There are plenty of traces of someone's activity on a computer, but perhaps some of the most valuble information can be found within memory dumps, that is images taken of RAM. These dumps of data are often very large, but can be analyzed using a tool called  Volatility", 
            "title": "Memory Forensics"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#volatility-basics", 
            "text": "Memory forensics isn't all that complicated, the hardest part would be using your toolset correctly. A good workflow is as follows:   Run  strings  for clues  Identify the image profile (which OS, version, etc.)  Dump processes and look for suspicious processes  Dump data related interesting processes  View data in a format relating to the process (Word: docx, Notepad: txt, Photoshop: psd, etc.)", 
            "title": "Volatility Basics"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#profile-identification", 
            "text": "In order to properly use Volatility you must supply a profile with  --profile=PROFILE , therefore before any sleuthing, you need to determine the profile using imageinfo:  $ python vol.py -f ~/image.raw imageinfo\nVolatility Foundation Volatility Framework  2 .4\nDetermining profile based on KDBG search...\n\n          Suggested Profile ( s )  : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory  ( Kernel AS ) \n                     AS Layer2 : FileAddressSpace  ( /Users/Michael/Desktop/win7_trial_64bit.raw ) \n                      PAE  type  : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors :  1 \n     Image Type  ( Service Pack )  :  0 \n                KPCR  for  CPU  0  : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and  time  :  2012 -02-22  11 :29:02 UTC+0000\n     Image  local  date and  time  :  2012 -02-22  03 :29:02 -0800", 
            "title": "Profile Identification"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#dump-processes", 
            "text": "In order to view processes, the  pslist  or  pstree  or  psscan  command can be used.  $ python vol.py -f ~/image.raw pslist --profile = Win7SP0x64 pstree\nVolatility Foundation Volatility Framework  2 .5\nOffset ( V )           Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------\n0xffffa0ee12532180 System                     4        0      108          0  ------       0   2018 -04-22  20 :02:33 UTC+0000\n0xffffa0ee1389d040 smss.exe                 232        4        3          0  ------       0   2018 -04-22  20 :02:33 UTC+0000\n...\n0xffffa0ee128c6780 VBoxTray.exe            3324     1123       10          0        1        0   2018 -04-22  20 :02:55 UTC+0000\n0xffffa0ee14108780 OneDrive.exe            1422     1123       10          0        1        1   2018 -04-22  20 :02:55 UTC+0000\n0xffffa0ee14ade080 svchost.exe              228      121        1          0        1        0   2018 -04-22  20 :14:43 UTC+0000\n0xffffa0ee1122b080 notepad.exe             2019     1123        1          0        1        0   2018 -04-22  20 :14:49 UTC+0000", 
            "title": "Dump Processes"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#process-memory-dump", 
            "text": "Dumping the memory of a process can prove to be fruitful, say we want to dump the data from notepad.exe:  $ python vol.py -f ~/image.raw --profile = Win7SP0x64 memdump -p  2019  -D dump/\nVolatility Foundation Volatility Framework  2 .4\n************************************************************************\nWriting System  [       2019 ]  to  2019 .dmp\n\n$ ls -alh dump/2019.dmp\n-rw-r--r--   1  user  staff   111M Apr  22   20 :47 dump/2019.dmp", 
            "title": "Process Memory Dump"
        }, 
        {
            "location": "/forensics/what-is-memory-forensics/#other-useful-commands", 
            "text": "There are plenty of commands  that Volatility offers but some highlights include:   $ python vol.py -f IMAGE --profile = PROFILE connections : view network connections  $ python vol.py -f IMAGE --profile = PROFILE cmdscan : view commands that were run in cmd prompt", 
            "title": "Other Useful Commands"
        }, 
        {
            "location": "/forensics/what-is-a-hex-editor/", 
            "text": "Hex Editor\n\n\nA hexadecimal (hex) editor (also called a binary file editor or byte editor) is a computer program you can use to manipulate the fundamental binary data that constitutes a computer file. The name \u201chex\u201d comes from \u201chexadecimal,\u201d a standard numerical format for representing binary data. A typical computer file occupies multiple areas on the platter(s) of a disk drive, whose contents are combined to form the file. Hex editors that are designed to parse and edit sector data from the physical segments of floppy or hard disks are sometimes called sector editors or disk editors. A hex editor is used to see or edit the raw, exact contents of a file. Hex editors may used to correct data corrupted by a system or application. A \nlist of editors\n can be found on the forensics Wiki. You can download one and install it on your system.\n\n\nExample\n\n\nOpen fileA.jpg in a hex editor. (Most Hex editors have either a \u201cFile \n Open\u201d option or a simple drag and drop.)\n\n\n\n\nWhen you open fileA.jpg in your hex editor, you should see something similar to this:\n\n\n\n\nYour hex editor should also have a \u201cgo to\u201d or \u201cfind\u201d feature so you can jump to a specific byte.", 
            "title": "What is a Hex Editor"
        }, 
        {
            "location": "/forensics/what-is-a-hex-editor/#hex-editor", 
            "text": "A hexadecimal (hex) editor (also called a binary file editor or byte editor) is a computer program you can use to manipulate the fundamental binary data that constitutes a computer file. The name \u201chex\u201d comes from \u201chexadecimal,\u201d a standard numerical format for representing binary data. A typical computer file occupies multiple areas on the platter(s) of a disk drive, whose contents are combined to form the file. Hex editors that are designed to parse and edit sector data from the physical segments of floppy or hard disks are sometimes called sector editors or disk editors. A hex editor is used to see or edit the raw, exact contents of a file. Hex editors may used to correct data corrupted by a system or application. A  list of editors  can be found on the forensics Wiki. You can download one and install it on your system.", 
            "title": "Hex Editor"
        }, 
        {
            "location": "/forensics/what-is-a-hex-editor/#example", 
            "text": "Open fileA.jpg in a hex editor. (Most Hex editors have either a \u201cFile   Open\u201d option or a simple drag and drop.)   When you open fileA.jpg in your hex editor, you should see something similar to this:   Your hex editor should also have a \u201cgo to\u201d or \u201cfind\u201d feature so you can jump to a specific byte.", 
            "title": "Example"
        }, 
        {
            "location": "/cryptography/overview/", 
            "text": "Cryptography\n\n\nCryptography is the reason we can use banking apps, transmit sensitive information over the web, and in general protect our privacy. However, a large part of CTFs is breaking widely used encryption schemes which are improperly implemented. The math may seem daunting, but more often than not, a simple understanding of the underlying principles will allow you to find flaws and crack the code.\n\n\nThe word \u201ccryptography\u201d technically means the art of writing codes. When it comes to digital forensics, it\u2019s a method you can use to understand how data is constructed for your analysis.\n\n\nWhat is cryptography used for?\n\n\nUses in every day software\n\n\n\n\nSecuring web traffic (passwords, communication, etc.)\n\n\nSecuring copyrighted software code\n\n\n\n\nMalicious uses\n\n\n\n\nHiding malicious communication\n\n\nHiding malicious code\n\n\n\n\nTopics\n\n\n\n\nXOR\n\n\nCesear Cipher\n\n\nSubstitution Cipher\n\n\nVigenere Cipher\n\n\nHashing Functions\n\n\nBlock Ciphers\n\n\nStream Ciphers\n\n\nRSA", 
            "title": "Overview"
        }, 
        {
            "location": "/cryptography/overview/#cryptography", 
            "text": "Cryptography is the reason we can use banking apps, transmit sensitive information over the web, and in general protect our privacy. However, a large part of CTFs is breaking widely used encryption schemes which are improperly implemented. The math may seem daunting, but more often than not, a simple understanding of the underlying principles will allow you to find flaws and crack the code.  The word \u201ccryptography\u201d technically means the art of writing codes. When it comes to digital forensics, it\u2019s a method you can use to understand how data is constructed for your analysis.", 
            "title": "Cryptography"
        }, 
        {
            "location": "/cryptography/overview/#what-is-cryptography-used-for", 
            "text": "Uses in every day software   Securing web traffic (passwords, communication, etc.)  Securing copyrighted software code   Malicious uses   Hiding malicious communication  Hiding malicious code", 
            "title": "What is cryptography used for?"
        }, 
        {
            "location": "/cryptography/overview/#topics", 
            "text": "XOR  Cesear Cipher  Substitution Cipher  Vigenere Cipher  Hashing Functions  Block Ciphers  Stream Ciphers  RSA", 
            "title": "Topics"
        }, 
        {
            "location": "/cryptography/what-is-xor/", 
            "text": "XOR\n\n\nData Representation\n\n\nData can be represented in different bases, an 'A' needs to be a numerical representation of Base 2 or binary so computers can understand them\n\n\n\n\nXOR Basics\n\n\nAn XOR or \neXclusive OR\n is a bitwise operation indicated by \n^\n and shown by the following truth table:\n\n\n\n\n\n\n\n\nA\n\n\nB\n\n\nA ^ B\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n0\n\n\n1\n\n\n1\n\n\n\n\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\nSo what XOR'ing bytes in the action \n0xA0 ^ 0x2C\n translates to is:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0b10001100\n is equivelent to \n0x8C\n, a cool property of XOR is that it is reversable meaning \n0x8C ^ 0x2C = 0xA0\n and \n0x8C ^ 0xA0 = 0x2C\n\n\n\n\nWhat does this have to do with CTF?\n\n\nXOR is a cheap way to encrypt data with a password. Any data can be encrypted using XOR as shown in this Python example:\n\n\n \ndata\n \n=\n \nCAPTURETHEFLAG\n\n\n \nkey\n \n=\n \nA\n\n\n \nencrypted\n \n=\n \n.\njoin\n([\nchr\n(\nord\n(\nx\n)\n \n^\n \nord\n(\nkey\n))\n \nfor\n \nx\n \nin\n \ndata\n])\n\n\n \nencrypted\n\n\n\\x02\\x00\\x11\\x15\\x14\\x13\\x04\\x15\\t\\x04\\x07\\r\\x00\\x06\n\n\n \ndecrypted\n \n=\n \n.\njoin\n([\nchr\n(\nord\n(\nx\n)\n \n^\n \nord\n(\nkey\n))\n \nfor\n \nx\n \nin\n \nencrypted\n])\n\n\n \ndecrypted\n\n\nCAPTURETHEFLAG\n\n\n\n\n\n\nThis can be extended using a multibyte key by iterating in parallel with the data.\n\n\nExploiting XOR Encryption\n\n\nSingle Byte XOR Encryption\n\n\nSingle Byte XOR Encryption is trivial to bruteforce as there are only 255 key combinations to try.\n\n\nMultibyte XOR Encryption\n\n\nMultibyte XOR gets exponentially harder the longer the key, but if the encrypted text is long enough, character frequency analysis is a viable method to find the key. Character Frequency Analysis means that we split the cipher text into groups based on the number of characters in the key. These groups then are bruteforced using the idea that some letters appear more frequently in the english alphabet than others.", 
            "title": "What is XOR"
        }, 
        {
            "location": "/cryptography/what-is-xor/#xor", 
            "text": "", 
            "title": "XOR"
        }, 
        {
            "location": "/cryptography/what-is-xor/#data-representation", 
            "text": "Data can be represented in different bases, an 'A' needs to be a numerical representation of Base 2 or binary so computers can understand them", 
            "title": "Data Representation"
        }, 
        {
            "location": "/cryptography/what-is-xor/#xor-basics", 
            "text": "An XOR or  eXclusive OR  is a bitwise operation indicated by  ^  and shown by the following truth table:     A  B  A ^ B      0  0  0    0  1  1    1  0  1    1  1  0     So what XOR'ing bytes in the action  0xA0 ^ 0x2C  translates to is:                 1  0  1  0  0  0  0  0    0  0  1  0  1  1  0  0        1  0  0  0  1  1  0  0                 0b10001100  is equivelent to  0x8C , a cool property of XOR is that it is reversable meaning  0x8C ^ 0x2C = 0xA0  and  0x8C ^ 0xA0 = 0x2C", 
            "title": "XOR Basics"
        }, 
        {
            "location": "/cryptography/what-is-xor/#what-does-this-have-to-do-with-ctf", 
            "text": "XOR is a cheap way to encrypt data with a password. Any data can be encrypted using XOR as shown in this Python example:    data   =   CAPTURETHEFLAG    key   =   A    encrypted   =   . join ([ chr ( ord ( x )   ^   ord ( key ))   for   x   in   data ])    encrypted  \\x02\\x00\\x11\\x15\\x14\\x13\\x04\\x15\\t\\x04\\x07\\r\\x00\\x06    decrypted   =   . join ([ chr ( ord ( x )   ^   ord ( key ))   for   x   in   encrypted ])    decrypted  CAPTURETHEFLAG   This can be extended using a multibyte key by iterating in parallel with the data.", 
            "title": "What does this have to do with CTF?"
        }, 
        {
            "location": "/cryptography/what-is-xor/#exploiting-xor-encryption", 
            "text": "", 
            "title": "Exploiting XOR Encryption"
        }, 
        {
            "location": "/cryptography/what-is-xor/#single-byte-xor-encryption", 
            "text": "Single Byte XOR Encryption is trivial to bruteforce as there are only 255 key combinations to try.", 
            "title": "Single Byte XOR Encryption"
        }, 
        {
            "location": "/cryptography/what-is-xor/#multibyte-xor-encryption", 
            "text": "Multibyte XOR gets exponentially harder the longer the key, but if the encrypted text is long enough, character frequency analysis is a viable method to find the key. Character Frequency Analysis means that we split the cipher text into groups based on the number of characters in the key. These groups then are bruteforced using the idea that some letters appear more frequently in the english alphabet than others.", 
            "title": "Multibyte XOR Encryption"
        }, 
        {
            "location": "/cryptography/what-is-a-substitution-cipher/", 
            "text": "Substitution Cipher\n\n\nA Substitution Cipher is system of encryption where different symobls substitute a normal alphabet.", 
            "title": "What is a Substitution Cipher"
        }, 
        {
            "location": "/cryptography/what-is-a-substitution-cipher/#substitution-cipher", 
            "text": "A Substitution Cipher is system of encryption where different symobls substitute a normal alphabet.", 
            "title": "Substitution Cipher"
        }, 
        {
            "location": "/cryptography/what-is-caesar-cipher-rot-13/", 
            "text": "Caesar Cipher/ROT 13\n\n\nThe Caesar Cipher or Caesar Shift is a cipher which uses the alphabet in order to encode texts.\n\n\nCAESAR\n encoded with a shift of 8 is \nKIMAIZ\n so \nABCDEFGHIJKLMNOPQRSTUVWXYZ\n becomes \nIJKLMNOPQRSTUVWXYZABCDEFGH\n\n\nROT13 is the same thing but a fixed shift of 13, this is a trivial cipher to bruteforce because there are only 25 shifts.", 
            "title": "Caesar Cipher/ROT 13"
        }, 
        {
            "location": "/cryptography/what-is-caesar-cipher-rot-13/#caesar-cipherrot-13", 
            "text": "The Caesar Cipher or Caesar Shift is a cipher which uses the alphabet in order to encode texts.  CAESAR  encoded with a shift of 8 is  KIMAIZ  so  ABCDEFGHIJKLMNOPQRSTUVWXYZ  becomes  IJKLMNOPQRSTUVWXYZABCDEFGH  ROT13 is the same thing but a fixed shift of 13, this is a trivial cipher to bruteforce because there are only 25 shifts.", 
            "title": "Caesar Cipher/ROT 13"
        }, 
        {
            "location": "/cryptography/what-is-a-vigenere-cipher/", 
            "text": "Vigenere Cipher\n\n\nA Vigenere Cipher is an extended \nCaesar Cipher\n where a message is encrypted using various Caesar shifted alphabets.\n\n\nThe following table can be used to encode a message:\n\n\n\nEncryption\n\n\nFor example, encrypting the text \nSUPERSECRET\n with \nCODE\n would follow this process:\n\n\n\n\nCODE\n gets padded to the length of \nSUPERSECRET\n so the key becomes \nCODECODECOD\n\n\nFor each letter in \nSUPERSECRET\n we use the table to get the Alphabet to use, in this instance row \nC\n and column \nS\n\n\nThe ciphertext's first letter then becomes \nU\n\n\nWe eventually get \nUISITGHGTSW\n\n\n\n\nDecryption\n\n\n\n\nGo to the row of the key, in this case \nC\n \n\n\nFind the letter of the cipher text in this row, in this case \nU\n\n\nThe column is the first letter of the decrypted ciphertext, so we get \nS\n\n\nAfter repeating this process we get back to \nSUPERSECRET", 
            "title": "What is a Vigenere Cipher"
        }, 
        {
            "location": "/cryptography/what-is-a-vigenere-cipher/#vigenere-cipher", 
            "text": "A Vigenere Cipher is an extended  Caesar Cipher  where a message is encrypted using various Caesar shifted alphabets.  The following table can be used to encode a message:", 
            "title": "Vigenere Cipher"
        }, 
        {
            "location": "/cryptography/what-is-a-vigenere-cipher/#encryption", 
            "text": "For example, encrypting the text  SUPERSECRET  with  CODE  would follow this process:   CODE  gets padded to the length of  SUPERSECRET  so the key becomes  CODECODECOD  For each letter in  SUPERSECRET  we use the table to get the Alphabet to use, in this instance row  C  and column  S  The ciphertext's first letter then becomes  U  We eventually get  UISITGHGTSW", 
            "title": "Encryption"
        }, 
        {
            "location": "/cryptography/what-is-a-vigenere-cipher/#decryption", 
            "text": "Go to the row of the key, in this case  C    Find the letter of the cipher text in this row, in this case  U  The column is the first letter of the decrypted ciphertext, so we get  S  After repeating this process we get back to  SUPERSECRET", 
            "title": "Decryption"
        }, 
        {
            "location": "/cryptography/what-are-hashing-functions/", 
            "text": "Hashing Functions\n\n\nHashing functions are one way functions which theoretically provide a unique output for every input. MD5, SHA-1, and other hashes which were considered secure are now found to have \ncollisions\n or two different pieces of data which produce the same supposed unique output.\n\n\nString Hashing\n\n\nA string hash is a number or string generated using an algorithm that runs on text or data.\n\n\nThe idea is that each hash should be unique to the text or data (although sometimes it isn\u2019t). For example, the hash for \u201cdog\u201d should be different from other hashes.\n\n\nYou can use command line tools tools or online resources such as this one.\nExample:\n\n$ \necho\n -n password \n|\n md5  5f4dcc3b5aa765d61d8327deb882cf99\n\nHere, \u201cpassword\u201d is hashed with different hashing algorithms:\n\n\n\n\nSHA-1\n: 5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8\n\n\nSHA-2\n: 5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8\n\n\nMD5\n: 5F4DCC3B5AA765D61D8327DEB882CF99\n\n\nCRC32\n: BBEDA74F\n\n\n\n\nGenerally, when verifying a hash visually, you can simply look at the first and last four characters of the string.\n\n\nFile Hashing\n\n\nA file hash is a number or string generated using an algorithm that is run on text or data. The premise is that it should be unique to the text or data. If the file or text changes in any way, the hash will change.\n\n\nWhat is it used for?\n- File and data identification\n- Password/certificate storage comparison\n\n\nHow can we determine the hash of a file? You can use the md5sum command (or similar).\n\n\n$ md5sum samplefile.txt\n3b85ec9ab2984b91070128be6aae25eb samplefile.txt\n\n\n\n\n\nHash Collisions\n\n\nA collision is when two pieces of data or text have the same cryptographic hash. This is very rare.\n\n\nWhat\u2019s significant about collisions is that they can be used to crack password hashes. Passwords are usually stored as hashes on a computer, since it\u2019s hard to get the passwords from hashes.\n\n\n\n\nIf you bruteforce by trying every possible piece of text or data, eventually you\u2019ll find something with the same hash. Enter it, and the computer accepts it as if you entered the actual password.\n\n\nTwo different files on the same hard drive with the same cryptographic hash can be very interesting.\n\n\n\u201cIt\u2019s now well-known that the cryptographic hash function MD5 has been broken,\u201d \nsaid Peter Selinger of Dalhousie University\n. \u201cIn March 2005, Xiaoyun Wang and Hongbo Yu of Shandong University in China published an article in which they described an algorithm that can find two different sequences of 128 bytes with the same MD5 hash.\u201d\n\n\nFor example, he cited this famous pair:\n\n\n\n\nand\n\n\n\n\nEach of these blocks has MD5 hash 79054025255fb1a26e4bc422aef54eb4.\n\n\nSelinger said that \u201cthe algorithm of Wang and Yu can be used to create files of arbitrary length that have identical MD5 hashes, and that differ only in 128 bytes somewhere in the middle of the file. Several people have used this technique to create pairs of interesting files with identical MD5 hashes.\u201d\n\n\nBen Laurie \nhas a nice website that visualizes this MD5 collision\n. For a non-technical, though slightly outdated, introduction to hash functions, see \nSteve Friedl\u2019s Illustrated Guide\n. And \nhere\u2019s a good article\n from DFI News that explores the same topic.", 
            "title": "What are Hashing Functions"
        }, 
        {
            "location": "/cryptography/what-are-hashing-functions/#hashing-functions", 
            "text": "Hashing functions are one way functions which theoretically provide a unique output for every input. MD5, SHA-1, and other hashes which were considered secure are now found to have  collisions  or two different pieces of data which produce the same supposed unique output.", 
            "title": "Hashing Functions"
        }, 
        {
            "location": "/cryptography/what-are-hashing-functions/#string-hashing", 
            "text": "A string hash is a number or string generated using an algorithm that runs on text or data.  The idea is that each hash should be unique to the text or data (although sometimes it isn\u2019t). For example, the hash for \u201cdog\u201d should be different from other hashes.  You can use command line tools tools or online resources such as this one.\nExample: $  echo  -n password  |  md5  5f4dcc3b5aa765d61d8327deb882cf99 \nHere, \u201cpassword\u201d is hashed with different hashing algorithms:   SHA-1 : 5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8  SHA-2 : 5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8  MD5 : 5F4DCC3B5AA765D61D8327DEB882CF99  CRC32 : BBEDA74F   Generally, when verifying a hash visually, you can simply look at the first and last four characters of the string.", 
            "title": "String Hashing"
        }, 
        {
            "location": "/cryptography/what-are-hashing-functions/#file-hashing", 
            "text": "A file hash is a number or string generated using an algorithm that is run on text or data. The premise is that it should be unique to the text or data. If the file or text changes in any way, the hash will change.  What is it used for?\n- File and data identification\n- Password/certificate storage comparison  How can we determine the hash of a file? You can use the md5sum command (or similar).  $ md5sum samplefile.txt\n3b85ec9ab2984b91070128be6aae25eb samplefile.txt", 
            "title": "File Hashing"
        }, 
        {
            "location": "/cryptography/what-are-hashing-functions/#hash-collisions", 
            "text": "A collision is when two pieces of data or text have the same cryptographic hash. This is very rare.  What\u2019s significant about collisions is that they can be used to crack password hashes. Passwords are usually stored as hashes on a computer, since it\u2019s hard to get the passwords from hashes.   If you bruteforce by trying every possible piece of text or data, eventually you\u2019ll find something with the same hash. Enter it, and the computer accepts it as if you entered the actual password.  Two different files on the same hard drive with the same cryptographic hash can be very interesting.  \u201cIt\u2019s now well-known that the cryptographic hash function MD5 has been broken,\u201d  said Peter Selinger of Dalhousie University . \u201cIn March 2005, Xiaoyun Wang and Hongbo Yu of Shandong University in China published an article in which they described an algorithm that can find two different sequences of 128 bytes with the same MD5 hash.\u201d  For example, he cited this famous pair:   and   Each of these blocks has MD5 hash 79054025255fb1a26e4bc422aef54eb4.  Selinger said that \u201cthe algorithm of Wang and Yu can be used to create files of arbitrary length that have identical MD5 hashes, and that differ only in 128 bytes somewhere in the middle of the file. Several people have used this technique to create pairs of interesting files with identical MD5 hashes.\u201d  Ben Laurie  has a nice website that visualizes this MD5 collision . For a non-technical, though slightly outdated, introduction to hash functions, see  Steve Friedl\u2019s Illustrated Guide . And  here\u2019s a good article  from DFI News that explores the same topic.", 
            "title": "Hash Collisions"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/", 
            "text": "Block Ciphers\n\n\nA \nBlock Cipher\n is an algorithm which is used in conjunction with a cryptosystem in order to package a message into evenly distributed 'blocks' which are encrypted one at a time.\n\n\nDefinitions\n\n\n\n\nMode of Operation: How a block cipher is applied to an amount of data which exceeds a block's size\n\n\nInitialization Vector (IV): A sequence of bytes which is used to randomize encryption even if the same plaintext is encrypted\n\n\nStarting Variable (SV): Similar to the IV, except it is used during the first block to provide a random seed during encryption\n\n\nPadding: Padding is used to ensure that the block sizes all line up and ensure the last block fits the block cipher\n\n\nPlaintext: Unencrypted text; Data without obfuscation\n\n\nKey: A secret used to encrypt plaintext\n\n\nCiphertext: Plaintext encrypted with a key\n\n\n\n\nCommon Block Ciphers\n\n\n\n\n\n\n\n\nMode\n\n\nFormulas\n\n\nCiphertext\n\n\n\n\n\n\n\n\n\n\nECB\n\n\nY\ni\n = F(PlainText\ni\n, Key)\n\n\nY\ni\n\n\n\n\n\n\nCBC\n\n\nY\ni\n = PlainText\ni\n XOR Ciphertext\ni-1\n\n\nF(Y, key); Ciphertext\n0\n = IV\n\n\n\n\n\n\nPCBC\n\n\nY\ni\n = PlainText\ni\n XOR (Ciphertext\ni-1\n XOR PlainText\ni-1\n)\n\n\nF(Y, key); Ciphertext\n0\n = IV\n\n\n\n\n\n\nCFB\n\n\nY\ni\n = Ciphertext\ni-1\n\n\nPlaintext XOR F(Y, key); Ciphertext\n0\n = IV\n\n\n\n\n\n\nOFB\n\n\nY\ni\n = F(Key, I\ni-1\n);Y\n0\n=IV\n\n\nPlaintext XOR Y\ni\n\n\n\n\n\n\nCTR\n\n\nY\ni\n = F(Key, IV + g(i));IV = token();\n\n\nPlaintext XOR Y\ni\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nIn this case \ni\n represents an index over the # of blocks in the plaintext. F() and g() represent the function used to convert plaintext into ciphertext.\n\n\n\n\nElectronic Codebook (ECB)\n\n\nECB is the most basic block cipher, it simply chunks up plaintext into blocks and independently encrypts those blocks and chains them all into a ciphertext.\n\n\n\n\n\n\nFlaws\n\n\nBecause ECB independently encrypts the blocks, patterns in data can still be seen clearly, as shown in the CBC Penguin image below.\n\n\n\n\n\n\n\n\nOriginal Image\n\n\nECB Image\n\n\nOther Block Cipher Modes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCipher Block Chaining (CBC)\n\n\nCBC is an improvement upon ECB where an Initialization Vector is used in order to add randomness. The encrypted previous block is used as the IV for each sequential block meaning that the encryption process cannot be parallelized. CBC has been declining in popularity due to a variety of\n\n\n\n\n\n\n\n\nNote\n\n\nEven though the encryption process cannot be parallelized, the decryption process can be parallelized. If the wrong IV is used for decryption it will only affect the first block as the decryption of all other blocks depends on the \nciphertext\n not the plaintext.\n\n\n\n\nPropogating Cipher Block Chaining (PCBC)\n\n\nPCBC is a less used cipher which modifies CBC so that decryption is also not parallelizable. It also cannot be decrypted from any point as changes made during the decryption and encryption process \"propogate\" throughout the blocks, meaning that both the plaintext and ciphertext are used when encrypting or decrypting as seen in the images below.\n\n\n\n\n\n\nCounter (CTR)\n\n\n\n\nNote\n\n\nCounter is also known as CM, integer counter mode (ICM), and segmented integer counter (SIC)\n\n\n\n\nCTR mode makes the block cipher similar to a stream cipher and it functions by adding a counter with each block in combination with a nonce and key to XOR the plaintext to produce the ciphertext. Similarly, the decryption process is the exact same except instead of XORing the plaintext, the ciphertext is XORed. This means that the process is parallelizable for both encryption and decryption \nand\n you can begin from anywhere as the counter for any block can be deduced easily.\n\n\n\n\n\n\nSecurity Considerations\n\n\nIf the nonce chosen is non-random, it is important to concatonate the nonce with the counter (high 64 bits to the nonce, low 64 bits to the counter) as adding or XORing the nonce with the counter would break security as an attacker can cause a collisions with the nonce and counter. An attacker with access to providing a plaintext, nonce and counter can then decrypt a block by using the ciphertext as seen in the decryption image.\n\n\nPadding Oracle Attack\n\n\nA Padding Oracle Attack sounds complex, but essentially means abusing a block cipher by changing the length of input and being able to determine the plaintext.\n\n\nRequirements\n\n\n\n\nAn oracle, or program, which encrypts data using CBC\n\n\nContinual use of the same key\n\n\n\n\nExecution\n\n\n\n\nIf we have two blocks of ciphertext, C\n1\n and C\n2\n, we can get the plaintext P\n2\n\n\nSince we know that CBC decryptionis dependent on the prior ciphertext, if we change the last byte of C\n1\n we can see if C\n2\n has correct padding\n\n\nIf it is correctly padded we know that the last byte of the plaintext\n\n\nIf not, we can increase our byte by one and repeat until we have a successful padding\n\n\nWe then repeat this for all successive bytes following C\n1\n and if the block is 16 bytes we can expect a maximum of 4080 attempts which is trivial", 
            "title": "What are Block Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#block-ciphers", 
            "text": "A  Block Cipher  is an algorithm which is used in conjunction with a cryptosystem in order to package a message into evenly distributed 'blocks' which are encrypted one at a time.", 
            "title": "Block Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#definitions", 
            "text": "Mode of Operation: How a block cipher is applied to an amount of data which exceeds a block's size  Initialization Vector (IV): A sequence of bytes which is used to randomize encryption even if the same plaintext is encrypted  Starting Variable (SV): Similar to the IV, except it is used during the first block to provide a random seed during encryption  Padding: Padding is used to ensure that the block sizes all line up and ensure the last block fits the block cipher  Plaintext: Unencrypted text; Data without obfuscation  Key: A secret used to encrypt plaintext  Ciphertext: Plaintext encrypted with a key", 
            "title": "Definitions"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#common-block-ciphers", 
            "text": "Mode  Formulas  Ciphertext      ECB  Y i  = F(PlainText i , Key)  Y i    CBC  Y i  = PlainText i  XOR Ciphertext i-1  F(Y, key); Ciphertext 0  = IV    PCBC  Y i  = PlainText i  XOR (Ciphertext i-1  XOR PlainText i-1 )  F(Y, key); Ciphertext 0  = IV    CFB  Y i  = Ciphertext i-1  Plaintext XOR F(Y, key); Ciphertext 0  = IV    OFB  Y i  = F(Key, I i-1 );Y 0 =IV  Plaintext XOR Y i    CTR  Y i  = F(Key, IV + g(i));IV = token();  Plaintext XOR Y i      Note  In this case  i  represents an index over the # of blocks in the plaintext. F() and g() represent the function used to convert plaintext into ciphertext.", 
            "title": "Common Block Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#electronic-codebook-ecb", 
            "text": "ECB is the most basic block cipher, it simply chunks up plaintext into blocks and independently encrypts those blocks and chains them all into a ciphertext.", 
            "title": "Electronic Codebook (ECB)"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#flaws", 
            "text": "Because ECB independently encrypts the blocks, patterns in data can still be seen clearly, as shown in the CBC Penguin image below.     Original Image  ECB Image  Other Block Cipher Modes", 
            "title": "Flaws"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#cipher-block-chaining-cbc", 
            "text": "CBC is an improvement upon ECB where an Initialization Vector is used in order to add randomness. The encrypted previous block is used as the IV for each sequential block meaning that the encryption process cannot be parallelized. CBC has been declining in popularity due to a variety of     Note  Even though the encryption process cannot be parallelized, the decryption process can be parallelized. If the wrong IV is used for decryption it will only affect the first block as the decryption of all other blocks depends on the  ciphertext  not the plaintext.", 
            "title": "Cipher Block Chaining (CBC)"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#propogating-cipher-block-chaining-pcbc", 
            "text": "PCBC is a less used cipher which modifies CBC so that decryption is also not parallelizable. It also cannot be decrypted from any point as changes made during the decryption and encryption process \"propogate\" throughout the blocks, meaning that both the plaintext and ciphertext are used when encrypting or decrypting as seen in the images below.", 
            "title": "Propogating Cipher Block Chaining (PCBC)"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#counter-ctr", 
            "text": "Note  Counter is also known as CM, integer counter mode (ICM), and segmented integer counter (SIC)   CTR mode makes the block cipher similar to a stream cipher and it functions by adding a counter with each block in combination with a nonce and key to XOR the plaintext to produce the ciphertext. Similarly, the decryption process is the exact same except instead of XORing the plaintext, the ciphertext is XORed. This means that the process is parallelizable for both encryption and decryption  and  you can begin from anywhere as the counter for any block can be deduced easily.", 
            "title": "Counter (CTR)"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#security-considerations", 
            "text": "If the nonce chosen is non-random, it is important to concatonate the nonce with the counter (high 64 bits to the nonce, low 64 bits to the counter) as adding or XORing the nonce with the counter would break security as an attacker can cause a collisions with the nonce and counter. An attacker with access to providing a plaintext, nonce and counter can then decrypt a block by using the ciphertext as seen in the decryption image.", 
            "title": "Security Considerations"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#padding-oracle-attack", 
            "text": "A Padding Oracle Attack sounds complex, but essentially means abusing a block cipher by changing the length of input and being able to determine the plaintext.", 
            "title": "Padding Oracle Attack"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#requirements", 
            "text": "An oracle, or program, which encrypts data using CBC  Continual use of the same key", 
            "title": "Requirements"
        }, 
        {
            "location": "/cryptography/what-are-block-ciphers/#execution", 
            "text": "If we have two blocks of ciphertext, C 1  and C 2 , we can get the plaintext P 2  Since we know that CBC decryptionis dependent on the prior ciphertext, if we change the last byte of C 1  we can see if C 2  has correct padding  If it is correctly padded we know that the last byte of the plaintext  If not, we can increase our byte by one and repeat until we have a successful padding  We then repeat this for all successive bytes following C 1  and if the block is 16 bytes we can expect a maximum of 4080 attempts which is trivial", 
            "title": "Execution"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/", 
            "text": "Stream Ciphers\n\n\nA Stream Cipher is used for symmetric key cryptography, or when the same key is used to encrypt and decrypt data. Stream Ciphers encrypt pseudorandom sequences with bits of plaintext in order to generate ciphertext, usually with XOR. A good way to think about Stream Ciphers is to think of them as generating one-time pads from a given state. \n\n\nDefinitions\n\n\n\n\nA \nkeystream\n is a sequence of pseudorandom digits which extend to the length of the plaintext in order to uniquely encrypt each character based on the corresponding digit in the keystream\n\n\n\n\nOne Time Pads\n\n\nA \none time pad\n is an encryption mechanism whereby the entire plaintext is XOR'd with a random sequence of numbers in order to generate a random ciphertext. The advantage of the one time pad is that it offers an immense amount of security BUT in order for it to be useful, the randomly generated key must be distributed on a separate secure channel, meaning that one time pads have little use in modern day cryptographic applications on the internet. Stream ciphers extend upon this idea by using a key, usually 128 bit in length, in order to seed a pseudorandom \nkeystream\n which is used to encrypt the text.\n\n\nTypes of Stream Ciphers\n\n\nSynchronous Stream Ciphers\n\n\nA Synchronous Stream Cipher generates a keystream based on internal states \nnot\n related to the plaintext or ciphertext. This means that the stream is generated pseudorandomly outside of the context of what is being encrypted. A \nbinary additive stream cipher\n is the term used for a stream cipher which XOR's the bits with the bits of the plaintext. Encryption and decryption require that the synchronus state cipher be in the same state, otherwise the message cannot be decrypted. \n\n\nSelf-synchronizing Stream Ciphers\n\n\nA Self-synchronizing Stream Cipher, also known as an asynchronous stream cipher or ciphertext autokey (CTAK), is a stream cipher which uses the previous \nN\n digits in order to compute the keystream used for the next \nN\n characters.\n\n\n\n\nNote\n\n\nSeems a lot like block ciphers doesn't it? That's because block cipher feedback mode (CFB) is an example of a self-synchronizing stream ciphers.\n\n\n\n\nStream Cipher Vulnerabilities\n\n\nKey Reuse\n\n\nThe key tenet of using stream ciphers securely is to \nNEVER\n repeat key use because of the communative property of XOR. If C\n1\n and C\n2\n have been XOR'd with a key K, retrieving that key K is trivial because C\n1\n XOR C\n2\n = P\n1\n XOR P\n2\n and having an english language based XOR means that cryptoanalysis tools such as a character frequency analysis will work well due to the low entropy of the english language.\n\n\nBit-flipping Attack\n\n\nAnother key tenet of using stream ciphers securely is considering that just because a message has been decrypted, it does not mean the message has not been tampered with. Because decryption is based on state, if an attacker knows the layout of the plaintext, a Man in the Middle (MITM) attack can flip a bit during transit altering the underlying ciphertext. If a ciphertext decrypts to 'Transfer $1000', then a middleman can flip a single bit in order for the ciphertext to decrypt to 'Transfer $9000' because changing a single character in the ciphertext does not affect the state in a synchronus stream cipher.", 
            "title": "What are Stream Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#stream-ciphers", 
            "text": "A Stream Cipher is used for symmetric key cryptography, or when the same key is used to encrypt and decrypt data. Stream Ciphers encrypt pseudorandom sequences with bits of plaintext in order to generate ciphertext, usually with XOR. A good way to think about Stream Ciphers is to think of them as generating one-time pads from a given state.", 
            "title": "Stream Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#definitions", 
            "text": "A  keystream  is a sequence of pseudorandom digits which extend to the length of the plaintext in order to uniquely encrypt each character based on the corresponding digit in the keystream", 
            "title": "Definitions"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#one-time-pads", 
            "text": "A  one time pad  is an encryption mechanism whereby the entire plaintext is XOR'd with a random sequence of numbers in order to generate a random ciphertext. The advantage of the one time pad is that it offers an immense amount of security BUT in order for it to be useful, the randomly generated key must be distributed on a separate secure channel, meaning that one time pads have little use in modern day cryptographic applications on the internet. Stream ciphers extend upon this idea by using a key, usually 128 bit in length, in order to seed a pseudorandom  keystream  which is used to encrypt the text.", 
            "title": "One Time Pads"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#types-of-stream-ciphers", 
            "text": "", 
            "title": "Types of Stream Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#synchronous-stream-ciphers", 
            "text": "A Synchronous Stream Cipher generates a keystream based on internal states  not  related to the plaintext or ciphertext. This means that the stream is generated pseudorandomly outside of the context of what is being encrypted. A  binary additive stream cipher  is the term used for a stream cipher which XOR's the bits with the bits of the plaintext. Encryption and decryption require that the synchronus state cipher be in the same state, otherwise the message cannot be decrypted.", 
            "title": "Synchronous Stream Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#self-synchronizing-stream-ciphers", 
            "text": "A Self-synchronizing Stream Cipher, also known as an asynchronous stream cipher or ciphertext autokey (CTAK), is a stream cipher which uses the previous  N  digits in order to compute the keystream used for the next  N  characters.   Note  Seems a lot like block ciphers doesn't it? That's because block cipher feedback mode (CFB) is an example of a self-synchronizing stream ciphers.", 
            "title": "Self-synchronizing Stream Ciphers"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#stream-cipher-vulnerabilities", 
            "text": "", 
            "title": "Stream Cipher Vulnerabilities"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#key-reuse", 
            "text": "The key tenet of using stream ciphers securely is to  NEVER  repeat key use because of the communative property of XOR. If C 1  and C 2  have been XOR'd with a key K, retrieving that key K is trivial because C 1  XOR C 2  = P 1  XOR P 2  and having an english language based XOR means that cryptoanalysis tools such as a character frequency analysis will work well due to the low entropy of the english language.", 
            "title": "Key Reuse"
        }, 
        {
            "location": "/cryptography/what-are-stream-ciphers/#bit-flipping-attack", 
            "text": "Another key tenet of using stream ciphers securely is considering that just because a message has been decrypted, it does not mean the message has not been tampered with. Because decryption is based on state, if an attacker knows the layout of the plaintext, a Man in the Middle (MITM) attack can flip a bit during transit altering the underlying ciphertext. If a ciphertext decrypts to 'Transfer $1000', then a middleman can flip a single bit in order for the ciphertext to decrypt to 'Transfer $9000' because changing a single character in the ciphertext does not affect the state in a synchronus stream cipher.", 
            "title": "Bit-flipping Attack"
        }, 
        {
            "location": "/cryptography/what-is-rsa/", 
            "text": "RSA\n\n\nRSA, which is an abbreviation of the author's names (Rivest\u2013Shamir\u2013Adleman), is a cryptosystem which allows for asymmetric encryption. Asymmetric cryptosystems are alos commonly referred to as \nPublic Key Cryptography\n where a public key is used to encrypt data and only a secret, private key can be used to decrypt the data.\n\n\nDefinitions\n\n\n\n\nThe \nPublic Key\n is made up of (\nn\n, \ne\n)\n\n\nThe \nPrivate Key\n is made up of (\nn\n, \nd\n)\n\n\nThe message is represented as \nm\n and is converted into a number\n\n\nThe encrypted message or ciphertext is represented by \nc\n\n\np\n and \nq\n are prime numbers which make up \nn\n\n\ne\n is the public exponent\n\n\nn\n is the modulus and its length in bits is the bit length (i.e. 1024 bit RSA)\n\n\nd\n is the private exponent\n\n\nThe totient \u03bb(\nn\n) is used to compute \nd\n and is equal to the lcm(\np\n-1, \nq\n-1), another definition for \u03bb(\nn\n) is that \u03bb(\npq\n) = lcm(\u03bb(\np\n), \u03bb(\nq\n))\n\n\n\n\nWhat makes RSA viable?\n\n\nIf public \nn\n, public \ne\n, private \nd\n are all very large numbers and a message \nm\n holds true for 0 \n \nm\n \n \nn\n, then we can say:\n\n\n\n\n(\nm\ne\n)\nd\n \u2261 \nm\n (mod \nn\n)\n\n\n\n\n\n\nNote\n\n\nThe triple equals sign in this case refers to \nmodular congruence\n which in this case means that there exists an integer \nk\n such that (\nm\ne\n)\nd\n = \nkn\n + \nm\n\n\n\n\nRSA is viable because it is incredibly hard to find \nd\n even with \nm\n, \nn\n, and \ne\n because factoring large numbers is an arduous process.\n\n\nImplementation\n\n\nRSA follows 4 steps to be implemented:\n1. Key Generation\n2. Encryption\n3. Decryption\n\n\nKey Generation\n\n\nWe are going to follow along Wikipedia's small numbers example in order to make this idea a bit easier to understand.\n\n\n\n\nNote\n\n\nIn This example we are using \nCarmichael's\n totient function where \u03bb(n) = lcm(\u03bb(p), \u03bb(q)), but \nEuler's\n totient function is perfectly valid to use with RSA. Euler's totient is \u03c6(n) = (p \u2212 1)(q \u2212 1)\n\n\n\n\n\n\nChoose two prime numbers such as: \n\n\np\n = 61 and \nq\n = 53\n\n\n\n\n\n\nFind \nn\n: \n\n\nn\n = \npq\n = 3233\n\n\n\n\n\n\n\n\nCalculate \u03bb(\nn\n) = lcm(\np\n-1, \nq\n-1) \n\n\n\n\n\u03bb(3233) = lcm(60, 52) = 780\n\n\n\n\n\n\n\n\nChoose a public exponent such that 1 \n \ne\n \n \u03bb(\nn\n) and is coprime (not a factor of) \u03bb(\nn\n). The standard is most cases is 65537, but we will be using: \n\n\n\n\ne\n = 17\n\n\n\n\n\n\nCalculate \nd\n as the modular multiplicative inverse or in english find \nd\n such that: \nd\n x \ne\n mod \u03bb(\nn\n) = 1\n\n\nd\n x 17 mod 780 = 1\n\n\nd\n = 413\n\n\n\n\n\n\n\n\nNow we have a public key of (3233, 17) and a private key of (3233, 413)\n\n\nEncryption\n\n\nWith the public key, \nm\n can be encrypted trivially\n\n\nThe ciphertext is equal to \nm\ne\n mod \nn\n or:\n\n\nc\n = \nm\n17\n mod 3233\n\n\nDecryption\n\n\nWith the private key, \nm\n can be decrypted trivially as well\n\n\nThe plaintext is equal to \nc\nd\n mod \nn\n or:\n\n\nm\n = \nc\n413\n mod 3233\n\n\nExploitation\n\n\nFrom the \nRsaCtfTool README\n\n\n\n\nAttacks:\n\n\n\n\nWeak public key factorization\n\n\nWiener's attack\n\n\nHastad's attack (Small public exponent attack)\n\n\nSmall q (q \n 100,000)\n\n\nCommon factor between ciphertext and modulus attack\n\n\nFermat's factorisation for close p and q\n\n\nGimmicky Primes method\n\n\nPast CTF Primes method\n\n\nSelf-Initializing Quadratic Sieve (SIQS) using Yafu\n\n\nCommon factor attacks across multiple keys\n\n\nSmall fractions method when p/q is close to a small fraction\n\n\nBoneh Durfee Method when the private exponent d is too small compared to the modulus (i.e d \n n\n0.292\n)\n\n\nElliptic Curve Method\n\n\nPollards p-1 for relatively smooth numbers\n\n\nMersenne primes factorization", 
            "title": "What is RSA"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#rsa", 
            "text": "RSA, which is an abbreviation of the author's names (Rivest\u2013Shamir\u2013Adleman), is a cryptosystem which allows for asymmetric encryption. Asymmetric cryptosystems are alos commonly referred to as  Public Key Cryptography  where a public key is used to encrypt data and only a secret, private key can be used to decrypt the data.", 
            "title": "RSA"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#definitions", 
            "text": "The  Public Key  is made up of ( n ,  e )  The  Private Key  is made up of ( n ,  d )  The message is represented as  m  and is converted into a number  The encrypted message or ciphertext is represented by  c  p  and  q  are prime numbers which make up  n  e  is the public exponent  n  is the modulus and its length in bits is the bit length (i.e. 1024 bit RSA)  d  is the private exponent  The totient \u03bb( n ) is used to compute  d  and is equal to the lcm( p -1,  q -1), another definition for \u03bb( n ) is that \u03bb( pq ) = lcm(\u03bb( p ), \u03bb( q ))", 
            "title": "Definitions"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#what-makes-rsa-viable", 
            "text": "If public  n , public  e , private  d  are all very large numbers and a message  m  holds true for 0    m     n , then we can say:   ( m e ) d  \u2261  m  (mod  n )    Note  The triple equals sign in this case refers to  modular congruence  which in this case means that there exists an integer  k  such that ( m e ) d  =  kn  +  m   RSA is viable because it is incredibly hard to find  d  even with  m ,  n , and  e  because factoring large numbers is an arduous process.", 
            "title": "What makes RSA viable?"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#implementation", 
            "text": "RSA follows 4 steps to be implemented:\n1. Key Generation\n2. Encryption\n3. Decryption", 
            "title": "Implementation"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#key-generation", 
            "text": "We are going to follow along Wikipedia's small numbers example in order to make this idea a bit easier to understand.   Note  In This example we are using  Carmichael's  totient function where \u03bb(n) = lcm(\u03bb(p), \u03bb(q)), but  Euler's  totient function is perfectly valid to use with RSA. Euler's totient is \u03c6(n) = (p \u2212 1)(q \u2212 1)    Choose two prime numbers such as:   p  = 61 and  q  = 53    Find  n :   n  =  pq  = 3233     Calculate \u03bb( n ) = lcm( p -1,  q -1)    \u03bb(3233) = lcm(60, 52) = 780     Choose a public exponent such that 1    e    \u03bb( n ) and is coprime (not a factor of) \u03bb( n ). The standard is most cases is 65537, but we will be using:    e  = 17    Calculate  d  as the modular multiplicative inverse or in english find  d  such that:  d  x  e  mod \u03bb( n ) = 1  d  x 17 mod 780 = 1  d  = 413     Now we have a public key of (3233, 17) and a private key of (3233, 413)", 
            "title": "Key Generation"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#encryption", 
            "text": "With the public key,  m  can be encrypted trivially  The ciphertext is equal to  m e  mod  n  or:  c  =  m 17  mod 3233", 
            "title": "Encryption"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#decryption", 
            "text": "With the private key,  m  can be decrypted trivially as well  The plaintext is equal to  c d  mod  n  or:  m  =  c 413  mod 3233", 
            "title": "Decryption"
        }, 
        {
            "location": "/cryptography/what-is-rsa/#exploitation", 
            "text": "From the  RsaCtfTool README   Attacks:   Weak public key factorization  Wiener's attack  Hastad's attack (Small public exponent attack)  Small q (q   100,000)  Common factor between ciphertext and modulus attack  Fermat's factorisation for close p and q  Gimmicky Primes method  Past CTF Primes method  Self-Initializing Quadratic Sieve (SIQS) using Yafu  Common factor attacks across multiple keys  Small fractions method when p/q is close to a small fraction  Boneh Durfee Method when the private exponent d is too small compared to the modulus (i.e d   n 0.292 )  Elliptic Curve Method  Pollards p-1 for relatively smooth numbers  Mersenne primes factorization", 
            "title": "Exploitation"
        }, 
        {
            "location": "/web-exploitation/overview/", 
            "text": "Web Exploitation\n\n\nWebsites all around the world are programmed using various programming languages. While there are specific vulnerabilities in each programming langage that the developer should be aware of, there are issues fundamental to the internet that can show up regardless of the chosen language or framework.\n\n\nThese vulnerabilities often show up in CTFs as web security challenges where the user needs to exploit a bug to gain some kind of higher level privelege.\n\n\nCommon vulnerabilities to see in CTF challenges:\n\n\n\n\nSQL Injection\n\n\nCommand Injection\n\n\nDirectory Traversal\n\n\nCross Site Request Forgery\n\n\nCross Site Scripting\n\n\nServer Side Request Forgery", 
            "title": "Overview"
        }, 
        {
            "location": "/web-exploitation/overview/#web-exploitation", 
            "text": "Websites all around the world are programmed using various programming languages. While there are specific vulnerabilities in each programming langage that the developer should be aware of, there are issues fundamental to the internet that can show up regardless of the chosen language or framework.  These vulnerabilities often show up in CTFs as web security challenges where the user needs to exploit a bug to gain some kind of higher level privelege.  Common vulnerabilities to see in CTF challenges:   SQL Injection  Command Injection  Directory Traversal  Cross Site Request Forgery  Cross Site Scripting  Server Side Request Forgery", 
            "title": "Web Exploitation"
        }, 
        {
            "location": "/web-exploitation/sql-injection/what-is-sql-injection/", 
            "text": "SQL Injection\n\n\nSQL Injection is a vulnerability where an application takes input from a user and doesn't vaildate that the user's input doesn't contain additional SQL.\n\n\n?php\n\n    \n$username\n \n=\n \n$_GET\n[\nusername\n];\n \n// kchung\n\n    \n$result\n \n=\n \nmysql_query\n(\nSELECT * FROM users WHERE username=\n$username\n);\n\n\n?\n\n\n\n\n\n\nIf we look at the $username variable, under normal operation we might expect the username parameter to be a real username (e.g. kchung).\n\n\nBut a malicious user might submit different kind of data. For example, consider if the input was \n?\n\n\nThe application would crash because the resulting SQL query is incorrect.\n\n\nSELECT\n \n*\n \nFROM\n \nusers\n \nWHERE\n \nusername\n=\n\n\n\n\n\n\n\n\nNote\n\n\nNotice the extra single quote at the end.\n\n\n\n\nWith the knowledge that a single quote will cause an error in the application we can expand a little more on SQL Injection.\n\n\nWhat if our input was \n OR 1=1\n?\n\n\nSELECT\n \n*\n \nFROM\n \nusers\n \nWHERE\n \nusername\n=\n \nOR\n \n1\n=\n1\n\n\n\n\n\n\n1 is indeed equal to 1. This equates to true in SQL. If we reinterpret this the SQL statement is really saying\n\n\nSELECT\n \n*\n \nFROM\n \nusers\n \nWHERE\n \nusername\n=\n \nOR\n \ntrue\n\n\n\n\n\n\nThis will return every row in the table because each row that exists must be true.\n\n\nWe can also inject comments and termination characters like \n--\n or \n/*\n or \n;\n. This allows you to terminate SQL queries after your injected statements. For example \n--\n is a common SQL injection payload.\n\n\nSELECT\n \n*\n \nFROM\n \nusers\n \nWHERE\n \nusername\n=\n-- \n\n\n\n\n\n\nThis payload sets the username parameter to an empty string to break out of the query and then adds a comment (\n--\n) that effectively hides the second single quote.\n\n\nUsing this technique of adding SQL statements to an existing query we can force databases to return data that it was not meant to return.", 
            "title": "What is SQL Injection"
        }, 
        {
            "location": "/web-exploitation/sql-injection/what-is-sql-injection/#sql-injection", 
            "text": "SQL Injection is a vulnerability where an application takes input from a user and doesn't vaildate that the user's input doesn't contain additional SQL.  ?php \n     $username   =   $_GET [ username ];   // kchung \n     $result   =   mysql_query ( SELECT * FROM users WHERE username= $username );  ?   If we look at the $username variable, under normal operation we might expect the username parameter to be a real username (e.g. kchung).  But a malicious user might submit different kind of data. For example, consider if the input was  ?  The application would crash because the resulting SQL query is incorrect.  SELECT   *   FROM   users   WHERE   username =    Note  Notice the extra single quote at the end.   With the knowledge that a single quote will cause an error in the application we can expand a little more on SQL Injection.  What if our input was   OR 1=1 ?  SELECT   *   FROM   users   WHERE   username =   OR   1 = 1   1 is indeed equal to 1. This equates to true in SQL. If we reinterpret this the SQL statement is really saying  SELECT   *   FROM   users   WHERE   username =   OR   true   This will return every row in the table because each row that exists must be true.  We can also inject comments and termination characters like  --  or  /*  or  ; . This allows you to terminate SQL queries after your injected statements. For example  --  is a common SQL injection payload.  SELECT   *   FROM   users   WHERE   username = --    This payload sets the username parameter to an empty string to break out of the query and then adds a comment ( -- ) that effectively hides the second single quote.  Using this technique of adding SQL statements to an existing query we can force databases to return data that it was not meant to return.", 
            "title": "SQL Injection"
        }, 
        {
            "location": "/web-exploitation/command-injection/what-is-command-injection/", 
            "text": "Command Injection\n\n\nCommand Injection is a vulnerability that allows an attacker to submit system commands to a computer running a website. This happens when the application fails to encode user input that goes into a system shell. It is very common to see this vulnerability when a developer uses the \nsystem()\n command or its equivalent in the programming language of the application.\n\n\nimport\n \nos\n\n\n\ndomain\n \n=\n \nuser_input\n()\n \n# ctf101.org\n\n\n\nos\n.\nsystem\n(\nping \n \n+\n \ndomain\n)\n\n\n\n\n\n\nThe above code when used normally will ping the \nctf101.org\n domain.\n\n\nBut consider what would happen if the \nuser_input()\n function returned different data?\n\n\nimport\n \nos\n\n\n\ndomain\n \n=\n \nuser_input\n()\n \n# ; ls\n\n\n\nos\n.\nsystem\n(\nping \n \n+\n \ndomain\n)\n\n\n\n\n\n\nBecause of the additional semicolon, the \nos.system()\n function is instructed to run two commands.\n\n\nIt looks to the program as:\n\n\nping \n;\n ls\n\n\n\n\n\n\n\nNote\n\n\nThe semicolon terminates a command in bash and allows you to put another command after it.\n\n\n\n\nBecause the \nping\n command is being terminated and the \nls\n command is being added on, the \nls\n command will be run in addition to the empty ping command!\n\n\nThis is the core concept behind command injection. The \nls\n command could of course be switched with another command (e.g. wget, curl, bash, etc.)\n\n\nCommand injection is a very common means of privelege escalation within web applications and applications that interface with system commands. Many kinds of home routers take user input and directly append it to a system command. For this reason, many of those home router models are vulnerable to command injection.\n\n\nExample Payloads\n\n\n\n\n;ls\n\n\n$(ls)\n\n\n`ls`\n\n\n\n\nRelated Challenges", 
            "title": "What is Command Injection"
        }, 
        {
            "location": "/web-exploitation/command-injection/what-is-command-injection/#command-injection", 
            "text": "Command Injection is a vulnerability that allows an attacker to submit system commands to a computer running a website. This happens when the application fails to encode user input that goes into a system shell. It is very common to see this vulnerability when a developer uses the  system()  command or its equivalent in the programming language of the application.  import   os  domain   =   user_input ()   # ctf101.org  os . system ( ping    +   domain )   The above code when used normally will ping the  ctf101.org  domain.  But consider what would happen if the  user_input()  function returned different data?  import   os  domain   =   user_input ()   # ; ls  os . system ( ping    +   domain )   Because of the additional semicolon, the  os.system()  function is instructed to run two commands.  It looks to the program as:  ping  ;  ls   Note  The semicolon terminates a command in bash and allows you to put another command after it.   Because the  ping  command is being terminated and the  ls  command is being added on, the  ls  command will be run in addition to the empty ping command!  This is the core concept behind command injection. The  ls  command could of course be switched with another command (e.g. wget, curl, bash, etc.)  Command injection is a very common means of privelege escalation within web applications and applications that interface with system commands. Many kinds of home routers take user input and directly append it to a system command. For this reason, many of those home router models are vulnerable to command injection.", 
            "title": "Command Injection"
        }, 
        {
            "location": "/web-exploitation/command-injection/what-is-command-injection/#example-payloads", 
            "text": ";ls  $(ls)  `ls`", 
            "title": "Example Payloads"
        }, 
        {
            "location": "/web-exploitation/command-injection/what-is-command-injection/#related-challenges", 
            "text": "", 
            "title": "Related Challenges"
        }, 
        {
            "location": "/web-exploitation/directory-traversal/what-is-directory-traversal/", 
            "text": "Directory Traversal\n\n\nDirectory Traversal is a vulnerability where an application takes in user input and uses it in a directory path.\n\n\nAny kind of path controlled by user input that isn't properly sanitized or properly sandboxed could be vulnerable to directory traversal.\n\n\nFor example, consider an application that allows the user to choose what page to load from a GET parameter.\n\n\n?php\n\n    \n$page\n \n=\n \n$_GET\n[\npage\n];\n \n// index.php\n\n    \ninclude\n(\n/var/www/html/\n \n.\n \n$page\n);\n\n\n?\n\n\n\n\n\n\nUnder normal operation the page would be \nindex.php\n. But what if a malicious user gave in something different?\n\n\n?php\n\n    \n$page\n \n=\n \n$_GET\n[\npage\n];\n \n// ../../../../../../../../etc/passwd\n\n    \ninclude\n(\n/var/www/html/\n \n.\n \n$page\n);\n\n\n?\n\n\n\n\n\n\nHere the user is submitting \n../../../../../../../../etc/passwd\n.\n\n\nThis will result in the PHP interpreter leaving the directory that it is coded to look in ('/var/www/html') and instead be forced up to the root folder.\n\n\ninclude(\n/var/www/html/../../../../../../../../etc/passwd\n);\n\n\n\n\n\n\nUltimately this will become \n/etc/passwd\n because the computer will not go a directory above its top directory.\n\n\nThus the application will load the \n/etc/passwd\n file and emit it to the user like so:\n\n\nroot\n:\nx\n:\n0\n:\n0\n:\nroot\n:/\nroot\n:/\nbin\n/\nbash\n\n\ndaemon\n:\nx\n:\n1\n:\n1\n:\ndaemon\n:/\nusr\n/sbin:/usr/sbin/\nnologin\n\n\nbin\n:\nx\n:\n2\n:\n2\n:\nbin\n:/\nbin\n:/\nusr\n/sbin/\nnologin\n\n\nsys\n:\nx\n:\n3\n:\n3\n:\nsys\n:/\ndev\n:/\nusr\n/sbin/\nnologin\n\n\nsync\n:\nx\n:\n4\n:\n65534\n:\nsync\n:/\nbin\n:/\nbin\n/\nsync\n\n\ngames\n:\nx\n:\n5\n:\n60\n:\ngames\n:/\nusr\n/games:/usr/sbin/\nnologin\n\n\nman\n:\nx\n:\n6\n:\n12\n:\nman\n:/\nvar\n/cache/man:/usr/sbin/\nnologin\n\n\nlp\n:\nx\n:\n7\n:\n7\n:\nlp\n:/\nvar\n/spool/lpd:/usr/sbin/\nnologin\n\n\nmail\n:\nx\n:\n8\n:\n8\n:\nmail\n:/\nvar\n/mail:/usr/sbin/\nnologin\n\n\nnews\n:\nx\n:\n9\n:\n9\n:\nnews\n:/\nvar\n/spool/news:/usr/sbin/\nnologin\n\n\nuucp\n:\nx\n:\n10\n:\n10\n:\nuucp\n:/\nvar\n/spool/uucp:/usr/sbin/\nnologin\n\n\nproxy\n:\nx\n:\n13\n:\n13\n:\nproxy\n:/\nbin\n:/\nusr\n/sbin/\nnologin\n\n\nwww\n-\ndata\n:\nx\n:\n33\n:\n33\n:\nwww\n-\ndata\n:/\nvar\n/www:/usr/sbin/\nnologin\n\n\nbackup\n:\nx\n:\n34\n:\n34\n:\nbackup\n:/\nvar\n/backups:/usr/sbin/\nnologin\n\n\nlist\n:\nx\n:\n38\n:\n38\n:\nMailing\n \nList\n \nManager\n:/\nvar\n/list:/usr/sbin/\nnologin\n\n\nirc\n:\nx\n:\n39\n:\n39\n:\nircd\n:/\nvar\n/run/ircd:/usr/sbin/\nnologin\n\n\ngnats\n:\nx\n:\n41\n:\n41\n:\nGnats\n \nBug\n-\nReporting\n \nSystem\n \n(\nadmin\n):/\nvar\n/lib/gnats:/usr/sbin/\nnologin\n\n\nnobody\n:\nx\n:\n65534\n:\n65534\n:\nnobody\n:/\nnonexistent\n:/\nusr\n/sbin/\nnologin\n\n\nsystemd\n-\ntimesync\n:\nx\n:\n100\n:\n102\n:\nsystemd\n \nTime\n \nSynchronization\n,,,:/\nrun\n/systemd:/bin/\nfalse\n\n\nsystemd\n-\nnetwork\n:\nx\n:\n101\n:\n103\n:\nsystemd\n \nNetwork\n \nManagement\n,,,:/\nrun\n/systemd/netif:/bin/\nfalse\n\n\nsystemd\n-\nresolve\n:\nx\n:\n102\n:\n104\n:\nsystemd\n \nResolver\n,,,:/\nrun\n/systemd/resolve:/bin/\nfalse\n\n\nsystemd\n-\nbus\n-\nproxy\n:\nx\n:\n103\n:\n105\n:\nsystemd\n \nBus\n \nProxy\n,,,:/\nrun\n/systemd:/bin/\nfalse\n\n\n_apt\n:\nx\n:\n104\n:\n65534\n::/\nnonexistent\n:/\nbin\n/\nfalse\n\n\n\n\n\n\nThis same concept can be applied to applications where some input is taken from a user and then used to access a file or path or similar. This vulnerability very often can be used to leak sensitive data or extract application source code to find other vulnerabilities.", 
            "title": "What is Directory Traversal"
        }, 
        {
            "location": "/web-exploitation/directory-traversal/what-is-directory-traversal/#directory-traversal", 
            "text": "Directory Traversal is a vulnerability where an application takes in user input and uses it in a directory path.  Any kind of path controlled by user input that isn't properly sanitized or properly sandboxed could be vulnerable to directory traversal.  For example, consider an application that allows the user to choose what page to load from a GET parameter.  ?php \n     $page   =   $_GET [ page ];   // index.php \n     include ( /var/www/html/   .   $page );  ?   Under normal operation the page would be  index.php . But what if a malicious user gave in something different?  ?php \n     $page   =   $_GET [ page ];   // ../../../../../../../../etc/passwd \n     include ( /var/www/html/   .   $page );  ?   Here the user is submitting  ../../../../../../../../etc/passwd .  This will result in the PHP interpreter leaving the directory that it is coded to look in ('/var/www/html') and instead be forced up to the root folder.  include( /var/www/html/../../../../../../../../etc/passwd );   Ultimately this will become  /etc/passwd  because the computer will not go a directory above its top directory.  Thus the application will load the  /etc/passwd  file and emit it to the user like so:  root : x : 0 : 0 : root :/ root :/ bin / bash  daemon : x : 1 : 1 : daemon :/ usr /sbin:/usr/sbin/ nologin  bin : x : 2 : 2 : bin :/ bin :/ usr /sbin/ nologin  sys : x : 3 : 3 : sys :/ dev :/ usr /sbin/ nologin  sync : x : 4 : 65534 : sync :/ bin :/ bin / sync  games : x : 5 : 60 : games :/ usr /games:/usr/sbin/ nologin  man : x : 6 : 12 : man :/ var /cache/man:/usr/sbin/ nologin  lp : x : 7 : 7 : lp :/ var /spool/lpd:/usr/sbin/ nologin  mail : x : 8 : 8 : mail :/ var /mail:/usr/sbin/ nologin  news : x : 9 : 9 : news :/ var /spool/news:/usr/sbin/ nologin  uucp : x : 10 : 10 : uucp :/ var /spool/uucp:/usr/sbin/ nologin  proxy : x : 13 : 13 : proxy :/ bin :/ usr /sbin/ nologin  www - data : x : 33 : 33 : www - data :/ var /www:/usr/sbin/ nologin  backup : x : 34 : 34 : backup :/ var /backups:/usr/sbin/ nologin  list : x : 38 : 38 : Mailing   List   Manager :/ var /list:/usr/sbin/ nologin  irc : x : 39 : 39 : ircd :/ var /run/ircd:/usr/sbin/ nologin  gnats : x : 41 : 41 : Gnats   Bug - Reporting   System   ( admin ):/ var /lib/gnats:/usr/sbin/ nologin  nobody : x : 65534 : 65534 : nobody :/ nonexistent :/ usr /sbin/ nologin  systemd - timesync : x : 100 : 102 : systemd   Time   Synchronization ,,,:/ run /systemd:/bin/ false  systemd - network : x : 101 : 103 : systemd   Network   Management ,,,:/ run /systemd/netif:/bin/ false  systemd - resolve : x : 102 : 104 : systemd   Resolver ,,,:/ run /systemd/resolve:/bin/ false  systemd - bus - proxy : x : 103 : 105 : systemd   Bus   Proxy ,,,:/ run /systemd:/bin/ false  _apt : x : 104 : 65534 ::/ nonexistent :/ bin / false   This same concept can be applied to applications where some input is taken from a user and then used to access a file or path or similar. This vulnerability very often can be used to leak sensitive data or extract application source code to find other vulnerabilities.", 
            "title": "Directory Traversal"
        }, 
        {
            "location": "/web-exploitation/cross-site-request-forgery/what-is-cross-site-request-forgery/", 
            "text": "Cross Site Request Forgery (CSRF)\n\n\nA Cross Site Request Forgery or CSRF Attack, pronounced \nsee surf\n, is an attack on an authenticated user which uses a state session in order to perform state changing attacks like a purchase, a transfer of funds, or a change of email address.\n\n\nThe entire premise of CSRF is based on session hijacking, usually by injecting malicious elements within a webpage through an \nimg\n tag or an \niframe\n where references to external resources are unverified.\n\n\nUsing CSRF\n\n\nGET\n requests are often used by websites to get user input. Say a user signs in to an banking site which assigns their browser a cookie which keeps them logged in. If they transfer some money, the URL that is sent to the server might have the pattern:\n\n\nhttp://securibank.com/transfer.do?acct=[RECEPIENT]\namount=[DOLLARS]\n\n\nKnowing this format, an attacker can send an email with a hyperlink to be clicked on or they can include an image tag of 0 by 0 pixels which will automatically be requested by the browser such as:\n\n\nimg src=\nhttp://securibank.com/transfer.do?acct=[RECEPIENT]\namount=[DOLLARS]\n width=\n0\n height=\n0\n border=\n0", 
            "title": "What is Cross Site Request Forgery"
        }, 
        {
            "location": "/web-exploitation/cross-site-request-forgery/what-is-cross-site-request-forgery/#cross-site-request-forgery-csrf", 
            "text": "A Cross Site Request Forgery or CSRF Attack, pronounced  see surf , is an attack on an authenticated user which uses a state session in order to perform state changing attacks like a purchase, a transfer of funds, or a change of email address.  The entire premise of CSRF is based on session hijacking, usually by injecting malicious elements within a webpage through an  img  tag or an  iframe  where references to external resources are unverified.", 
            "title": "Cross Site Request Forgery (CSRF)"
        }, 
        {
            "location": "/web-exploitation/cross-site-request-forgery/what-is-cross-site-request-forgery/#using-csrf", 
            "text": "GET  requests are often used by websites to get user input. Say a user signs in to an banking site which assigns their browser a cookie which keeps them logged in. If they transfer some money, the URL that is sent to the server might have the pattern:  http://securibank.com/transfer.do?acct=[RECEPIENT] amount=[DOLLARS]  Knowing this format, an attacker can send an email with a hyperlink to be clicked on or they can include an image tag of 0 by 0 pixels which will automatically be requested by the browser such as:  img src= http://securibank.com/transfer.do?acct=[RECEPIENT] amount=[DOLLARS]  width= 0  height= 0  border= 0", 
            "title": "Using CSRF"
        }, 
        {
            "location": "/web-exploitation/cross-site-scripting/what-is-cross-site-scripting/", 
            "text": "Cross Site Scripting (XSS)\n\n\nCross Site Scripting or XSS is a vulnerability where on user of an application can send JavaScript that is executed by the browser of another user of the same application.\n\n\nThis is a vulnerability because JavaScript has a high degree of control over a user's web browser.\n\n\nFor example JavaScript has the ability to:\n\n\n\n\nModify the page (called the DOM)\n\n\nSend more HTTP requests\n\n\nAccess cookies\n\n\n\n\nBy combining all of these abilities, XSS can maliciously use JavaScript to extract user's cookies and send them to an attacker controlled server. XSS can also modify the DOM to phish users for their passwords. This only scratches the surface of what XSS can be used to do.\n\n\nXSS is typically broken down into three categories:\n\n\n\n\nReflected XSS\n\n\nStored XSS\n\n\nDOM XSS\n\n\n\n\nReflected XSS\n\n\nReflected XSS is when an XSS exploit is provided through a URL paramater.\n\n\nFor example:\n\n\nhttps://ctf101.org?data=\nscript\nalert(1)\n/script\n\n\n\n\n\n\nYou can see the XSS exploit provided in the \ndata\n GET parameter. If the application is vulnerable to reflected XSS, the application will take this data parameter value and inject it into the DOM.\n\n\nFor example:\n\n\nhtml\n\n    \nbody\n\n        \nscript\nalert\n(\n1\n)\n/\nscript\n\n    \n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\nDepending on where the exploit gets injected, it may need to be constructed differently.\n\n\nAlso, the exploit payload can change to fit whatever the attacker needs it to do. Whether that is to extract cookies and submit it to an external server, or to simply modify the page to deface it.\n\n\nOne of the deficiencies of reflected XSS however is that it requires the victim to access the vulnerable page from an attacker controlled resource. Notice that if the data paramter, wasn't provided the exploit wouldn't work.\n\n\nIn many situations, reflected XSS is detected by the browser because it is very simple for a browser to detect malicous XSS payloads in URLs.\n\n\nStored XSS\n\n\nStored XSS is different from reflected XSS in one key way. In reflected XSS, the exploit is provided through a GET parameter. But in stored XSS, the exploit is provided from the website itself.\n\n\nImagine a website that allows users to post comments. If a user can submit an XSS payload as a comment, and then have others view that malicious comment, it would be an example of stored XSS.\n\n\nThe reason being that the web site itself is serving up the XSS payload to other users. This makes it very difficult to detect from the browser's perspective and no browser is capable of generically preventing stored XSS from exploiting a user.\n\n\nDOM XSS\n\n\nDOM XSS is XSS that is due to the browser itself injecting an XSS payload into the DOM. While the server itself may properly prevent XSS, it's possible that the client side scripts may accidentally take a payload and insert it into the DOM and cause the payload to trigger.\n\n\nThe server itself is not to blame, but the client side JavaScript files are causing the issue.", 
            "title": "What is Cross Site Scripting"
        }, 
        {
            "location": "/web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#cross-site-scripting-xss", 
            "text": "Cross Site Scripting or XSS is a vulnerability where on user of an application can send JavaScript that is executed by the browser of another user of the same application.  This is a vulnerability because JavaScript has a high degree of control over a user's web browser.  For example JavaScript has the ability to:   Modify the page (called the DOM)  Send more HTTP requests  Access cookies   By combining all of these abilities, XSS can maliciously use JavaScript to extract user's cookies and send them to an attacker controlled server. XSS can also modify the DOM to phish users for their passwords. This only scratches the surface of what XSS can be used to do.  XSS is typically broken down into three categories:   Reflected XSS  Stored XSS  DOM XSS", 
            "title": "Cross Site Scripting (XSS)"
        }, 
        {
            "location": "/web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#reflected-xss", 
            "text": "Reflected XSS is when an XSS exploit is provided through a URL paramater.  For example:  https://ctf101.org?data= script alert(1) /script   You can see the XSS exploit provided in the  data  GET parameter. If the application is vulnerable to reflected XSS, the application will take this data parameter value and inject it into the DOM.  For example:  html \n     body \n         script alert ( 1 ) / script \n     / body  / html   Depending on where the exploit gets injected, it may need to be constructed differently.  Also, the exploit payload can change to fit whatever the attacker needs it to do. Whether that is to extract cookies and submit it to an external server, or to simply modify the page to deface it.  One of the deficiencies of reflected XSS however is that it requires the victim to access the vulnerable page from an attacker controlled resource. Notice that if the data paramter, wasn't provided the exploit wouldn't work.  In many situations, reflected XSS is detected by the browser because it is very simple for a browser to detect malicous XSS payloads in URLs.", 
            "title": "Reflected XSS"
        }, 
        {
            "location": "/web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#stored-xss", 
            "text": "Stored XSS is different from reflected XSS in one key way. In reflected XSS, the exploit is provided through a GET parameter. But in stored XSS, the exploit is provided from the website itself.  Imagine a website that allows users to post comments. If a user can submit an XSS payload as a comment, and then have others view that malicious comment, it would be an example of stored XSS.  The reason being that the web site itself is serving up the XSS payload to other users. This makes it very difficult to detect from the browser's perspective and no browser is capable of generically preventing stored XSS from exploiting a user.", 
            "title": "Stored XSS"
        }, 
        {
            "location": "/web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#dom-xss", 
            "text": "DOM XSS is XSS that is due to the browser itself injecting an XSS payload into the DOM. While the server itself may properly prevent XSS, it's possible that the client side scripts may accidentally take a payload and insert it into the DOM and cause the payload to trigger.  The server itself is not to blame, but the client side JavaScript files are causing the issue.", 
            "title": "DOM XSS"
        }, 
        {
            "location": "/web-exploitation/server-side-request-forgery/what-is-server-side-request-forgery/", 
            "text": "Server Side Request Forgery (SSRF)\n\n\nServer Side Request Forgery or SSRF is where an attacker is able to cause a web application to send a request that the attacker defines.\n\n\nFor example, say there is a website that lets you take a screenshot of any site on the internet.\n\n\nUnder normal usage a user might ask it to take a screenshot of a page like Google, or The New York Times. But what if a user does something more nefarious? What if they asked the site to take a picture of http://localhost ? Or perhaps tries to access something more useful like \nhttp://localhost/server-status\n ?\n\n\n\n\nNote\n\n\n127.0.0.1 (also known as localhost or loopback) represents the computer itself. Accessing localhost means you are accessing the computer's own internal network. Developers often use localhost as a way to access the services they have running on their own computers.\n\n\n\n\nDepending on what the response from the site is the attacker may be able to gain additional information about what's running on the computer itself.\n\n\nIn addition, the requests originating from the server would come from the server's IP not the attackers IP. Because of that, it is possible that the attacker might be able to access internal resources that he wouldn't normally be able to access.\n\n\nAnother usage for SSRF is to create a simple port scanner to scan the internal network looking for internal services.", 
            "title": "What is Server Side Request Forgery"
        }, 
        {
            "location": "/web-exploitation/server-side-request-forgery/what-is-server-side-request-forgery/#server-side-request-forgery-ssrf", 
            "text": "Server Side Request Forgery or SSRF is where an attacker is able to cause a web application to send a request that the attacker defines.  For example, say there is a website that lets you take a screenshot of any site on the internet.  Under normal usage a user might ask it to take a screenshot of a page like Google, or The New York Times. But what if a user does something more nefarious? What if they asked the site to take a picture of http://localhost ? Or perhaps tries to access something more useful like  http://localhost/server-status  ?   Note  127.0.0.1 (also known as localhost or loopback) represents the computer itself. Accessing localhost means you are accessing the computer's own internal network. Developers often use localhost as a way to access the services they have running on their own computers.   Depending on what the response from the site is the attacker may be able to gain additional information about what's running on the computer itself.  In addition, the requests originating from the server would come from the server's IP not the attackers IP. Because of that, it is possible that the attacker might be able to access internal resources that he wouldn't normally be able to access.  Another usage for SSRF is to create a simple port scanner to scan the internal network looking for internal services.", 
            "title": "Server Side Request Forgery (SSRF)"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/", 
            "text": "PHP\n\n\nPHP is one of the most used languages for back-end web development and therefore it has become a target by hackers. PHP is a language which makes it painful to be secure for most instances, making it every hacker's dream target.\n\n\nOverview\n\n\nPHP is a C-like language which uses tags enclosed by \n?php\n \n...\n \n?\n (sometimes just \n?\n \n...\n \n?\n). It is inlined into HTML. A word of advice is to keep the php docs open because function names are strange due to the fact that the length of function name is used to be the key in PHP's internal dictionary, so function names were shortened/lengthened to make the lookup faster. Other things include:\n\n\n\n\nVariables start with $: \n$name\n\n\nVariable variables: \n$$name\n\n\nRequest-specific dictionaries: \n$_GET, $_POST, $_SERVER\n\n\n\n\nExample\n\n\n?php\n\n    \nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n===\n \nPOST\n \n \nisset\n(\n$_POST\n[\nemail\n])\n \n \nisset\n(\n$_POST\n[\npassword\n]))\n \n{\n\n        \n$db\n \n=\n \nnew\n \nmysqli\n(\n127.0.0.1\n,\n \ncs3284\n,\n \ncs3284\n,\n \nlogmein\n);\n\n        \n$email\n \n=\n \n$_POST\n[\nemail\n];\n\n        \n$password\n \n=\n \nsha1\n(\n$_POST\n[\npassword\n]);\n\n        \n$res\n \n=\n \n$db\n-\nquery\n(\nSELECT * FROM users WHERE email = \n$email\n AND password = \n$password\n);\n\n        \nif\n \n(\n$row\n \n=\n \n$res\n-\nfetch_assoc\n())\n \n{\n\n            \n$_SESSION\n[\nid\n]\n \n=\n \n$row\n[\nid\n];\n\n            \nheader\n(\nLocation: index.php\n);\n\n            \ndie\n();\n\n        \n}\n\n   \n}\n\n\n?\n\n\nhtml\n...\n\n\n\n\n\n\nThis example PHP simply checks the POST data for an email and password. If the password is equal to the hashed password in the database, the use is logged in and redirected to the index page.\n\n\nThe line \nemail = \n$email\n uses automatic string interpolation in order to convert $email into a string to compare with the database.\n\n\nType Juggling\n\n\nPHP will do just about anything to match with a loose comparison (==) which means things can be 'equal' (==) or \nreally\n equal (===). The implicit integer parsing to strings is the root cause of a lot of issues in PHP.\n\n\nType Comparison Table\n\n\nComparisons of $x with PHP Functions\n\n\n\n\n\n\n\n\nExpression\n\n\ngettype()\n\n\nempty()\n\n\nis_null()\n\n\nisset()\n\n\nboolean: \nif($x)\n\n\n\n\n\n\n\n\n\n\n$x = \"\";\n\n\nstring\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n$x = null;\n\n\nNULL\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\nvar $x;\n\n\nNULL\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n$x is undefined\n\n\nNULL\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n$x = array();\n\n\narray\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n$x = array('a', 'b');\n\n\narray\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = false;\n\n\nboolean\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n$x = true;\n\n\nboolean\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = 1;\n\n\ninteger\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = 42;\n\n\ninteger\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = 0;\n\n\ninteger\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n$x = -1;\n\n\ninteger\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = \"1\";\n\n\nstring\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = \"0\";\n\n\nstring\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n$x = \"-1\";\n\n\nstring\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = \"php\";\n\n\nstring\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = \"true\";\n\n\nstring\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n$x = \"false\";\n\n\nstring\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n\n\n\"==\" Comparisons\n\n\n\n\n\n\n\n\n\n\nTRUE\n\n\nFALSE\n\n\n1\n\n\n0\n\n\n-1\n\n\n\"1\"\n\n\n\"0\"\n\n\n\"-1\"\n\n\nNULL\n\n\narray()\n\n\n\"php\"\n\n\n\"\"\n\n\n\n\n\n\n\n\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\n\n\n\n\n1\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n0\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\n\n\n\n\n-1\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"1\"\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"0\"\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"-1\"\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\nNULL\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\n\n\n\n\narray()\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"php\"\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n\"\"\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\n\n\n\n\n\n\n\"===\" Comparisons\n\n\n\n\n\n\n\n\n\n\nTRUE\n\n\nFALSE\n\n\n1\n\n\n0\n\n\n-1\n\n\n\"1\"\n\n\n\"0\"\n\n\n\"-1\"\n\n\nNULL\n\n\narray()\n\n\n\"php\"\n\n\n\"\"\n\n\n\n\n\n\n\n\n\n\nTRUE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n1\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n0\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n-1\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"1\"\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"0\"\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"-1\"\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\nNULL\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\narray()\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\nFALSE\n\n\n\n\n\n\n\"php\"\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\n\"\"\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nFALSE\n\n\nTRUE\n\n\n\n\n\n\n\n\nFile Inclusion\n\n\nPHP has multiple ways to include other source files such as require, require_once and include. These can take a dynamic string such as \nrequire $_GET[\npage\n] . \n.php\n;\n which is usually seen in templating.\n\n\nPHP Stream Filters\n\n\nPHP has its own URL scheme: \nphp://...\n and  its main purpose is to filter output automatically. It can automatically remove certain HTML tags and can base64 encode as well.\n\n\nExample\n\n\n$fp = fopen(\nphp://output\n, \nw\n);\n\n\nstream_filter_append(\n\n\n       $fp,\n\n\n       \nstring.strip_tags\n,\n\n\n       STREAM_FILTER_WRITE,\n\n\n       array(\nb\n,\ni\n,\nu\n));\n\n\nfwrite($fp, \nb\nbolded text\n/b\n enlarged to a \nh1\nlevel 1 heading\n/h1\n\\n\n);\n\n\n/* \nb\nbolded text\n/b\n enlarged to a level 1 heading */\n\n\n\n\n\n\nExploitation\n\n\nThese filters can also be used on input such as:\n\n\n\n\nphp://filter/convert.base64-encode/resource={file}\n\n\ninclude\n, \nfile_get_contents()\n, etc. support URLs including PHP stream filter URLs (\nphp://\n)\n\n\ninclude\n normally evaluates any PHP code (in tags) it finds, but if it\u2019s base64 encoded it can be used to leak source", 
            "title": "What is PHP?"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#php", 
            "text": "PHP is one of the most used languages for back-end web development and therefore it has become a target by hackers. PHP is a language which makes it painful to be secure for most instances, making it every hacker's dream target.", 
            "title": "PHP"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#overview", 
            "text": "PHP is a C-like language which uses tags enclosed by  ?php   ...   ?  (sometimes just  ?   ...   ? ). It is inlined into HTML. A word of advice is to keep the php docs open because function names are strange due to the fact that the length of function name is used to be the key in PHP's internal dictionary, so function names were shortened/lengthened to make the lookup faster. Other things include:   Variables start with $:  $name  Variable variables:  $$name  Request-specific dictionaries:  $_GET, $_POST, $_SERVER", 
            "title": "Overview"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#example", 
            "text": "?php \n     if   ( $_SERVER [ REQUEST_METHOD ]   ===   POST     isset ( $_POST [ email ])     isset ( $_POST [ password ]))   { \n         $db   =   new   mysqli ( 127.0.0.1 ,   cs3284 ,   cs3284 ,   logmein ); \n         $email   =   $_POST [ email ]; \n         $password   =   sha1 ( $_POST [ password ]); \n         $res   =   $db - query ( SELECT * FROM users WHERE email =  $email  AND password =  $password ); \n         if   ( $row   =   $res - fetch_assoc ())   { \n             $_SESSION [ id ]   =   $row [ id ]; \n             header ( Location: index.php ); \n             die (); \n         } \n    }  ?  html ...   This example PHP simply checks the POST data for an email and password. If the password is equal to the hashed password in the database, the use is logged in and redirected to the index page.  The line  email =  $email  uses automatic string interpolation in order to convert $email into a string to compare with the database.", 
            "title": "Example"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#type-juggling", 
            "text": "PHP will do just about anything to match with a loose comparison (==) which means things can be 'equal' (==) or  really  equal (===). The implicit integer parsing to strings is the root cause of a lot of issues in PHP.", 
            "title": "Type Juggling"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#type-comparison-table", 
            "text": "", 
            "title": "Type Comparison Table"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#comparisons-of-x-with-php-functions", 
            "text": "Expression  gettype()  empty()  is_null()  isset()  boolean:  if($x)      $x = \"\";  string  TRUE  FALSE  TRUE  FALSE    $x = null;  NULL  TRUE  TRUE  FALSE  FALSE    var $x;  NULL  TRUE  TRUE  FALSE  FALSE    $x is undefined  NULL  TRUE  TRUE  FALSE  FALSE    $x = array();  array  TRUE  FALSE  TRUE  FALSE    $x = array('a', 'b');  array  FALSE  FALSE  TRUE  TRUE    $x = false;  boolean  TRUE  FALSE  TRUE  FALSE    $x = true;  boolean  FALSE  FALSE  TRUE  TRUE    $x = 1;  integer  FALSE  FALSE  TRUE  TRUE    $x = 42;  integer  FALSE  FALSE  TRUE  TRUE    $x = 0;  integer  TRUE  FALSE  TRUE  FALSE    $x = -1;  integer  FALSE  FALSE  TRUE  TRUE    $x = \"1\";  string  FALSE  FALSE  TRUE  TRUE    $x = \"0\";  string  TRUE  FALSE  TRUE  FALSE    $x = \"-1\";  string  FALSE  FALSE  TRUE  TRUE    $x = \"php\";  string  FALSE  FALSE  TRUE  TRUE    $x = \"true\";  string  FALSE  FALSE  TRUE  TRUE    $x = \"false\";  string  FALSE  FALSE  TRUE  TRUE", 
            "title": "Comparisons of $x with PHP Functions"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#comparisons", 
            "text": "TRUE  FALSE  1  0  -1  \"1\"  \"0\"  \"-1\"  NULL  array()  \"php\"  \"\"      TRUE  TRUE  FALSE  TRUE  FALSE  TRUE  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE    FALSE  FALSE  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  TRUE  TRUE  FALSE  TRUE    1  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    0  FALSE  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  TRUE  FALSE  TRUE  TRUE    -1  TRUE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE    \"1\"  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    \"0\"  FALSE  TRUE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE    \"-1\"  TRUE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE    NULL  FALSE  TRUE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  TRUE  TRUE  FALSE  TRUE    array()  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  TRUE  FALSE  FALSE    \"php\"  TRUE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE    \"\"  FALSE  TRUE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  TRUE", 
            "title": "\"==\" Comparisons"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#comparisons_1", 
            "text": "TRUE  FALSE  1  0  -1  \"1\"  \"0\"  \"-1\"  NULL  array()  \"php\"  \"\"      TRUE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    1  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    0  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    -1  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    \"1\"  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE    \"0\"  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE    \"-1\"  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE  FALSE    NULL  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE  FALSE    array()  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE  FALSE    \"php\"  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE  FALSE    \"\"  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  FALSE  TRUE", 
            "title": "\"===\" Comparisons"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#file-inclusion", 
            "text": "PHP has multiple ways to include other source files such as require, require_once and include. These can take a dynamic string such as  require $_GET[ page ] .  .php ;  which is usually seen in templating.", 
            "title": "File Inclusion"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#php-stream-filters", 
            "text": "PHP has its own URL scheme:  php://...  and  its main purpose is to filter output automatically. It can automatically remove certain HTML tags and can base64 encode as well.", 
            "title": "PHP Stream Filters"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#example_1", 
            "text": "$fp = fopen( php://output ,  w );  stream_filter_append(         $fp,          string.strip_tags ,         STREAM_FILTER_WRITE,         array( b , i , u ));  fwrite($fp,  b bolded text /b  enlarged to a  h1 level 1 heading /h1 \\n );  /*  b bolded text /b  enlarged to a level 1 heading */", 
            "title": "Example"
        }, 
        {
            "location": "/web-exploitation/php/what-is-php/#exploitation", 
            "text": "These filters can also be used on input such as:   php://filter/convert.base64-encode/resource={file}  include ,  file_get_contents() , etc. support URLs including PHP stream filter URLs ( php:// )  include  normally evaluates any PHP code (in tags) it finds, but if it\u2019s base64 encoded it can be used to leak source", 
            "title": "Exploitation"
        }, 
        {
            "location": "/reverse-engineering/overview/", 
            "text": "Reverse Engineering\n\n\nReverse Engineering in a CTF is typically the process of taking a compiled (machine code, bytecode) program and converting it back into a more human readable format.\n\n\nVery often the goal of a reverse engineering challenge is to understand the functionality of a given program such that you can identify deeper issues.\n\n\n\n\nAssembly / Machine Code\n\n\n\n\nThe C Programming Language\n\n\nDisassemblers\n\n\nDecompilers", 
            "title": "Overview"
        }, 
        {
            "location": "/reverse-engineering/overview/#reverse-engineering", 
            "text": "Reverse Engineering in a CTF is typically the process of taking a compiled (machine code, bytecode) program and converting it back into a more human readable format.  Very often the goal of a reverse engineering challenge is to understand the functionality of a given program such that you can identify deeper issues.   Assembly / Machine Code   The C Programming Language  Disassemblers  Decompilers", 
            "title": "Reverse Engineering"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/", 
            "text": "Assembly/Machine Code\n\n\nMachine Code or Assembly is code which has been formatted for direct execution by a CPU. Machine Code is the why readable programming languages like C, when compiled, cannot be reversed into source code (well \nDecompilers\n can sort of, but more on that later).\n\n\nFrom Source to Compilation\n\n\nGodbolt\n shows the differences in machine code generated by various compilers.\n\n\nFor example, if we have a simple C++ function:\n\n\n#include\n \nunistd.h\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nchar\n \nc\n;\n\n    \nint\n \nfd\n \n=\n \nsyscall\n(\n2\n,\n \n/etc/passwd\n,\n \n0\n);\n\n    \nwhile\n \n(\nsyscall\n(\n0\n,\n \nfd\n,\n \nc\n,\n \n1\n))\n \n{\n\n        \nputchar\n(\nc\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe can see the compilation results in some verbose instrucitons for the CPU:\n\n\n.LC0:\n\n  \n.string\n \n/etc/passwd\n\n\nmain:\n\n  \npush\n \nrbp\n\n  \nmov\n \nrbp\n,\n \nrsp\n\n  \nsub\n \nrsp\n,\n \n16\n\n  \nmov\n \nedx\n,\n \n0\n\n  \nmov\n \nesi\n,\n \nOFFSET\n \nFLAT\n:.\nLC0\n\n  \nmov\n \nedi\n,\n \n2\n\n  \nmov\n \neax\n,\n \n0\n\n  \ncall\n \nsyscall\n\n  \nmov\n \nDWORD\n \nPTR\n \n[\nrbp-4\n],\n \neax\n\n\n.L3:\n\n  \nlea\n \nrdx\n,\n \n[\nrbp-5\n]\n\n  \nmov\n \neax\n,\n \nDWORD\n \nPTR\n \n[\nrbp-4\n]\n\n  \nmov\n \necx\n,\n \n1\n\n  \nmov\n \nesi\n,\n \neax\n\n  \nmov\n \nedi\n,\n \n0\n\n  \nmov\n \neax\n,\n \n0\n\n  \ncall\n \nsyscall\n\n  \ntest\n \nrax\n,\n \nrax\n\n  \nsetne\n \nal\n\n  \ntest\n \nal\n,\n \nal\n\n  \nje\n \n.L2\n\n  \nmovzx\n \neax\n,\n \nBYTE\n \nPTR\n \n[\nrbp-5\n]\n\n  \nmovsx\n \neax\n,\n \nal\n\n  \nmov\n \nedi\n,\n \neax\n\n  \ncall\n \nputchar\n\n  \njmp\n \n.L3\n\n\n.L2:\n\n  \nmov\n \neax\n,\n \n0\n\n  \nleave\n\n  \nret\n\n\n\n\n\n\nThis is a one way process for compiled languages as there is no way to generate source from machine code. While the machine code may seem unintelligble, the extremely basic functions can be interpreted with some practice.\n\n\nx86-64\n\n\nx86-64 or amd64 or i64 is a 64-bit Complex Instruction Set Computing (CISC) architecture. This basically means that the registers used for this architecture extend an extra 32-bits on Intel's x86 architecture. CISC means that a single instruction can do a bunch of diferent things at once such as memory accesses, register reads, etc. It is also a variable-length instruction set which means diferent instructions can be diferent sizes ranging from 1 to 16 bytes long. And finally x86-64 allows for multi-sized register access which means that you can access certain parts of a register which are diferent sizes.\n\n\nx86-64 Registers\n\n\nx86-64 registers behave similarly to other architectures. A key component of x86-64 registers is multi-sized access which means the register RAX can have its lower 32 bits accessed with EAX. The next lower 16 bits can be accessed with AX and the lowest 8 bits can be accessed with AL which allows for the compuler to make optimizations which boost program execution.\n\n\n\nx86-64 has plenty of registers to use including rax, rbx, rcx, rdx, rdi, rsi, rsp, rip, r8-r15, and more! But some registers serve special purposes.\n\n\nThe special registers include:\n- RIP: the instruction pointer\n- RSP: the stack pointer\n- RBP: the base pointer\n\n\nInstructions\n\n\nAn \ninstruction\n represents a single operation for the CPU to perform.\n\n\nThere are diferent types of instructions including:\n\n\n\n\nData movement: \nmov rax, [rsp - 0x40]\n\n\nArithmetic: \nadd rbx, rcx\n\n\nControl-flow: \njne 0x8000400\n\n\n\n\nBecause x86-64 is a CISC architecture, instructions can be quite complex for machine code such as \nrepne scasb\n which repeats up to ECX times over memory at EDI looking for NULL byte (0x00), decrementing ECX each byte (Essentially strlen() in a single instruction!)\n\n\nIt is important to remember that an instruction really is just memory, this idea will become useful with Return Oriented Programming or ROP.\n\n\n\n\nNote\n\n\nInstructions, numbers, strings, everything! Always represented in hex.\n\n\n\n\nadd rax, rbx\nmov rax, 0xdeadbeef\nmov rax, [0xdeadbeef] == 67 48 8b 05 ef be ad de\n\nHello\n == 48 65 6c 6c 6f\n== 48 01 d8\n== 48 c7 c0 ef be ad de\n\n\n\n\n\nExecution\n\n\nWhat should the CPU execute? This is determined by the RIP register where IP means instruction pointer. Execution follows the pattern: fetch the instruction at the address in RIP, decode it, run it.\n\n\nExamples\n\n\n\n\nmov rax, 0xdeadbeef\n\n\n\n\nHere the operation \nmov\n is moving the \"immeadiate\" \n0xdeadbeef\n into the register \nRAX\n\n\n\n\nmov rax, [0xdeadbeef + rbx * 4]\n\n\n\n\nHere the operation \nmov\n is moving the data at the address of \n[0xdeadbeef + RBX*4]\n into the register \nRAX\n. When brackets are used, you can think of the program as getting the content from that effective address.\n\n\nExample Execution\n\n\n-\n 0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804000\n   0x080400a: add, rax, rbx                  RAX = 0x0\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n-\n 0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400a\n-\n 0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400d\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n-\n 0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804010\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n   0x080400d: inc rbx                        RBX = 0x1235\n-\n 0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804013\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0x0\n-\n 0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\n   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0xdeadbeee\n   0x0804013: mov rcx, rax                   RDX = 0x0\n\n\n\n\n\nControl Flow\n\n\nHow can we express conditionals in x86-64? We use conditional jumps such as:\n\n\n\n\njnz \naddress\n\n\nje \naddress\n\n\njge \naddress\n\n\njle \naddress\n\n\netc.\n\n\n\n\nThey jump if their condition is true, and just go to the next instruction otherwise. These conditionals are checking EFLAGS which are special registers which store flags on certain instructions such as \nadd rax, rbx\n which sets the o (overflow) flag if the sum is greater than a 64-bit register can hold, and wraps around. You can jump based on that with a \njo\n instruction. The most important thing to remember is the cmp instruction:\n\n\ncmp rax, rbx\njle error\n\n\n\n\n\nThis assembly jumps if RAX \n= RBX\n\n\nAddresses\n\n\nMemory acts similarly to a big array where the indices of this \"array\" are memory addresses. Remember from earlier:\n\n\nmov rax, [0xdeadbeef]\n\n\nThe square brackets mean \"get the data at this address\". This is analagous to the C/C++ syntax: \nrax = *0xdeadbeef;", 
            "title": "What is Assembly/Machine Code"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#assemblymachine-code", 
            "text": "Machine Code or Assembly is code which has been formatted for direct execution by a CPU. Machine Code is the why readable programming languages like C, when compiled, cannot be reversed into source code (well  Decompilers  can sort of, but more on that later).", 
            "title": "Assembly/Machine Code"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#from-source-to-compilation", 
            "text": "Godbolt  shows the differences in machine code generated by various compilers.  For example, if we have a simple C++ function:  #include   unistd.h  #include   stdio.h  #include   stdlib.h  int   main ()   { \n     char   c ; \n     int   fd   =   syscall ( 2 ,   /etc/passwd ,   0 ); \n     while   ( syscall ( 0 ,   fd ,   c ,   1 ))   { \n         putchar ( c ); \n     }  }   We can see the compilation results in some verbose instrucitons for the CPU:  .LC0: \n   .string   /etc/passwd  main: \n   push   rbp \n   mov   rbp ,   rsp \n   sub   rsp ,   16 \n   mov   edx ,   0 \n   mov   esi ,   OFFSET   FLAT :. LC0 \n   mov   edi ,   2 \n   mov   eax ,   0 \n   call   syscall \n   mov   DWORD   PTR   [ rbp-4 ],   eax  .L3: \n   lea   rdx ,   [ rbp-5 ] \n   mov   eax ,   DWORD   PTR   [ rbp-4 ] \n   mov   ecx ,   1 \n   mov   esi ,   eax \n   mov   edi ,   0 \n   mov   eax ,   0 \n   call   syscall \n   test   rax ,   rax \n   setne   al \n   test   al ,   al \n   je   .L2 \n   movzx   eax ,   BYTE   PTR   [ rbp-5 ] \n   movsx   eax ,   al \n   mov   edi ,   eax \n   call   putchar \n   jmp   .L3  .L2: \n   mov   eax ,   0 \n   leave \n   ret   This is a one way process for compiled languages as there is no way to generate source from machine code. While the machine code may seem unintelligble, the extremely basic functions can be interpreted with some practice.", 
            "title": "From Source to Compilation"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#x86-64", 
            "text": "x86-64 or amd64 or i64 is a 64-bit Complex Instruction Set Computing (CISC) architecture. This basically means that the registers used for this architecture extend an extra 32-bits on Intel's x86 architecture. CISC means that a single instruction can do a bunch of diferent things at once such as memory accesses, register reads, etc. It is also a variable-length instruction set which means diferent instructions can be diferent sizes ranging from 1 to 16 bytes long. And finally x86-64 allows for multi-sized register access which means that you can access certain parts of a register which are diferent sizes.", 
            "title": "x86-64"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#x86-64-registers", 
            "text": "x86-64 registers behave similarly to other architectures. A key component of x86-64 registers is multi-sized access which means the register RAX can have its lower 32 bits accessed with EAX. The next lower 16 bits can be accessed with AX and the lowest 8 bits can be accessed with AL which allows for the compuler to make optimizations which boost program execution.  x86-64 has plenty of registers to use including rax, rbx, rcx, rdx, rdi, rsi, rsp, rip, r8-r15, and more! But some registers serve special purposes.  The special registers include:\n- RIP: the instruction pointer\n- RSP: the stack pointer\n- RBP: the base pointer", 
            "title": "x86-64 Registers"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#instructions", 
            "text": "An  instruction  represents a single operation for the CPU to perform.  There are diferent types of instructions including:   Data movement:  mov rax, [rsp - 0x40]  Arithmetic:  add rbx, rcx  Control-flow:  jne 0x8000400   Because x86-64 is a CISC architecture, instructions can be quite complex for machine code such as  repne scasb  which repeats up to ECX times over memory at EDI looking for NULL byte (0x00), decrementing ECX each byte (Essentially strlen() in a single instruction!)  It is important to remember that an instruction really is just memory, this idea will become useful with Return Oriented Programming or ROP.   Note  Instructions, numbers, strings, everything! Always represented in hex.   add rax, rbx\nmov rax, 0xdeadbeef\nmov rax, [0xdeadbeef] == 67 48 8b 05 ef be ad de Hello  == 48 65 6c 6c 6f\n== 48 01 d8\n== 48 c7 c0 ef be ad de", 
            "title": "Instructions"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#execution", 
            "text": "What should the CPU execute? This is determined by the RIP register where IP means instruction pointer. Execution follows the pattern: fetch the instruction at the address in RIP, decode it, run it.", 
            "title": "Execution"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#examples", 
            "text": "mov rax, 0xdeadbeef   Here the operation  mov  is moving the \"immeadiate\"  0xdeadbeef  into the register  RAX   mov rax, [0xdeadbeef + rbx * 4]   Here the operation  mov  is moving the data at the address of  [0xdeadbeef + RBX*4]  into the register  RAX . When brackets are used, you can think of the program as getting the content from that effective address.", 
            "title": "Examples"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#example-execution", 
            "text": "-  0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804000\n   0x080400a: add, rax, rbx                  RAX = 0x0\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n-  0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400a\n-  0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400d\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n-  0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804010\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n   0x080400d: inc rbx                        RBX = 0x1235\n-  0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804013\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0x0\n-  0x0804013: mov rcx, rax                   RDX = 0x0     0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0xdeadbeee\n   0x0804013: mov rcx, rax                   RDX = 0x0", 
            "title": "Example Execution"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#control-flow", 
            "text": "How can we express conditionals in x86-64? We use conditional jumps such as:   jnz  address  je  address  jge  address  jle  address  etc.   They jump if their condition is true, and just go to the next instruction otherwise. These conditionals are checking EFLAGS which are special registers which store flags on certain instructions such as  add rax, rbx  which sets the o (overflow) flag if the sum is greater than a 64-bit register can hold, and wraps around. You can jump based on that with a  jo  instruction. The most important thing to remember is the cmp instruction:  cmp rax, rbx\njle error  This assembly jumps if RAX  = RBX", 
            "title": "Control Flow"
        }, 
        {
            "location": "/reverse-engineering/what-is-assembly-machine-code/#addresses", 
            "text": "Memory acts similarly to a big array where the indices of this \"array\" are memory addresses. Remember from earlier:  mov rax, [0xdeadbeef]  The square brackets mean \"get the data at this address\". This is analagous to the C/C++ syntax:  rax = *0xdeadbeef;", 
            "title": "Addresses"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/", 
            "text": "The C Programming Language\n\n\nHistory\n\n\nThe C programming language iwas written by Dennis Ritchie in the 1970s while he was working at Bell Labs. It was first used to reimplement the Unix operating system which was purely written in assembly language. At first, the Unix developers were considering using a language called \"B\" but because B wasn't optimized for the target computer, the C language was created.\n\n\n\n\nNote\n\n\nC is the letter and the programming language after B!\n\n\n\n\nC was designed to be close to assembly and is still widely used in lower level programming where speed and control are needed (operating systems, embedded systems). C was also very influential to other programming langauges used today. Notable languages include C++, Objective-C, Golang, Java, JavaScript, PHP, Python, and Rust.\n\n\nHello World\n\n\nC is an ancestor of many other programming languages and if you are familiar with programming, it's likely that C will be at least someewhat familiar.\n\n\n#include\n \nstdio.h\n\n\nint\n \nmain\n()\n\n\n{\n\n   \nprintf\n(\nHello, World!\n);\n\n   \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nToday\n\n\nToday C is widely used either as a low level programming langauge or is the base language that other programming languages are implemented in.\n\n\nWhile it can be difficult to see, the C language compiles down directly into machine code. The compiler is programmed to process the provided C code and emit assembly that's targetted to whatever operating system and architecture the compiler is set to use.\n\n\nSome common compilers include:\n\n\n\n\ngcc\n\n\nclang\n\n\n\n\nA good way to explore this relationship is to use this online \nGCC Explorer\n from Matt Godbolt.\n\n\n\n\nIn regards to CTF, many reverse engineering and exploitation CTF challenges are written in C because the language compiles down directly to assembly and there are little to no safeguards in the language. This means developers must manually handle both. Of course, this can lead to mistakes which can sometimes lead to security issues.\n\n\n\n\nNote\n\n\nOther higher level langauges like Python manage memory and garbage collection for you. Google Golang was inspired by C but adds in functionality like garbage collection, and memory safety.\n\n\n\n\nThere are some examples of famously vulnerable functions in C which are still available and can still result in vulnerabilities:\n\n\n\n\ngets\n - Can result in buffer overflows\n\n\nstrcpy\n - Can result in buffer overflows\n\n\nstrcat\n - Can result in buffer overflows\n\n\nstrcmp\n - Can result in timing attacks\n\n\n\n\nTypes\n\n\nC has four basic types:\n\n\n\n\nchar - characters\n\n\nint - integers (e.g. 125)\n\n\nfloat - 32 bit floating point number (e.g. 2.4)\n\n\ndouble - 64 bit floating point number (like a float but more precise in terms of decimal points)\n\n\n\n\nPointers\n\n\nC uses an idea known as pointers. A pointer is a variable which contains the address of another variable.\n\n\nTo understand this idea we should first understand that memory is laid out in terms of addresses and data gets stored at these addresses.\n\n\nTake the following example of defining an integer in C:\n\n\nint\n \nx\n \n=\n \n4\n;\n\n\n\n\n\n\nTo the programmer this is the variable \nx\n receiving the value of 4. The computer stores this value in some location in memory. For example we can say that address \n0x1000\n now holds the value \n4\n. The computer knows to directly access the memory and retrieve the value \n4\n whenever the programmer tries to use the \nx\n variable. If we were to say \nx + 4\n, the computer would give you \n8\n instead of \n0x1004\n.\n\n\nBut in C we can retrieve the memory address being used to hold the 4 value (i.e. 0x1000) by using the \n character and using \n*\n to create an \"integer pointer\" type.\n\n\nint\n*\n \ny\n \n=\n \nx\n;\n\n\n\n\n\n\nThe \ny\n variable will store the address pointed to by the \nx\nvariable (0x1000).\n\n\n\n\nNote\n\n\nThe \n*\n character allows us to declare pointer variables but also allows us to access the value stored at a pointer. For example, entering \n*y\n allows us to access the 4 value instead of 0x1000.\n\n\n\n\nWhenever we use the \ny\n variable we are using the memory address, but if we use the x variable we use the value stored at the memory address.\n\n\nArrays\n\n\nArrays are a grouping of objects of the same type. They are typically created with the following syntax:\n\n\ntype\n \narrayName\n \n[\n \narraySize\n \n];\n\n\n\n\n\n\nTo initialize values in the array we can do:\n\n\nint\n \nintegers\n[\n \n10\n \n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n};\n\n\n\n\n\n\nArrays allow programmers to group data into logical containers.\n\n\nTo access the indiviual elements of an array we access the contents by their \"index\". Most programming langauges today start counting from 0. So to take our previous example:\n\n\nint\n \nintegers\n[\n \n10\n \n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n};\n\n\n/*     indexes        0  1  2  3  4  5  6  7  8   9\n\n\n\n\n\n\nTo access the value 6 we would use index 5:\n\n\nintegers\n[\n5\n];\n\n\n\n\n\n\nHow do arrays work?\n\n\nArrays are a clever combination of multiplication, pointers, and programming.\n\n\nBecause the computer knows the data type used for every element in the array, the computer needs to simply multiply the size of the data type by the index you are looking for and then add this value to the address of the beginning of the array.\n\n\nFor example if we know that the base address of an array is 1000 and we know that each integer takes 8 bytes, we know that if we have 8 integers right next to each other, we can get the integer at the 4th index with the following math:\n\n\n1000\n \n+\n \n(\n4\n \n*\n \n8\n)\n \n=\n  \n1032\n\n\n\n\n\n\narray\n \n[\n \n1\n   \n,\n \n2\n   \n,\n \n3\n   \n,\n \n4\n   \n,\n \n5\n   \n,\n \n6\n   \n,\n \n7\n   \n,\n \n8\n   \n]\n\n\nindex\n   \n0\n     \n1\n     \n2\n     \n3\n     \n4\n     \n5\n     \n6\n     \n7\n\n\naddrs\n  \n1000\n  \n1008\n  \n1016\n  \n1024\n  \n1032\n  \n1040\n  \n1048\n  \n1056\n\n\n\n\n\n\nMemory Management", 
            "title": "What is C"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#the-c-programming-language", 
            "text": "", 
            "title": "The C Programming Language"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#history", 
            "text": "The C programming language iwas written by Dennis Ritchie in the 1970s while he was working at Bell Labs. It was first used to reimplement the Unix operating system which was purely written in assembly language. At first, the Unix developers were considering using a language called \"B\" but because B wasn't optimized for the target computer, the C language was created.   Note  C is the letter and the programming language after B!   C was designed to be close to assembly and is still widely used in lower level programming where speed and control are needed (operating systems, embedded systems). C was also very influential to other programming langauges used today. Notable languages include C++, Objective-C, Golang, Java, JavaScript, PHP, Python, and Rust.", 
            "title": "History"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#hello-world", 
            "text": "C is an ancestor of many other programming languages and if you are familiar with programming, it's likely that C will be at least someewhat familiar.  #include   stdio.h  int   main ()  { \n    printf ( Hello, World! ); \n    return   0 ;  }", 
            "title": "Hello World"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#today", 
            "text": "Today C is widely used either as a low level programming langauge or is the base language that other programming languages are implemented in.  While it can be difficult to see, the C language compiles down directly into machine code. The compiler is programmed to process the provided C code and emit assembly that's targetted to whatever operating system and architecture the compiler is set to use.  Some common compilers include:   gcc  clang   A good way to explore this relationship is to use this online  GCC Explorer  from Matt Godbolt.   In regards to CTF, many reverse engineering and exploitation CTF challenges are written in C because the language compiles down directly to assembly and there are little to no safeguards in the language. This means developers must manually handle both. Of course, this can lead to mistakes which can sometimes lead to security issues.   Note  Other higher level langauges like Python manage memory and garbage collection for you. Google Golang was inspired by C but adds in functionality like garbage collection, and memory safety.   There are some examples of famously vulnerable functions in C which are still available and can still result in vulnerabilities:   gets  - Can result in buffer overflows  strcpy  - Can result in buffer overflows  strcat  - Can result in buffer overflows  strcmp  - Can result in timing attacks", 
            "title": "Today"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#types", 
            "text": "C has four basic types:   char - characters  int - integers (e.g. 125)  float - 32 bit floating point number (e.g. 2.4)  double - 64 bit floating point number (like a float but more precise in terms of decimal points)", 
            "title": "Types"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#pointers", 
            "text": "C uses an idea known as pointers. A pointer is a variable which contains the address of another variable.  To understand this idea we should first understand that memory is laid out in terms of addresses and data gets stored at these addresses.  Take the following example of defining an integer in C:  int   x   =   4 ;   To the programmer this is the variable  x  receiving the value of 4. The computer stores this value in some location in memory. For example we can say that address  0x1000  now holds the value  4 . The computer knows to directly access the memory and retrieve the value  4  whenever the programmer tries to use the  x  variable. If we were to say  x + 4 , the computer would give you  8  instead of  0x1004 .  But in C we can retrieve the memory address being used to hold the 4 value (i.e. 0x1000) by using the   character and using  *  to create an \"integer pointer\" type.  int *   y   =   x ;   The  y  variable will store the address pointed to by the  x variable (0x1000).   Note  The  *  character allows us to declare pointer variables but also allows us to access the value stored at a pointer. For example, entering  *y  allows us to access the 4 value instead of 0x1000.   Whenever we use the  y  variable we are using the memory address, but if we use the x variable we use the value stored at the memory address.", 
            "title": "Pointers"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#arrays", 
            "text": "Arrays are a grouping of objects of the same type. They are typically created with the following syntax:  type   arrayName   [   arraySize   ];   To initialize values in the array we can do:  int   integers [   10   ]   =   { 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 };   Arrays allow programmers to group data into logical containers.  To access the indiviual elements of an array we access the contents by their \"index\". Most programming langauges today start counting from 0. So to take our previous example:  int   integers [   10   ]   =   { 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 };  /*     indexes        0  1  2  3  4  5  6  7  8   9   To access the value 6 we would use index 5:  integers [ 5 ];", 
            "title": "Arrays"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#how-do-arrays-work", 
            "text": "Arrays are a clever combination of multiplication, pointers, and programming.  Because the computer knows the data type used for every element in the array, the computer needs to simply multiply the size of the data type by the index you are looking for and then add this value to the address of the beginning of the array.  For example if we know that the base address of an array is 1000 and we know that each integer takes 8 bytes, we know that if we have 8 integers right next to each other, we can get the integer at the 4th index with the following math:  1000   +   ( 4   *   8 )   =    1032   array   [   1     ,   2     ,   3     ,   4     ,   5     ,   6     ,   7     ,   8     ]  index     0       1       2       3       4       5       6       7  addrs    1000    1008    1016    1024    1032    1040    1048    1056", 
            "title": "How do arrays work?"
        }, 
        {
            "location": "/reverse-engineering/what-is-c/#memory-management", 
            "text": "", 
            "title": "Memory Management"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/", 
            "text": "Disassemblers\n\n\nA \ndisassembler\n is a tool which breaks down a compiled program into machine code.\n\n\nList of Disassemblers\n\n\n\n\nIDA\n\n\nBinary Ninja\n\n\nGNU Debugger (GDB)\n\n\nradare2\n\n\nHopper\n\n\n\n\nIDA\n\n\nThe Interactive Disassembler (IDA) is the industry standard for binary disassembly. IDA is capable of disassembling \"virtually any popular file format\". This makes it very useful to security researchers and CTF players who often need to analyze obscure files without knowing what they are or where they came from. IDA also features the industry leading Hex Rays decompiler which can convert assembly code back into a pseudo code like format.\n\n\n\n\nIDA also has a plugin interface which has been used to create some successful plugins that can make reverse engineering easier:\n\n\n\n\nhttps://github.com/google/binnavi\n\n\nhttps://github.com/yegord/snowman\n\n\nhttps://github.com/gaasedelen/lighthouse\n\n\nhttps://github.com/joxeankoret/diaphora\n\n\nhttps://github.com/REhints/HexRaysCodeXplorer\n\n\nhttps://github.com/osirislab/Fentanyl\n\n\n\n\nBinary Ninja\n\n\nBinary Ninja is an up and coming disassembler that attempts to bring a new, more programmatic approach to reverse engineering. Binary Ninja brings an improved plugin API and modern features to reverse engineering. While it's less popular or as old as IDA, Binary Ninja (often called binja) is quickly gaining ground and has a small community of dedicated users and followers.\n\n\n\n\nBinja also has some community contributed plugins which are collected here: \nhttps://github.com/Vector35/community-plugins\n\n\ngdb\n\n\nThe GNU Debugger is a free and open source debugger which also disassembles programs. It's capable as a disassembler, but most notably it is used by CTF players for its debugging and dynamic analysis capabailities.\n\n\ngdb is often used in tandom with enhancement scripts like \npeda\n, \npwndbg\n, and \nGEF", 
            "title": "What are Disassemblers"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/#disassemblers", 
            "text": "A  disassembler  is a tool which breaks down a compiled program into machine code.", 
            "title": "Disassemblers"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/#list-of-disassemblers", 
            "text": "IDA  Binary Ninja  GNU Debugger (GDB)  radare2  Hopper", 
            "title": "List of Disassemblers"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/#ida", 
            "text": "The Interactive Disassembler (IDA) is the industry standard for binary disassembly. IDA is capable of disassembling \"virtually any popular file format\". This makes it very useful to security researchers and CTF players who often need to analyze obscure files without knowing what they are or where they came from. IDA also features the industry leading Hex Rays decompiler which can convert assembly code back into a pseudo code like format.   IDA also has a plugin interface which has been used to create some successful plugins that can make reverse engineering easier:   https://github.com/google/binnavi  https://github.com/yegord/snowman  https://github.com/gaasedelen/lighthouse  https://github.com/joxeankoret/diaphora  https://github.com/REhints/HexRaysCodeXplorer  https://github.com/osirislab/Fentanyl", 
            "title": "IDA"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/#binary-ninja", 
            "text": "Binary Ninja is an up and coming disassembler that attempts to bring a new, more programmatic approach to reverse engineering. Binary Ninja brings an improved plugin API and modern features to reverse engineering. While it's less popular or as old as IDA, Binary Ninja (often called binja) is quickly gaining ground and has a small community of dedicated users and followers.   Binja also has some community contributed plugins which are collected here:  https://github.com/Vector35/community-plugins", 
            "title": "Binary Ninja"
        }, 
        {
            "location": "/reverse-engineering/what-are-disassemblers/#gdb", 
            "text": "The GNU Debugger is a free and open source debugger which also disassembles programs. It's capable as a disassembler, but most notably it is used by CTF players for its debugging and dynamic analysis capabailities.  gdb is often used in tandom with enhancement scripts like  peda ,  pwndbg , and  GEF", 
            "title": "gdb"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/", 
            "text": "The GNU Debugger (GDB)\n\n\nThe GNU Debugger or GDB is a powerful debugger which allows for step-by-step execution of a program. It can be used to trace program execution and is an important part of any reverse engineering toolkit.\n\n\nVanilla GDB\n\n\nGDB without any modifications is unintuitive and obscures a lot of useful information. The plug-in \npwndb\n solves a lot of these problems and makes for a much more pleasant experience. But if you are constrained and \nhave\n to use vanilla gdb, here are several things to make your life easier.\n\n\nStarting GDB\n\n\nTo execute GBD and attach it to a program simply run \ngdb [program]\n\n\nDisassembly\n\n\n(gdb) disassemble [address/symbol]\n will display the disassembly for that function/frame\n\n\nGDB will autocomplete functions, so saying \n(gdb) disas main\n suffices if you'd like to see the disassembly of main\n\n\nView Disassembly During Execution\n\n\nAnother handy thing to see while stepping through a program is the disassembly of nearby instructions:\n\n\n(gdb) display/[# of instructions]i $pc [\u00b1 offset]\n\n\n\n\ndisplay\n shows data with each step\n\n\n/[#]i\n shows how much data in the format i for instruction \n\n\n$pc\n means the pc, program counter, register\n\n\n[\u00b1 offset]\n allows you to specify how you would like the data offset from the current instruction\n\n\n\n\nExample Usage\n\n\n(gdb) display/10i $pc - 0x5\n\n\nThis command will show 10 instructions on screen with an offset from the next instruction of 5, giving us this display:\n\n\n   0x8048535 \nmain+6\n:  lock pushl -0x4(%ecx)\n   0x8048539 \nmain+10\n: push   %ebp\n=\n 0x804853a \nmain+11\n: mov    %esp,%ebp\n   0x804853c \nmain+13\n: push   %ecx\n   0x804853d \nmain+14\n: sub    $0x14,%esp\n   0x8048540 \nmain+17\n: sub    $0xc,%esp\n   0x8048543 \nmain+20\n: push   $0x400\n   0x8048548 \nmain+25\n: call   0x80483a0 \nmalloc@plt\n\n   0x804854d \nmain+30\n: add    $0x10,%esp\n   0x8048550 \nmain+33\n: sub    $0xc,%esp\n\n\n\n\n\nDeleting Views\n\n\nIf for whatever reason, a view no long suits your needs simply call \n(gdb) info display\n which will give you a list of active displays:\n\n\nAuto-display expressions now in effect:\nNum Enb Expression\n1:   y  /10bi $pc-0x5\n\n\n\n\n\nThen simply execute \n(gdb) delete display 1\n and your execution will resume without the display.\n\n\nRegisters\n\n\nIn order to view the state of registers with vanilla gdb, you need to run the command \ninfo registers\n which will display the state of all the registers:\n\n\neax            0xf77a6ddc   -142971428\necx            0xffe06b10   -2069744\nedx            0xffe06b34   -2069708\nebx            0x0  0\nesp            0xffe06af8   0xffe06af8\nebp            0x0  0x0\nesi            0xf77a5000   -142979072\nedi            0xf77a5000   -142979072\neip            0x804853a    0x804853a \nmain+11\n\neflags         0x286    [ PF SF IF ]\ncs             0x23 35\nss             0x2b 43\nds             0x2b 43\nes             0x2b 43\nfs             0x0  0\ngs             0x63 99\n\n\n\n\n\nIf you simply would like to see the contents of a single register, the notation \nx/x $[register]\n where:\n\n\n\n\nx/x\n means display the address in hex notation\n\n\n$[register]\n is the register code such as eax, rax, etc.\n\n\n\n\nPwndbg\n\n\nThese commands work with vanilla gdb as well.\n\n\nSetting Breakpoints\n\n\nSetting breakpoints in GDB uses the format \nb*[Address/Symbol]\n\n\nExample Usage\n\n\n\n\n(gdb) b*main\n: Break at the start\n\n\n(gdb) b*0x804854d\n: Break at 0x804854d\n\n\n(gdb) b*0x804854d-0x100\n: Break at 0x804844d\n\n\n\n\nDeleting Breakpoints\n\n\nAs before, in order to delete a view, you can list the available breakpoints using \n(gdb) info breakpoints\n (don't forget about GDB's autocomplete, you don't always need to type out every command!) which will display all breakpoints:\n\n\nNum     Type           Disp Enb Address    What\n1       breakpoint     keep y   0x0804852f \nmain\n\n3       breakpoint     keep y   0x0804864d \n__libc_csu_init+61\n\n\n\n\n\n\nThen simply execute \n(gdb) delete 1\n\n\n\n\nNote\n\n\nGDB creates breakpoints chronologically and does NOT reuse numbers.\n\n\n\n\nStepping\n\n\nWhat good is a debugger if you can't control where you are going? In order to begin execution of a program, use the command \nr [arguments]\n similar to how if you ran it with dot-slash notation you would execute it \n./program [arguments]\n. In this case the program will run normally and if no breakpoints are set, you will execute normally. If you have breakpoints set, you will stop at that instruction.\n\n\n\n\n(gdb) continue [# of breakpoints]\n: Resumes the execution of the program until it finishes or until another breakpoint is hit (shorthand \nc\n)\n\n\n(gdb) step[# of instructions]\n: Steps into an instruction the specified number of times, default is 1 (shorthand \ns\n)\n\n\n(gdb) next instruction [# of instructions]\n: Steps over an instruction meaning it will not delve into called functions (shorthand \nni\n)\n\n\n(gdb) finish\n: Finishes a function and breaks after it gets returned (shorthand \nfin\n)\n\n\n\n\nExamining\n\n\nExamining data in GDB is also very useful for seeing how the program is affecting data. The notation may seem complex at first, but it is flexible and provides powerful functionality.\n\n\n(gdb) x/[#][size][format] [Address/Symbol/Register][\u00b1 offset]\n\n\n\n\nx/\n means examine\n\n\n[#]\n means how much\n\n\n[size]\n means what size the data should be such as a word \nw\n (2 bytes), double word \nd\n (4 bytes), or giant word \ng\n (8 bytes)\n\n\n[format]\n means how the data should be interpreted such as an instruction \ni\n, a string \ns\n, hex bytes \nx\n\n\n[Address/Symbol][\u00b1 offset]\n means where to start interpreting the data\n\n\n\n\nExample Usage\n\n\n\n\n(gdb) x/x $rax\n: Displays the content of the register RAX as hex bytes\n\n\n(gdb) x/i 0xdeadbeef\n: Displays the instruction at address 0xdeadbeef\n\n\n(gdb) x/10s 0x893e10\n: Displays 10 strings at the address\n\n\n(gdb) x/10gx 0x7fe10\n: Displays 10 giant words as hex at the address\n\n\n\n\nForking\n\n\nIf the program happens to be an accept-and-fork server, gdb will have issues following the child or parent processes. In order to specify how you want gdb to function you can use the command \nset follow-fork-mode [on/off]\n\n\nSetting Data\n\n\nIf you would like to set data at any point, it is possible using the command \nset\n \n[\nAddress\n/\nRegister\n]\n=\n[\nHex\n \nData\n]\n\n\nExample Usage\n\n\n\n\nset $rax=0x0\n: Sets the register rax to 0\n\n\nset 0x1e4a70=0x123\n: Sets the data at 0x1e4a70 to 0x123\n\n\n\n\nProcess Mapping\n\n\nA handy way to find the process's mapped address spaces is to use \ninfo proc map\n:\n\n\nMapped address spaces:\n\n    Start Addr   End Addr       Size     Offset objfile\n     0x8048000  0x8049000     0x1000        0x0 /directory/program\n     0x8049000  0x804a000     0x1000        0x0 /directory/program\n     0x804a000  0x804b000     0x1000     0x1000 /directory/program\n    0xf75cb000 0xf75cc000     0x1000        0x0\n    0xf75cc000 0xf7779000   0x1ad000        0x0 /lib32/libc-2.23.so\n    0xf7779000 0xf777b000     0x2000   0x1ac000 /lib32/libc-2.23.so\n    0xf777b000 0xf777c000     0x1000   0x1ae000 /lib32/libc-2.23.so\n    0xf777c000 0xf7780000     0x4000        0x0\n    0xf778b000 0xf778d000     0x2000        0x0 [vvar]\n    0xf778d000 0xf778f000     0x2000        0x0 [vdso]\n    0xf778f000 0xf77b1000    0x22000        0x0 /lib32/ld-2.23.so\n    0xf77b1000 0xf77b2000     0x1000        0x0\n    0xf77b2000 0xf77b3000     0x1000    0x22000 /lib32/ld-2.23.so\n    0xf77b3000 0xf77b4000     0x1000    0x23000 /lib32/ld-2.23.so\n    0xffc59000 0xffc7a000    0x21000        0x0 [stack]\n\n\n\n\n\nThis will show you where the stack, heap (if there is one), and libc are located.\n\n\nAttaching Processes\n\n\nAnother useful feature of GDB is to attach to processes which are already running. Simply launch gdb using \ngdb\n, then find the process id of the program you would like to attach to an execute \nattach [pid]\n.", 
            "title": "What is GDB"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#the-gnu-debugger-gdb", 
            "text": "The GNU Debugger or GDB is a powerful debugger which allows for step-by-step execution of a program. It can be used to trace program execution and is an important part of any reverse engineering toolkit.", 
            "title": "The GNU Debugger (GDB)"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#vanilla-gdb", 
            "text": "GDB without any modifications is unintuitive and obscures a lot of useful information. The plug-in  pwndb  solves a lot of these problems and makes for a much more pleasant experience. But if you are constrained and  have  to use vanilla gdb, here are several things to make your life easier.", 
            "title": "Vanilla GDB"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#starting-gdb", 
            "text": "To execute GBD and attach it to a program simply run  gdb [program]", 
            "title": "Starting GDB"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#disassembly", 
            "text": "(gdb) disassemble [address/symbol]  will display the disassembly for that function/frame  GDB will autocomplete functions, so saying  (gdb) disas main  suffices if you'd like to see the disassembly of main", 
            "title": "Disassembly"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#view-disassembly-during-execution", 
            "text": "Another handy thing to see while stepping through a program is the disassembly of nearby instructions:  (gdb) display/[# of instructions]i $pc [\u00b1 offset]   display  shows data with each step  /[#]i  shows how much data in the format i for instruction   $pc  means the pc, program counter, register  [\u00b1 offset]  allows you to specify how you would like the data offset from the current instruction", 
            "title": "View Disassembly During Execution"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#example-usage", 
            "text": "(gdb) display/10i $pc - 0x5  This command will show 10 instructions on screen with an offset from the next instruction of 5, giving us this display:     0x8048535  main+6 :  lock pushl -0x4(%ecx)\n   0x8048539  main+10 : push   %ebp\n=  0x804853a  main+11 : mov    %esp,%ebp\n   0x804853c  main+13 : push   %ecx\n   0x804853d  main+14 : sub    $0x14,%esp\n   0x8048540  main+17 : sub    $0xc,%esp\n   0x8048543  main+20 : push   $0x400\n   0x8048548  main+25 : call   0x80483a0  malloc@plt \n   0x804854d  main+30 : add    $0x10,%esp\n   0x8048550  main+33 : sub    $0xc,%esp", 
            "title": "Example Usage"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#deleting-views", 
            "text": "If for whatever reason, a view no long suits your needs simply call  (gdb) info display  which will give you a list of active displays:  Auto-display expressions now in effect:\nNum Enb Expression\n1:   y  /10bi $pc-0x5  Then simply execute  (gdb) delete display 1  and your execution will resume without the display.", 
            "title": "Deleting Views"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#registers", 
            "text": "In order to view the state of registers with vanilla gdb, you need to run the command  info registers  which will display the state of all the registers:  eax            0xf77a6ddc   -142971428\necx            0xffe06b10   -2069744\nedx            0xffe06b34   -2069708\nebx            0x0  0\nesp            0xffe06af8   0xffe06af8\nebp            0x0  0x0\nesi            0xf77a5000   -142979072\nedi            0xf77a5000   -142979072\neip            0x804853a    0x804853a  main+11 \neflags         0x286    [ PF SF IF ]\ncs             0x23 35\nss             0x2b 43\nds             0x2b 43\nes             0x2b 43\nfs             0x0  0\ngs             0x63 99  If you simply would like to see the contents of a single register, the notation  x/x $[register]  where:   x/x  means display the address in hex notation  $[register]  is the register code such as eax, rax, etc.", 
            "title": "Registers"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#pwndbg", 
            "text": "These commands work with vanilla gdb as well.", 
            "title": "Pwndbg"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#setting-breakpoints", 
            "text": "Setting breakpoints in GDB uses the format  b*[Address/Symbol]", 
            "title": "Setting Breakpoints"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#example-usage_1", 
            "text": "(gdb) b*main : Break at the start  (gdb) b*0x804854d : Break at 0x804854d  (gdb) b*0x804854d-0x100 : Break at 0x804844d", 
            "title": "Example Usage"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#deleting-breakpoints", 
            "text": "As before, in order to delete a view, you can list the available breakpoints using  (gdb) info breakpoints  (don't forget about GDB's autocomplete, you don't always need to type out every command!) which will display all breakpoints:  Num     Type           Disp Enb Address    What\n1       breakpoint     keep y   0x0804852f  main \n3       breakpoint     keep y   0x0804864d  __libc_csu_init+61   Then simply execute  (gdb) delete 1   Note  GDB creates breakpoints chronologically and does NOT reuse numbers.", 
            "title": "Deleting Breakpoints"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#stepping", 
            "text": "What good is a debugger if you can't control where you are going? In order to begin execution of a program, use the command  r [arguments]  similar to how if you ran it with dot-slash notation you would execute it  ./program [arguments] . In this case the program will run normally and if no breakpoints are set, you will execute normally. If you have breakpoints set, you will stop at that instruction.   (gdb) continue [# of breakpoints] : Resumes the execution of the program until it finishes or until another breakpoint is hit (shorthand  c )  (gdb) step[# of instructions] : Steps into an instruction the specified number of times, default is 1 (shorthand  s )  (gdb) next instruction [# of instructions] : Steps over an instruction meaning it will not delve into called functions (shorthand  ni )  (gdb) finish : Finishes a function and breaks after it gets returned (shorthand  fin )", 
            "title": "Stepping"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#examining", 
            "text": "Examining data in GDB is also very useful for seeing how the program is affecting data. The notation may seem complex at first, but it is flexible and provides powerful functionality.  (gdb) x/[#][size][format] [Address/Symbol/Register][\u00b1 offset]   x/  means examine  [#]  means how much  [size]  means what size the data should be such as a word  w  (2 bytes), double word  d  (4 bytes), or giant word  g  (8 bytes)  [format]  means how the data should be interpreted such as an instruction  i , a string  s , hex bytes  x  [Address/Symbol][\u00b1 offset]  means where to start interpreting the data", 
            "title": "Examining"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#example-usage_2", 
            "text": "(gdb) x/x $rax : Displays the content of the register RAX as hex bytes  (gdb) x/i 0xdeadbeef : Displays the instruction at address 0xdeadbeef  (gdb) x/10s 0x893e10 : Displays 10 strings at the address  (gdb) x/10gx 0x7fe10 : Displays 10 giant words as hex at the address", 
            "title": "Example Usage"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#forking", 
            "text": "If the program happens to be an accept-and-fork server, gdb will have issues following the child or parent processes. In order to specify how you want gdb to function you can use the command  set follow-fork-mode [on/off]", 
            "title": "Forking"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#setting-data", 
            "text": "If you would like to set data at any point, it is possible using the command  set   [ Address / Register ] = [ Hex   Data ]", 
            "title": "Setting Data"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#example-usage_3", 
            "text": "set $rax=0x0 : Sets the register rax to 0  set 0x1e4a70=0x123 : Sets the data at 0x1e4a70 to 0x123", 
            "title": "Example Usage"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#process-mapping", 
            "text": "A handy way to find the process's mapped address spaces is to use  info proc map :  Mapped address spaces:\n\n    Start Addr   End Addr       Size     Offset objfile\n     0x8048000  0x8049000     0x1000        0x0 /directory/program\n     0x8049000  0x804a000     0x1000        0x0 /directory/program\n     0x804a000  0x804b000     0x1000     0x1000 /directory/program\n    0xf75cb000 0xf75cc000     0x1000        0x0\n    0xf75cc000 0xf7779000   0x1ad000        0x0 /lib32/libc-2.23.so\n    0xf7779000 0xf777b000     0x2000   0x1ac000 /lib32/libc-2.23.so\n    0xf777b000 0xf777c000     0x1000   0x1ae000 /lib32/libc-2.23.so\n    0xf777c000 0xf7780000     0x4000        0x0\n    0xf778b000 0xf778d000     0x2000        0x0 [vvar]\n    0xf778d000 0xf778f000     0x2000        0x0 [vdso]\n    0xf778f000 0xf77b1000    0x22000        0x0 /lib32/ld-2.23.so\n    0xf77b1000 0xf77b2000     0x1000        0x0\n    0xf77b2000 0xf77b3000     0x1000    0x22000 /lib32/ld-2.23.so\n    0xf77b3000 0xf77b4000     0x1000    0x23000 /lib32/ld-2.23.so\n    0xffc59000 0xffc7a000    0x21000        0x0 [stack]  This will show you where the stack, heap (if there is one), and libc are located.", 
            "title": "Process Mapping"
        }, 
        {
            "location": "/reverse-engineering/what-is-gdb/#attaching-processes", 
            "text": "Another useful feature of GDB is to attach to processes which are already running. Simply launch gdb using  gdb , then find the process id of the program you would like to attach to an execute  attach [pid] .", 
            "title": "Attaching Processes"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/", 
            "text": "Decompilers\n\n\nDecompilers do the impossible and reverse compiled code \nback\n into psuedocode/code.\n\n\nIDA offers HexRays, which translates machine code into a higher language pseudocode.\n\n\n\n\nExample Workflow\n\n\nLet's say we are disassembling a program which has the source code:\n\n\n#include\n \nstdio.h\n\n\n\nvoid\n \nprintSpacer\n(\nint\n \nnum\n){\n\n    \nfor\n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnum\n;\n \n++\ni\n){\n\n        \nprintf\n(\n-\n);\n\n    \n}\n\n    \nprintf\n(\n\\n\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nchar\n*\n \nstring\n \n=\n \nHello, World!\n;\n\n    \nfor\n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \n13\n;\n \n++\ni\n){\n\n        \nprintf\n(\n%c\n,\n \nstring\n[\ni\n]);\n\n        \nfor\n(\nint\n \nj\n \n=\n \ni\n+\n1\n;\n \nj\n \n \n13\n;\n \nj\n++\n){\n\n            \nprintf\n(\n%c\n,\n \nstring\n[\nj\n]);\n\n        \n}\n\n        \nprintf\n(\n\\n\n);\n\n        \nprintSpacer\n(\n13\n \n-\n \ni\n);\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nAnd creates an output of:\n\n\nHello, World!\n\n\n-------------\n\n\nello, World!\n\n\n------------\n\n\nllo, World!\n\n\n-----------\n\n\nlo, World!\n\n\n----------\n\n\no, World!\n\n\n---------\n\n\n, World!\n\n\n--------\n\n World!\n-------\n\nWorld!\n\n\n------\n\n\norld!\n\n\n-----\n\n\nrld!\n\n\n----\n\n\nld!\n\n\n---\n\nd!\n--\n!\n-\n\n\n\n\n\nIf we are given a binary compiled from that source and we want to figure out how the source looks, we can use a decompiler to get c pseudocode which we can then use to reconstruct the function. The sample decompilation can look like:\n\n\nprintSpacer\n:\n\n\nint\n \n__fastcall\n \nprintSpacer\n(\nint\n \na1\n)\n\n\n{\n\n  \nint\n \ni\n;\n \n// [rsp+8h] [rbp-8h]\n\n\n  \nfor\n \n(\n \ni\n \n=\n \n0\n;\n \ni\n \n \na1\n;\n \n++\ni\n \n)\n\n    \nprintf\n(\n-\n);\n\n  \nreturn\n \nprintf\n(\n\\n\n);\n\n\n}\n\n\n\nmain\n:\n\n\nint\n \n__cdecl\n \nmain\n(\nint\n \nargc\n,\n \nconst\n \nchar\n \n**\nargv\n,\n \nconst\n \nchar\n \n**\nenvp\n)\n\n\n{\n\n  \nint\n \nv4\n;\n \n// [rsp+18h] [rbp-18h]\n\n  \nsigned\n \nint\n \ni\n;\n \n// [rsp+1Ch] [rbp-14h]\n\n\n  \nfor\n \n(\n \ni\n \n=\n \n0\n;\n \ni\n \n \n13\n;\n \n++\ni\n \n)\n\n  \n{\n\n    \nv4\n \n=\n \ni\n \n+\n \n1\n;\n\n    \nprintf\n(\n%c\n,\n \n(\nunsigned\n \nint\n)\naHelloWorld\n[\ni\n],\n \nenvp\n);\n\n    \nwhile\n \n(\n \nv4\n \n \n13\n \n)\n\n      \nprintf\n(\n%c\n,\n \n(\nunsigned\n \nint\n)\naHelloWorld\n[\nv4\n++\n]);\n\n    \nprintf\n(\n\\n\n);\n\n    \nprintSpacer\n(\n13\n \n-\n \ni\n);\n\n  \n}\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nA good method of getting a good representation of the source is to convert the decompilation into Python since Python is basically psuedocode that runs. Starting with main often allows you to gain a good overview of what the program is doing and will help you translate the other functions.\n\n\nMain\n\n\nWe know we will start with a main function and some variables, if you trace the execution of the variables, you can oftentimes determine the variable type. Because \ni\n is being used as an index, we know its an int, and because \nv4\n used as one later on, it too is an index. We can also see that we have a variable \naHelloWorld\n being printed with \"%c\", we can determine it represents the 'Hello, World!' string. Lets define all these variables in our Python main function:\n\n\ndef\n \nmain\n():\n\n    \nstring\n \n=\n \nHello, World!\n\n    \ni\n \n=\n \n0\n\n    \nv4\n \n=\n \n0\n\n    \nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n \n13\n):\n\n        \nv4\n \n=\n \ni\n \n+\n \n1\n\n        \nprint\n(\nstring\n[\ni\n],\n \nend\n=\n)\n\n        \nwhile\n \nv4\n \n \n13\n:\n\n            \nprint\n(\nstring\n[\nv4\n],\n \nend\n=\n)\n\n            \nv4\n \n+=\n \n1\n\n        \nprint\n()\n\n        \nprintSpacer\n(\n13\n-\ni\n)\n\n\n\n\n\n\nprintSpacer Function\n\n\nNow we can see that printSpacer is clearly being fed an int value. Translating it into python shouldn't be too hard.\n\n\ndef\n \nprintSpacer\n(\nnumber\n):\n\n    \ni\n \n=\n \n0\n\n    \nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n \nnumber\n):\n\n        \nprint\n(\n-\n,\n \nend\n=\n)\n\n    \nprint\n()\n\n\n\n\n\n\nResults\n\n\nRunning main() gives us:\n\n\nHello, World!\n\n\n-------------\n\n\nello, World!\n\n\n------------\n\n\nllo, World!\n\n\n-----------\n\n\nlo, World!\n\n\n----------\n\n\no, World!\n\n\n---------\n\n\n, World!\n\n\n--------\n\n World!\n-------\n\nWorld!\n\n\n------\n\n\norld!\n\n\n-----\n\n\nrld!\n\n\n----\n\n\nld!\n\n\n---\n\nd!\n--\n!\n-", 
            "title": "What are Decompilers"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/#decompilers", 
            "text": "Decompilers do the impossible and reverse compiled code  back  into psuedocode/code.  IDA offers HexRays, which translates machine code into a higher language pseudocode.", 
            "title": "Decompilers"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/#example-workflow", 
            "text": "Let's say we are disassembling a program which has the source code:  #include   stdio.h  void   printSpacer ( int   num ){ \n     for ( int   i   =   0 ;   i     num ;   ++ i ){ \n         printf ( - ); \n     } \n     printf ( \\n );  }  int   main ()  { \n     char *   string   =   Hello, World! ; \n     for ( int   i   =   0 ;   i     13 ;   ++ i ){ \n         printf ( %c ,   string [ i ]); \n         for ( int   j   =   i + 1 ;   j     13 ;   j ++ ){ \n             printf ( %c ,   string [ j ]); \n         } \n         printf ( \\n ); \n         printSpacer ( 13   -   i ); \n     } \n     return   0 ;  }   And creates an output of:  Hello, World!  -------------  ello, World!  ------------  llo, World!  -----------  lo, World!  ----------  o, World!  ---------  , World!  -------- \n World!\n------- World!  ------  orld!  -----  rld!  ----  ld!  --- \nd!\n--\n!\n-  If we are given a binary compiled from that source and we want to figure out how the source looks, we can use a decompiler to get c pseudocode which we can then use to reconstruct the function. The sample decompilation can look like:  printSpacer :  int   __fastcall   printSpacer ( int   a1 )  { \n   int   i ;   // [rsp+8h] [rbp-8h] \n\n   for   (   i   =   0 ;   i     a1 ;   ++ i   ) \n     printf ( - ); \n   return   printf ( \\n );  }  main :  int   __cdecl   main ( int   argc ,   const   char   ** argv ,   const   char   ** envp )  { \n   int   v4 ;   // [rsp+18h] [rbp-18h] \n   signed   int   i ;   // [rsp+1Ch] [rbp-14h] \n\n   for   (   i   =   0 ;   i     13 ;   ++ i   ) \n   { \n     v4   =   i   +   1 ; \n     printf ( %c ,   ( unsigned   int ) aHelloWorld [ i ],   envp ); \n     while   (   v4     13   ) \n       printf ( %c ,   ( unsigned   int ) aHelloWorld [ v4 ++ ]); \n     printf ( \\n ); \n     printSpacer ( 13   -   i ); \n   } \n   return   0 ;  }   A good method of getting a good representation of the source is to convert the decompilation into Python since Python is basically psuedocode that runs. Starting with main often allows you to gain a good overview of what the program is doing and will help you translate the other functions.", 
            "title": "Example Workflow"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/#main", 
            "text": "We know we will start with a main function and some variables, if you trace the execution of the variables, you can oftentimes determine the variable type. Because  i  is being used as an index, we know its an int, and because  v4  used as one later on, it too is an index. We can also see that we have a variable  aHelloWorld  being printed with \"%c\", we can determine it represents the 'Hello, World!' string. Lets define all these variables in our Python main function:  def   main (): \n     string   =   Hello, World! \n     i   =   0 \n     v4   =   0 \n     for   i   in   range ( 0 ,   13 ): \n         v4   =   i   +   1 \n         print ( string [ i ],   end = ) \n         while   v4     13 : \n             print ( string [ v4 ],   end = ) \n             v4   +=   1 \n         print () \n         printSpacer ( 13 - i )", 
            "title": "Main"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/#printspacer-function", 
            "text": "Now we can see that printSpacer is clearly being fed an int value. Translating it into python shouldn't be too hard.  def   printSpacer ( number ): \n     i   =   0 \n     for   i   in   range ( 0 ,   number ): \n         print ( - ,   end = ) \n     print ()", 
            "title": "printSpacer Function"
        }, 
        {
            "location": "/reverse-engineering/what-are-decompilers/#results", 
            "text": "Running main() gives us:  Hello, World!  -------------  ello, World!  ------------  llo, World!  -----------  lo, World!  ----------  o, World!  ---------  , World!  -------- \n World!\n------- World!  ------  orld!  -----  rld!  ----  ld!  --- \nd!\n--\n!\n-", 
            "title": "Results"
        }, 
        {
            "location": "/binary-exploitation/overview/", 
            "text": "Binary Exploitation\n\n\nBinaries, or executables, are machine code for a computer to execute. For the most part, the binaries that you will face in CTFs are Linux ELF files or the occasional windows executable. Binary Exploitation is a broad topic within Cyber Security which really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program's functions.\n\n\nCommon topics addressed by Binary Exploitation or 'pwn' challenges include:\n\n\n\n\nRegisters\n\n\nThe Stack\n\n\nCalling Conventions\n\n\nGlobal Offset Table (GOT)\n\n\nBuffers\n\n\nBuffer Overflow\n\n\n\n\n\n\nReturn Oriented Programming (ROP)\n\n\nBinary Security\n\n\nNo eXecute (NX)\n\n\nAddress Space Layout Randomization (ASLR)\n\n\nStack Canaries\n\n\nRelocation Read-Only (RELRO)\n\n\n\n\n\n\nThe Heap\n\n\nHeap Exploitation\n\n\n\n\n\n\nFormat String Vulnerability", 
            "title": "Overview"
        }, 
        {
            "location": "/binary-exploitation/overview/#binary-exploitation", 
            "text": "Binaries, or executables, are machine code for a computer to execute. For the most part, the binaries that you will face in CTFs are Linux ELF files or the occasional windows executable. Binary Exploitation is a broad topic within Cyber Security which really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program's functions.  Common topics addressed by Binary Exploitation or 'pwn' challenges include:   Registers  The Stack  Calling Conventions  Global Offset Table (GOT)  Buffers  Buffer Overflow    Return Oriented Programming (ROP)  Binary Security  No eXecute (NX)  Address Space Layout Randomization (ASLR)  Stack Canaries  Relocation Read-Only (RELRO)    The Heap  Heap Exploitation    Format String Vulnerability", 
            "title": "Binary Exploitation"
        }, 
        {
            "location": "/binary-exploitation/what-are-registers/", 
            "text": "Registers\n\n\nA \nregister\n is a location within the processor that is able to store data, much like RAM. Unlike RAM however, accesses to registers are effectively instantaneous, whereas reads from main memory can take hundreds of CPU cycles to return.\n\n\nRegisters can hold any value: addresses (pointers), results from mathematical operations, characters, etc. Some registers are \nreserved\n however, meaning they have a special purpose and are not \"general purpose registers\" (GPRs). On x86, the only 2 reserved registers are \nrip\n and \nrsp\n which hold the address of the next instruction to execute and the address of the \nstack\n respectively.\n\n\nOn x86, the same register can have different sized accesses for backwards compatability. For example, the \nrax\n register is the full 64-bit register, \neax\n is the low 32 bits of \nrax\n, \nax\n is the low 16 bits, \nal\n is the low 8 bits, and \nah\n is the high 8 bits of \nax\n (bits 8-16 of \nrax\n).", 
            "title": "What are Registers"
        }, 
        {
            "location": "/binary-exploitation/what-are-registers/#registers", 
            "text": "A  register  is a location within the processor that is able to store data, much like RAM. Unlike RAM however, accesses to registers are effectively instantaneous, whereas reads from main memory can take hundreds of CPU cycles to return.  Registers can hold any value: addresses (pointers), results from mathematical operations, characters, etc. Some registers are  reserved  however, meaning they have a special purpose and are not \"general purpose registers\" (GPRs). On x86, the only 2 reserved registers are  rip  and  rsp  which hold the address of the next instruction to execute and the address of the  stack  respectively.  On x86, the same register can have different sized accesses for backwards compatability. For example, the  rax  register is the full 64-bit register,  eax  is the low 32 bits of  rax ,  ax  is the low 16 bits,  al  is the low 8 bits, and  ah  is the high 8 bits of  ax  (bits 8-16 of  rax ).", 
            "title": "Registers"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-stack/", 
            "text": "The Stack\n\n\nIn computer architecture, the stack is a hardware manifestation of the stack data structure (a Last In, First Out queue).\n\n\nIn x86, the stack is simply an area in RAM that was chosen to be the stack - there is no special hardware to store stack contents. The \nesp\n/\nrsp\n register holds the address in memory where the bottom of the stack resides. When something is \npush\ned to the stack, \nesp\n decrements by 4 (or 8 on 64-bit x86), and the value that was \npush\ned is stored at that location in memory. Likewise, when a \npop\n instruction is executed, the value at \nesp\n is retrieved (i.e. \nesp\n is dereferenced), and\n\nesp\n is then incremented by 4 (or 8).\n\n\nN.B. The stack \"grows\" down to lower memory addresses!\n\n\nConventionally, \nebp\n/\nrbp\n contains the address of the top of the current \nstack frame\n, and so sometimes local variables are referenced as an offset relative to \nebp\n rather than an offset to \nesp\n. A stack frame is essentially just the space used on the stack by a given function.\n\n\nUses\n\n\nThe stack is primarily used for a few things:\n\n\n\n\nStoring function arguments\n\n\nStoring local variables\n\n\nStoring processor state between function calls\n\n\n\n\nExample\n\n\nLet's see what the stack looks like right after \nsay_hi\n has been called in this 32-bit x86 C program:\n\n\n#include\n \nstdio.h\n\n\n\nvoid\n \nsay_hi\n(\nconst\n \nchar\n \n*\n \nname\n)\n \n{\n\n    \nprintf\n(\nHello %s!\n\\n\n,\n \nname\n);\n\n\n}\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\n \nargv\n)\n \n{\n\n    \nchar\n \n*\n \nname\n;\n\n    \nif\n \n(\nargc\n \n!=\n \n2\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nname\n \n=\n \nargv\n[\n1\n];\n\n    \nsay_hi\n(\nname\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nAnd the relevant assembly:\n\n\n0804840b \nsay_hi\n:\n 804840b:   55                      push   ebp\n 804840c:   89 e5                   mov    ebp,esp\n 804840e:   83 ec 08                sub    esp,0x8\n 8048411:   83 ec 08                sub    esp,0x8\n 8048414:   ff 75 08                push   DWORD PTR [ebp+0x8]\n 8048417:   68 f0 84 04 08          push   0x80484f0\n 804841c:   e8 bf fe ff ff          call   80482e0 \nprintf@plt\n\n 8048421:   83 c4 10                add    esp,0x10\n 8048424:   90                      nop\n 8048425:   c9                      leave\n 8048426:   c3                      ret\n\n08048427 \nmain\n:\n 8048427:   8d 4c 24 04             lea    ecx,[esp+0x4]\n 804842b:   83 e4 f0                and    esp,0xfffffff0\n 804842e:   ff 71 fc                push   DWORD PTR [ecx-0x4]\n 8048431:   55                      push   ebp\n 8048432:   89 e5                   mov    ebp,esp\n 8048434:   51                      push   ecx\n 8048435:   83 ec 14                sub    esp,0x14\n 8048438:   89 c8                   mov    eax,ecx\n 804843a:   83 38 02                cmp    DWORD PTR [eax],0x2\n 804843d:   74 07                   je     8048446 \nmain+0x1f\n\n 804843f:   b8 01 00 00 00          mov    eax,0x1\n 8048444:   eb 1c                   jmp    8048462 \nmain+0x3b\n\n 8048446:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 8048449:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 804844c:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax\n 804844f:   83 ec 0c                sub    esp,0xc\n 8048452:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n 8048455:   e8 b1 ff ff ff          call   804840b \nsay_hi\n\n 804845a:   83 c4 10                add    esp,0x10\n 804845d:   b8 00 00 00 00          mov    eax,0x0\n 8048462:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\n 8048465:   c9                      leave\n 8048466:   8d 61 fc                lea    esp,[ecx-0x4]\n 8048469:   c3                      ret\n\n\n\n\n\nSkipping over the bulk of \nmain\n, you'll see that at \n0x8048452\n \nmain\n's \nname\n local is pushed to the stack because it's the first argument to \nsay_hi\n. Then, a \ncall\n instruction is executed. \ncall\n instructions first push the current instruction pointer to the stack, then jump to their destination. So when the processor begins executing \nsay_hi\n at \n0x0804840b\n, the stack looks like this:\n\n\nEIP = 0x0804840b (push ebp)\nESP = 0xffff0000\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -\n  0xffff0000: 0x0804845a              // Return address for say_hi\n\n\n\n\n\nThe first thing \nsay_hi\n does is save the current \nebp\n so that when it returns, \nebp\n is back where \nmain\n expects it to be. The stack now looks like this:\n\n\nEIP = 0x0804840c (mov ebp, esp)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nESP -\n  0xfffefffc: 0xffff002c              // Saved EBP\n\n\n\n\n\nAgain, note how \nesp\n gets smaller when values are pushed to the stack.\n\n\nNext, the current \nesp\n is saved into \nebp\n, marking the top of the new stack frame.\n\n\nEIP = 0x0804840e (sub esp, 0x8)\nESP = 0xfffefffc\nEBP = 0xfffefffc\n\n            0xffff0004: 0xffffa0a0              // say_hi argument 1\n            0xffff0000: 0x0804845a              // Return address for say_hi\nESP, EBP -\n 0xfffefffc: 0xffff002c              // Saved EBP\n\n\n\n\n\nThen, the stack is \"grown\" to accommodate local variables inside \nsay_hi\n.\n\n\nEIP = 0x08048414 (push [ebp + 0x8])\nESP = 0xfffeffec\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -\n  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\nESP -\n  0xfffefffc: UNDEFINED\n\n\n\n\n\nNOTE: stack space is not implictly cleared!\n\n\nNow, the 2 arguments to \nprintf\n are pushed in reverse order.\n\n\nEIP = 0x0804841c (call printf@plt)\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -\n  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\nESP -\n  0xfffeffe4: 0x080484f0              // printf argument 1\n\n\n\n\n\nFinally, \nprintf\n is called, which pushes the address of the next instruction to execute.\n\n\nEIP = 0x080482e0\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -\n  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\n        0xfffeffe4: 0x080484f0              // printf argument 1\nESP -\n  0xfffeffe0: 0x08048421              // Return address for printf\n\n\n\n\n\nOnce \nprintf\n has returned, the \nleave\n instruction moves \nebp\n into \nesp\n, and pops the saved EBP.\n\n\nEIP = 0x08048426 (ret)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -\n  0xffff0000: 0x0804845a              // Return address for say_hi\n\n\n\n\n\nAnd finally, \nret\n pops the saved instruction pointer into \neip\n which causes the program to return to main with the same \nesp\n, \nebp\n, and stack contents as when \nsay_hi\n was initially called.\n\n\nEIP = 0x0804845a (add esp, 0x10)\nESP = 0xffff0000\nEBP = 0xffff002c\n\nESP -\n  0xffff0004: 0xffffa0a0              // say_hi argument 1", 
            "title": "What is the Stack"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-stack/#the-stack", 
            "text": "In computer architecture, the stack is a hardware manifestation of the stack data structure (a Last In, First Out queue).  In x86, the stack is simply an area in RAM that was chosen to be the stack - there is no special hardware to store stack contents. The  esp / rsp  register holds the address in memory where the bottom of the stack resides. When something is  push ed to the stack,  esp  decrements by 4 (or 8 on 64-bit x86), and the value that was  push ed is stored at that location in memory. Likewise, when a  pop  instruction is executed, the value at  esp  is retrieved (i.e.  esp  is dereferenced), and esp  is then incremented by 4 (or 8).  N.B. The stack \"grows\" down to lower memory addresses!  Conventionally,  ebp / rbp  contains the address of the top of the current  stack frame , and so sometimes local variables are referenced as an offset relative to  ebp  rather than an offset to  esp . A stack frame is essentially just the space used on the stack by a given function.", 
            "title": "The Stack"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-stack/#uses", 
            "text": "The stack is primarily used for a few things:   Storing function arguments  Storing local variables  Storing processor state between function calls", 
            "title": "Uses"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-stack/#example", 
            "text": "Let's see what the stack looks like right after  say_hi  has been called in this 32-bit x86 C program:  #include   stdio.h  void   say_hi ( const   char   *   name )   { \n     printf ( Hello %s! \\n ,   name );  }  int   main ( int   argc ,   char   **   argv )   { \n     char   *   name ; \n     if   ( argc   !=   2 )   { \n         return   1 ; \n     } \n     name   =   argv [ 1 ]; \n     say_hi ( name ); \n     return   0 ;  }   And the relevant assembly:  0804840b  say_hi :\n 804840b:   55                      push   ebp\n 804840c:   89 e5                   mov    ebp,esp\n 804840e:   83 ec 08                sub    esp,0x8\n 8048411:   83 ec 08                sub    esp,0x8\n 8048414:   ff 75 08                push   DWORD PTR [ebp+0x8]\n 8048417:   68 f0 84 04 08          push   0x80484f0\n 804841c:   e8 bf fe ff ff          call   80482e0  printf@plt \n 8048421:   83 c4 10                add    esp,0x10\n 8048424:   90                      nop\n 8048425:   c9                      leave\n 8048426:   c3                      ret\n\n08048427  main :\n 8048427:   8d 4c 24 04             lea    ecx,[esp+0x4]\n 804842b:   83 e4 f0                and    esp,0xfffffff0\n 804842e:   ff 71 fc                push   DWORD PTR [ecx-0x4]\n 8048431:   55                      push   ebp\n 8048432:   89 e5                   mov    ebp,esp\n 8048434:   51                      push   ecx\n 8048435:   83 ec 14                sub    esp,0x14\n 8048438:   89 c8                   mov    eax,ecx\n 804843a:   83 38 02                cmp    DWORD PTR [eax],0x2\n 804843d:   74 07                   je     8048446  main+0x1f \n 804843f:   b8 01 00 00 00          mov    eax,0x1\n 8048444:   eb 1c                   jmp    8048462  main+0x3b \n 8048446:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 8048449:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 804844c:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax\n 804844f:   83 ec 0c                sub    esp,0xc\n 8048452:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n 8048455:   e8 b1 ff ff ff          call   804840b  say_hi \n 804845a:   83 c4 10                add    esp,0x10\n 804845d:   b8 00 00 00 00          mov    eax,0x0\n 8048462:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\n 8048465:   c9                      leave\n 8048466:   8d 61 fc                lea    esp,[ecx-0x4]\n 8048469:   c3                      ret  Skipping over the bulk of  main , you'll see that at  0x8048452   main 's  name  local is pushed to the stack because it's the first argument to  say_hi . Then, a  call  instruction is executed.  call  instructions first push the current instruction pointer to the stack, then jump to their destination. So when the processor begins executing  say_hi  at  0x0804840b , the stack looks like this:  EIP = 0x0804840b (push ebp)\nESP = 0xffff0000\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -   0xffff0000: 0x0804845a              // Return address for say_hi  The first thing  say_hi  does is save the current  ebp  so that when it returns,  ebp  is back where  main  expects it to be. The stack now looks like this:  EIP = 0x0804840c (mov ebp, esp)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nESP -   0xfffefffc: 0xffff002c              // Saved EBP  Again, note how  esp  gets smaller when values are pushed to the stack.  Next, the current  esp  is saved into  ebp , marking the top of the new stack frame.  EIP = 0x0804840e (sub esp, 0x8)\nESP = 0xfffefffc\nEBP = 0xfffefffc\n\n            0xffff0004: 0xffffa0a0              // say_hi argument 1\n            0xffff0000: 0x0804845a              // Return address for say_hi\nESP, EBP -  0xfffefffc: 0xffff002c              // Saved EBP  Then, the stack is \"grown\" to accommodate local variables inside  say_hi .  EIP = 0x08048414 (push [ebp + 0x8])\nESP = 0xfffeffec\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -   0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\nESP -   0xfffefffc: UNDEFINED  NOTE: stack space is not implictly cleared!  Now, the 2 arguments to  printf  are pushed in reverse order.  EIP = 0x0804841c (call printf@plt)\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -   0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\nESP -   0xfffeffe4: 0x080484f0              // printf argument 1  Finally,  printf  is called, which pushes the address of the next instruction to execute.  EIP = 0x080482e0\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -   0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\n        0xfffeffe4: 0x080484f0              // printf argument 1\nESP -   0xfffeffe0: 0x08048421              // Return address for printf  Once  printf  has returned, the  leave  instruction moves  ebp  into  esp , and pops the saved EBP.  EIP = 0x08048426 (ret)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -   0xffff0000: 0x0804845a              // Return address for say_hi  And finally,  ret  pops the saved instruction pointer into  eip  which causes the program to return to main with the same  esp ,  ebp , and stack contents as when  say_hi  was initially called.  EIP = 0x0804845a (add esp, 0x10)\nESP = 0xffff0000\nEBP = 0xffff002c\n\nESP -   0xffff0004: 0xffffa0a0              // say_hi argument 1", 
            "title": "Example"
        }, 
        {
            "location": "/binary-exploitation/what-are-calling-conventions/", 
            "text": "Calling Conventions\n\n\nTo be able to call functions, there needs to be an agreed-upon way to pass arguments. If a program is entirely self-contained in a binary, the compiler would be free to decide the calling convention. However in reality, shared libraries are used so that common code (e.g. libc) can be stored once and dynamically linked in to programs that need it, reducing program size.\n\n\nIn Linux binaries, there are really only two commonly used calling conventions: cdecl for 32-bit binaries, and SysV for 64-bit\n\n\ncdecl\n\n\nIn 32-bit binaries on Linux, function arguments are passed in on \nthe stack\n in reverse order. A function like this:\n\n\nint\n \nadd\n(\nint\n \na\n,\n \nint\n \nb\n,\n \nint\n \nc\n)\n \n{\n\n    \nreturn\n \na\n \n+\n \nb\n \n+\n \nc\n;\n\n\n}\n\n\n\n\n\n\nwould be invoked by pushing \nc\n, then \nb\n, then \na\n.\n\n\nSysV\n\n\nFor 64-bit binaries, function arguments are first passed in certain registers:\n\n\n\n\nRDI\n\n\nRSI\n\n\nRDX\n\n\nRCX\n\n\nR8\n\n\nR9\n\n\n\n\nthen any leftover arguments are pushed onto the stack in reverse order, as in cdecl.\n\n\nOther Conventions\n\n\nAny method of passing arguments could be used as long as the compiler is aware of what the convention is. As a result, there have been \nmany\n calling conventions in the past that aren't used frequently anymore. See \nWikipedia\n for a comprehensive list.", 
            "title": "What are Calling Conventions"
        }, 
        {
            "location": "/binary-exploitation/what-are-calling-conventions/#calling-conventions", 
            "text": "To be able to call functions, there needs to be an agreed-upon way to pass arguments. If a program is entirely self-contained in a binary, the compiler would be free to decide the calling convention. However in reality, shared libraries are used so that common code (e.g. libc) can be stored once and dynamically linked in to programs that need it, reducing program size.  In Linux binaries, there are really only two commonly used calling conventions: cdecl for 32-bit binaries, and SysV for 64-bit", 
            "title": "Calling Conventions"
        }, 
        {
            "location": "/binary-exploitation/what-are-calling-conventions/#cdecl", 
            "text": "In 32-bit binaries on Linux, function arguments are passed in on  the stack  in reverse order. A function like this:  int   add ( int   a ,   int   b ,   int   c )   { \n     return   a   +   b   +   c ;  }   would be invoked by pushing  c , then  b , then  a .", 
            "title": "cdecl"
        }, 
        {
            "location": "/binary-exploitation/what-are-calling-conventions/#sysv", 
            "text": "For 64-bit binaries, function arguments are first passed in certain registers:   RDI  RSI  RDX  RCX  R8  R9   then any leftover arguments are pushed onto the stack in reverse order, as in cdecl.", 
            "title": "SysV"
        }, 
        {
            "location": "/binary-exploitation/what-are-calling-conventions/#other-conventions", 
            "text": "Any method of passing arguments could be used as long as the compiler is aware of what the convention is. As a result, there have been  many  calling conventions in the past that aren't used frequently anymore. See  Wikipedia  for a comprehensive list.", 
            "title": "Other Conventions"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-got/", 
            "text": "GOT\n\n\nThe Global Offset Table (or GOT) is a section inside of programs that holds addresses of functions that are dynamically linked. As mentioned in the page on \ncalling conventions\n, most programs don't include every function they use to reduce binary size. Instead, common functions (like those in libc) are \"linked\" into the program so they can be saved once on disk and reused by every program.\n\n\nUnless a program is marked \nfull RELRO\n, the resolution of function to address in dynamic library is done lazily. All dynamic libraries are loaded into memory along with the main program at launch, however functions are not mapped to their actual code until they're first called. For example, in the following C snippet \nputs\n won't be resolved to an address in libc until after it has been called once:\n\n\nint\n \nmain\n()\n \n{\n\n    \nputs\n(\nHi there!\n);\n\n    \nputs\n(\nOk bye now.\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nTo avoid searching through shared libraries each time a function is called, the result of the lookup is saved into the GOT so future function calls \"short circuit\" straight to their implementation bypassing the dynamic resolver.\n\n\nThis has two important implications:\n\n\n\n\nThe GOT contains pointers to libraries which move around due to \nASLR\n\n\nThe GOT is writable\n\n\n\n\nThese two facts will become very useful to use in \nReturn Oriented Programming\n\n\nPLT\n\n\nBefore a functions address has been resolved, the GOT points to an entry in the Procedure Linkage Table (PLT). This is a small \"stub\" function which is responsible for calling the dynamic linker with (effectively) the name of the function that should be resolved.", 
            "title": "What is the GOT"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-got/#got", 
            "text": "The Global Offset Table (or GOT) is a section inside of programs that holds addresses of functions that are dynamically linked. As mentioned in the page on  calling conventions , most programs don't include every function they use to reduce binary size. Instead, common functions (like those in libc) are \"linked\" into the program so they can be saved once on disk and reused by every program.  Unless a program is marked  full RELRO , the resolution of function to address in dynamic library is done lazily. All dynamic libraries are loaded into memory along with the main program at launch, however functions are not mapped to their actual code until they're first called. For example, in the following C snippet  puts  won't be resolved to an address in libc until after it has been called once:  int   main ()   { \n     puts ( Hi there! ); \n     puts ( Ok bye now. ); \n     return   0 ;  }   To avoid searching through shared libraries each time a function is called, the result of the lookup is saved into the GOT so future function calls \"short circuit\" straight to their implementation bypassing the dynamic resolver.  This has two important implications:   The GOT contains pointers to libraries which move around due to  ASLR  The GOT is writable   These two facts will become very useful to use in  Return Oriented Programming", 
            "title": "GOT"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-got/#plt", 
            "text": "Before a functions address has been resolved, the GOT points to an entry in the Procedure Linkage Table (PLT). This is a small \"stub\" function which is responsible for calling the dynamic linker with (effectively) the name of the function that should be resolved.", 
            "title": "PLT"
        }, 
        {
            "location": "/binary-exploitation/what-are-buffers/", 
            "text": "Buffers\n\n\nA buffer is any allocated space in memory where data (often user input) can be stored. For example, in the following C program \nname\n would be considered a stack buffer:\n\n\n#include\n \nstdio.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nchar\n \nname\n[\n64\n]\n \n=\n \n{\n0\n};\n\n    \nread\n(\n0\n,\n \nname\n,\n \n63\n);\n\n    \nprintf\n(\nHello %s\n,\n \nname\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nBuffers could also be global variables:\n\n\n#include\n \nstdio.h\n\n\n\nchar\n \nname\n[\n64\n]\n \n=\n \n{\n0\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nread\n(\n0\n,\n \nname\n,\n \n63\n);\n\n    \nprintf\n(\nHello %s\n,\n \nname\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nOr dynamically allocated on the \nheap\n:\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nchar\n \n*\nname\n \n=\n \nmalloc\n(\n64\n);\n\n    \nmemset\n(\nname\n,\n \n0\n,\n \n64\n);\n\n    \nread\n(\n0\n,\n \nname\n,\n \n63\n);\n\n    \nprintf\n(\nHello %s\n,\n \nname\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nExploits\n\n\nGiven that buffers commonly hold user input, mistakes when writing to them could result in attacker controlled data being written outside of the buffer's space. See the page on \nbuffer overflows\n for more.", 
            "title": "What are Buffers"
        }, 
        {
            "location": "/binary-exploitation/what-are-buffers/#buffers", 
            "text": "A buffer is any allocated space in memory where data (often user input) can be stored. For example, in the following C program  name  would be considered a stack buffer:  #include   stdio.h  int   main ()   { \n     char   name [ 64 ]   =   { 0 }; \n     read ( 0 ,   name ,   63 ); \n     printf ( Hello %s ,   name ); \n     return   0 ;  }   Buffers could also be global variables:  #include   stdio.h  char   name [ 64 ]   =   { 0 };  int   main ()   { \n     read ( 0 ,   name ,   63 ); \n     printf ( Hello %s ,   name ); \n     return   0 ;  }   Or dynamically allocated on the  heap :  #include   stdio.h  #include   stdlib.h  int   main ()   { \n     char   * name   =   malloc ( 64 ); \n     memset ( name ,   0 ,   64 ); \n     read ( 0 ,   name ,   63 ); \n     printf ( Hello %s ,   name ); \n     return   0 ;  }", 
            "title": "Buffers"
        }, 
        {
            "location": "/binary-exploitation/what-are-buffers/#exploits", 
            "text": "Given that buffers commonly hold user input, mistakes when writing to them could result in attacker controlled data being written outside of the buffer's space. See the page on  buffer overflows  for more.", 
            "title": "Exploits"
        }, 
        {
            "location": "/binary-exploitation/buffer-overflow/", 
            "text": "Buffer Overflow\n\n\nA Buffer Overflow is a vulnerability in which data can be written which exceeds the allocated space, allowing an attacker to overwrite other data.\n\n\nStack buffer overflow\n\n\nThe simplest and most common buffer overflow is one where the buffer is on \nthe stack\n. Let's look at an example.\n\n\n#include\n \nstdio.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nint\n \nsecret\n \n=\n \n0xdeadbeef\n;\n\n    \nchar\n \nname\n[\n100\n]\n \n=\n \n{\n0\n};\n\n    \nread\n(\n0\n,\n \nname\n,\n \n0x100\n);\n\n    \nif\n \n(\nsecret\n \n==\n \n0x1337\n)\n \n{\n\n        \nputs\n(\nWow! Here\ns a secret.\n);\n\n    \n}\n \nelse\n \n{\n\n        \nputs\n(\nI guess you\nre not cool enough to see my secret\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThere's a tiny mistake in this program which will allow us to see the secret. \nname\n is decimal 100 bytes, however we're reading in hex 100 bytes (=256 decimal bytes)! Let's see how we can use this to our advantage.\n\n\nIf the compiler chose to layout the stack like this:\n\n\n        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x0\nESP -\n  0xffff0000: 0x0         // name\n\n\n\n\n\nlet's look at what happens when we read in 0x100 bytes of 'A's.\n\n\nThe first decimal 100 bytes are saved properly:\n\n\n        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x41414141\nESP -\n  0xffff0000: 0x41414141  // name\n\n\n\n\n\nHowever when the 101st byte is read in, we see an issue:\n\n\n        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbe41  // secret\n...\n        0xffff0004: 0x41414141\nESP -\n  0xffff0000: 0x41414141  // name\n\n\n\n\n\nThe least significant byte of \nsecret\n has been overwritten! If we follow the next 3 bytes to be read in, we'll see the entirety of \nsecret\n is \"clobbered\" with our 'A's\n\n\n        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0x41414141  // secret\n...\n        0xffff0004: 0x41414141\nESP -\n  0xffff0000: 0x41414141  // name\n\n\n\n\n\nThe remaining 152 bytes would continue clobbering values up the stack.\n\n\nPassing an impossible check\n\n\nHow can we use this to pass the seemingly impossible check in the original program? Well, if we carefully line up our input so that the bytes that overwrite \nsecret\n happen to be the bytes that represent 0x1337 in little-endian, we'll see the secret message.\n\n\nA small Python one-liner will work nicely: \npython -c \nprint \nA\n*100 + \n\\x31\\x13\\x00\\x00\n\n\nThis will fill the \nname\n buffer with 100 'A's, then overwrite \nsecret\n with the 32-bit little-endian encoding of 0x1337.\n\n\nGoing one step further\n\n\nAs discussed on \nthe stack\n page, the instruction that the current function should jump to when it is done is also saved on the stack (denoted as \"Saved EIP\" in the above stack diagrams). If we can overwrite this, we can control where the program jumps after \nmain\n finishes running, giving us the ability to control what the program does entirely.\n\n\nUsually, the end objective in binary exploitation is to get a shell (often called \"popping a shell\") on the remote computer. The shell provides us with an easy way to run \nanything\n we want on the target computer.\n\n\nSay there happens to be a nice function that does this defined somewhere else in the program that we normally can't get to:\n\n\nvoid\n \ngive_shell\n()\n \n{\n\n    \nsystem\n(\n/bin/sh\n);\n\n\n}\n\n\n\n\n\n\nWell with our buffer overflow knowledge, now we can! All we have to do is overwrite the saved EIP on the stack to the address where \ngive_shell\n is. Then, when main returns, it will pop that address off of the stack and jump to it, running \ngive_shell\n, and giving us our shell.\n\n\nAssuming \ngive_shell\n is at 0x08048fd0, we could use something like this: \npython -c \nprint \nA\n*108 + \n\\xd0\\x8f\\x04\\x08\n\n\nWe send 108 'A's to overwrite the 100 bytes that is allocated for \nname\n, the 4 bytes for \nsecret\n, and the 4 bytes for the saved EBP. Then we simply send the little-endian form of \ngive_shell\n's address, and we would get a shell!\n\n\nThis idea is extended on in \nReturn Oriented Programming", 
            "title": "Buffer Overflow"
        }, 
        {
            "location": "/binary-exploitation/buffer-overflow/#buffer-overflow", 
            "text": "A Buffer Overflow is a vulnerability in which data can be written which exceeds the allocated space, allowing an attacker to overwrite other data.", 
            "title": "Buffer Overflow"
        }, 
        {
            "location": "/binary-exploitation/buffer-overflow/#stack-buffer-overflow", 
            "text": "The simplest and most common buffer overflow is one where the buffer is on  the stack . Let's look at an example.  #include   stdio.h  int   main ()   { \n     int   secret   =   0xdeadbeef ; \n     char   name [ 100 ]   =   { 0 }; \n     read ( 0 ,   name ,   0x100 ); \n     if   ( secret   ==   0x1337 )   { \n         puts ( Wow! Here s a secret. ); \n     }   else   { \n         puts ( I guess you re not cool enough to see my secret ); \n     }  }   There's a tiny mistake in this program which will allow us to see the secret.  name  is decimal 100 bytes, however we're reading in hex 100 bytes (=256 decimal bytes)! Let's see how we can use this to our advantage.  If the compiler chose to layout the stack like this:          0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x0\nESP -   0xffff0000: 0x0         // name  let's look at what happens when we read in 0x100 bytes of 'A's.  The first decimal 100 bytes are saved properly:          0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x41414141\nESP -   0xffff0000: 0x41414141  // name  However when the 101st byte is read in, we see an issue:          0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbe41  // secret\n...\n        0xffff0004: 0x41414141\nESP -   0xffff0000: 0x41414141  // name  The least significant byte of  secret  has been overwritten! If we follow the next 3 bytes to be read in, we'll see the entirety of  secret  is \"clobbered\" with our 'A's          0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0x41414141  // secret\n...\n        0xffff0004: 0x41414141\nESP -   0xffff0000: 0x41414141  // name  The remaining 152 bytes would continue clobbering values up the stack.", 
            "title": "Stack buffer overflow"
        }, 
        {
            "location": "/binary-exploitation/buffer-overflow/#passing-an-impossible-check", 
            "text": "How can we use this to pass the seemingly impossible check in the original program? Well, if we carefully line up our input so that the bytes that overwrite  secret  happen to be the bytes that represent 0x1337 in little-endian, we'll see the secret message.  A small Python one-liner will work nicely:  python -c  print  A *100 +  \\x31\\x13\\x00\\x00  This will fill the  name  buffer with 100 'A's, then overwrite  secret  with the 32-bit little-endian encoding of 0x1337.", 
            "title": "Passing an impossible check"
        }, 
        {
            "location": "/binary-exploitation/buffer-overflow/#going-one-step-further", 
            "text": "As discussed on  the stack  page, the instruction that the current function should jump to when it is done is also saved on the stack (denoted as \"Saved EIP\" in the above stack diagrams). If we can overwrite this, we can control where the program jumps after  main  finishes running, giving us the ability to control what the program does entirely.  Usually, the end objective in binary exploitation is to get a shell (often called \"popping a shell\") on the remote computer. The shell provides us with an easy way to run  anything  we want on the target computer.  Say there happens to be a nice function that does this defined somewhere else in the program that we normally can't get to:  void   give_shell ()   { \n     system ( /bin/sh );  }   Well with our buffer overflow knowledge, now we can! All we have to do is overwrite the saved EIP on the stack to the address where  give_shell  is. Then, when main returns, it will pop that address off of the stack and jump to it, running  give_shell , and giving us our shell.  Assuming  give_shell  is at 0x08048fd0, we could use something like this:  python -c  print  A *108 +  \\xd0\\x8f\\x04\\x08  We send 108 'A's to overwrite the 100 bytes that is allocated for  name , the 4 bytes for  secret , and the 4 bytes for the saved EBP. Then we simply send the little-endian form of  give_shell 's address, and we would get a shell!  This idea is extended on in  Return Oriented Programming", 
            "title": "Going one step further"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/", 
            "text": "Return Oriented Programming\n\n\nReturn Oriented Programming (or ROP) is the idea of chaining together small snippets of assembly with stack control to cause the program to do more complex things.\n\n\nAs we saw in \nbuffer overflows\n, having stack control can be very powerful since it allows us to overwrite saved instruction pointers, giving us control over what the program does next. Most programs don't have a convenient \ngive_shell\n function however, so we need to find a way to manually invoke \nsystem\n or another \nexec\n function to get us our shell.\n\n\n32 bit\n\n\nImagine we have a program similar to the following:\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n\nchar\n \nname\n[\n32\n];\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nprintf\n(\nWhat\ns your name? \n);\n\n    \nread\n(\n0\n,\n \nname\n,\n \n32\n);\n\n\n    \nprintf\n(\nHi %s\n\\n\n,\n \nname\n);\n\n\n    \nprintf\n(\nThe time is currently \n);\n\n    \nsystem\n(\n/bin/date\n);\n\n\n    \nchar\n \necho\n[\n100\n];\n\n    \nprintf\n(\nWhat do you want me to echo back? \n);\n\n    \nread\n(\n0\n,\n \necho\n,\n \n1000\n);\n\n    \nputs\n(\necho\n);\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nWe obviously have a stack buffer overflow on the \necho\n variable which can give us EIP control when \nmain\n returns. But we don't have a \ngive_shell\n function! So what can we do?\n\n\nWe can call \nsystem\n with an argument we control! Since arguments are passed in on the stack in 32-bit Linux programs (see \ncalling conventions\n), if we have stack control, we have argument control.\n\n\nWhen main returns, we want our stack to look like something had normally called \nsystem\n. Recall what is on the stack after a function has been called:\n\n\n        ...                                 // More arguments\n        0xffff0008: 0x00000002              // Argument 2\n        0xffff0004: 0x00000001              // Argument 1\nESP -\n  0xffff0000: 0x080484d0              // Return address\n\n\n\n\n\nSo \nmain\n's stack frame needs to look like this:\n\n\n        0xffff0008: 0xdeadbeef              // system argument 1\n        0xffff0004: 0xdeadbeef              // return address for system\nESP -\n  0xffff0000: 0x08048450              // return address for main (system\ns PLT entry)\n\n\n\n\n\nThen when \nmain\n returns, it will jump into \nsystem\n's \nPLT\n entry and the stack will appear just like \nsystem\n had been called normally for the first time.\n\n\nNote: we don't care about the return address \nsystem\n will return to because we will have already gotten our shell by then!\n\n\nArguments\n\n\nThis is a good start, but we need to pass an argument to \nsystem\n for anything to happen. As mentioned in the page on \nASLR\n, the stack and dynamic libraries \"move around\" each time a program is run, which means we can't easily use data on the stack or a string in libc for our argument. In this case however, we have a very convenient \nname\n global which will be at a known location in the binary (in the BSS segment).\n\n\nPutting it together\n\n\nOur exploit will need to do the following:\n\n\n\n\nEnter \"sh\" or another command to run as \nname\n\n\nFill the stack with\n\n\nGarbage up to the saved EIP\n\n\nThe address of \nsystem\n's PLT entry\n\n\nA fake return address for system to jump to when it's done\n\n\nThe address of the \nname\n global to act as the first argument to \nsystem\n\n\n\n\n\n\n\n\n64 bit\n\n\nIn 64-bit binaries we have to work a bit harder to pass arguments to functions. The basic idea of overwriting the saved RIP is the same, but as discussed in \ncalling conventions\n, arguments are passed in registers in 64-bit programs. In the case of running \nsystem\n, this means we will need to find a way to control the RDI register.\n\n\nTo do this, we'll use small snippets of assembly in the binary, called \"gadgets.\" These gadgets usually \npop\n one or more registers off of the stack, and then call \nret\n, which allows us to chain them together by making a large fake call stack.\n\n\nFor example, if we needed control of both RDI and RSI, we might find two gadgets in our program that look like this (using a tool like \nrp++\n or \nROPgadget\n):\n\n\n0x400c01\n:\n \npop\n \nrdi\n;\n \nret\n\n\n0x400c03\n:\n \npop\n \nrsi\n;\n \npop\n \nr15\n;\n \nret\n\n\n\n\n\n\nWe can setup a fake call stack with these gadets to sequentially execute them, \npop\ning values we control into registers, and then end with a jump to \nsystem\n.\n\n\nExample\n\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget\ns ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget\ns ret will return to - the pop rsi gadget\n        0xffff0008: 0xdeadbeef          // value to be popped into rdi\nRSP -\n  0xffff0000: 0x400c01            // address of rdi gadget\n\n\n\n\n\nStepping through this one instruction at a time, \nmain\n returns, jumping to our \npop rdi\n gadget:\n\n\nRIP = 0x400c01 (pop rdi)\nRDI = UNKNOWN\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget\ns ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget\ns ret will return to - the pop rsi gadget\nRSP -\n  0xffff0008: 0xdeadbeef          // value to be popped into rdi\n\n\n\n\n\npop rdi\n is then executed, popping the top of the stack into RDI:\n\n\nRIP = 0x400c02 (ret)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget\ns ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\nRSP -\n  0xffff0010: 0x400c03            // address that the rdi gadget\ns ret will return to - the pop rsi gadget\n\n\n\n\n\nThe RDI gadget then \nret\ns into our RSI gadget:\n\n\nRIP = 0x400c03 (pop rsi)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget\ns ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\nRSP -\n  0xffff0018: 0x1337beef          // value we want in rsi\n\n\n\n\n\nRSI and R15 are popped:\n\n\nRIP = 0x400c05 (ret)\nRDI = 0xdeadbeef\nRSI = 0x1337beef\n\nRSP -\n  0xffff0028: 0x400d00            // where we want the rsi gadget\ns ret to jump to now that rdi and rsi are controlled\n\n\n\n\n\nAnd finally, the RSI gadget \nret\ns, jumping to whatever function we want, but now with RDI and RSI set to values we control.", 
            "title": "What is ROP"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#return-oriented-programming", 
            "text": "Return Oriented Programming (or ROP) is the idea of chaining together small snippets of assembly with stack control to cause the program to do more complex things.  As we saw in  buffer overflows , having stack control can be very powerful since it allows us to overwrite saved instruction pointers, giving us control over what the program does next. Most programs don't have a convenient  give_shell  function however, so we need to find a way to manually invoke  system  or another  exec  function to get us our shell.", 
            "title": "Return Oriented Programming"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#32-bit", 
            "text": "Imagine we have a program similar to the following:  #include   stdio.h  #include   stdlib.h  char   name [ 32 ];  int   main ()   { \n     printf ( What s your name?  ); \n     read ( 0 ,   name ,   32 ); \n\n     printf ( Hi %s \\n ,   name ); \n\n     printf ( The time is currently  ); \n     system ( /bin/date ); \n\n     char   echo [ 100 ]; \n     printf ( What do you want me to echo back?  ); \n     read ( 0 ,   echo ,   1000 ); \n     puts ( echo ); \n\n     return   0 ;  }   We obviously have a stack buffer overflow on the  echo  variable which can give us EIP control when  main  returns. But we don't have a  give_shell  function! So what can we do?  We can call  system  with an argument we control! Since arguments are passed in on the stack in 32-bit Linux programs (see  calling conventions ), if we have stack control, we have argument control.  When main returns, we want our stack to look like something had normally called  system . Recall what is on the stack after a function has been called:          ...                                 // More arguments\n        0xffff0008: 0x00000002              // Argument 2\n        0xffff0004: 0x00000001              // Argument 1\nESP -   0xffff0000: 0x080484d0              // Return address  So  main 's stack frame needs to look like this:          0xffff0008: 0xdeadbeef              // system argument 1\n        0xffff0004: 0xdeadbeef              // return address for system\nESP -   0xffff0000: 0x08048450              // return address for main (system s PLT entry)  Then when  main  returns, it will jump into  system 's  PLT  entry and the stack will appear just like  system  had been called normally for the first time.  Note: we don't care about the return address  system  will return to because we will have already gotten our shell by then!", 
            "title": "32 bit"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#arguments", 
            "text": "This is a good start, but we need to pass an argument to  system  for anything to happen. As mentioned in the page on  ASLR , the stack and dynamic libraries \"move around\" each time a program is run, which means we can't easily use data on the stack or a string in libc for our argument. In this case however, we have a very convenient  name  global which will be at a known location in the binary (in the BSS segment).", 
            "title": "Arguments"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#putting-it-together", 
            "text": "Our exploit will need to do the following:   Enter \"sh\" or another command to run as  name  Fill the stack with  Garbage up to the saved EIP  The address of  system 's PLT entry  A fake return address for system to jump to when it's done  The address of the  name  global to act as the first argument to  system", 
            "title": "Putting it together"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#64-bit", 
            "text": "In 64-bit binaries we have to work a bit harder to pass arguments to functions. The basic idea of overwriting the saved RIP is the same, but as discussed in  calling conventions , arguments are passed in registers in 64-bit programs. In the case of running  system , this means we will need to find a way to control the RDI register.  To do this, we'll use small snippets of assembly in the binary, called \"gadgets.\" These gadgets usually  pop  one or more registers off of the stack, and then call  ret , which allows us to chain them together by making a large fake call stack.  For example, if we needed control of both RDI and RSI, we might find two gadgets in our program that look like this (using a tool like  rp++  or  ROPgadget ):  0x400c01 :   pop   rdi ;   ret  0x400c03 :   pop   rsi ;   pop   r15 ;   ret   We can setup a fake call stack with these gadets to sequentially execute them,  pop ing values we control into registers, and then end with a jump to  system .", 
            "title": "64 bit"
        }, 
        {
            "location": "/binary-exploitation/return-oriented-programming/#example", 
            "text": "0xffff0028: 0x400d00            // where we want the rsi gadget s ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget s ret will return to - the pop rsi gadget\n        0xffff0008: 0xdeadbeef          // value to be popped into rdi\nRSP -   0xffff0000: 0x400c01            // address of rdi gadget  Stepping through this one instruction at a time,  main  returns, jumping to our  pop rdi  gadget:  RIP = 0x400c01 (pop rdi)\nRDI = UNKNOWN\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget s ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget s ret will return to - the pop rsi gadget\nRSP -   0xffff0008: 0xdeadbeef          // value to be popped into rdi  pop rdi  is then executed, popping the top of the stack into RDI:  RIP = 0x400c02 (ret)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget s ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\nRSP -   0xffff0010: 0x400c03            // address that the rdi gadget s ret will return to - the pop rsi gadget  The RDI gadget then  ret s into our RSI gadget:  RIP = 0x400c03 (pop rsi)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget s ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\nRSP -   0xffff0018: 0x1337beef          // value we want in rsi  RSI and R15 are popped:  RIP = 0x400c05 (ret)\nRDI = 0xdeadbeef\nRSI = 0x1337beef\n\nRSP -   0xffff0028: 0x400d00            // where we want the rsi gadget s ret to jump to now that rdi and rsi are controlled  And finally, the RSI gadget  ret s, jumping to whatever function we want, but now with RDI and RSI set to values we control.", 
            "title": "Example"
        }, 
        {
            "location": "/binary-exploitation/what-is-binary-security/", 
            "text": "Binary Security\n\n\nBinary Security is using tools and methods in order to secure programs from being manipulated and exploited. This tools are not infallible, but when used together and implemented properly, they can raise the difficulty of exploitation greatly.\n\n\nSome methods covered include:\n\n\n\n\nNo eXecute (NX)\n\n\nAddress Space Layout Randomization (ASLR)\n\n\nRelocation Read-Only (RELRO)\n\n\nStack Canaries/Cookies", 
            "title": "What is Binary Security"
        }, 
        {
            "location": "/binary-exploitation/what-is-binary-security/#binary-security", 
            "text": "Binary Security is using tools and methods in order to secure programs from being manipulated and exploited. This tools are not infallible, but when used together and implemented properly, they can raise the difficulty of exploitation greatly.  Some methods covered include:   No eXecute (NX)  Address Space Layout Randomization (ASLR)  Relocation Read-Only (RELRO)  Stack Canaries/Cookies", 
            "title": "Binary Security"
        }, 
        {
            "location": "/binary-exploitation/no-execute/", 
            "text": "No eXecute (NX Bit)\n\n\nThe No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code. This is significant because it prevents attackers from being able to jump to custom shellcode that they've stored on the stack or in a global variable.", 
            "title": "No eXecute (NX)"
        }, 
        {
            "location": "/binary-exploitation/no-execute/#no-execute-nx-bit", 
            "text": "The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code. This is significant because it prevents attackers from being able to jump to custom shellcode that they've stored on the stack or in a global variable.", 
            "title": "No eXecute (NX Bit)"
        }, 
        {
            "location": "/binary-exploitation/address-space-layout-randomization/", 
            "text": "Address Space Layout Randomization (ASLR)\n\n\nAddress Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are. This makes can make it harder for an attacker to exploit a service, as knowledge about where the stack, heap, or libc can't be re-used between program launches. This is a partially effective way of preventing an attacker from jumping to, for example, libc without a leak.\n\n\nTypically, only the stack, heap, and shared libraries are ASLR enabled. It is still somewhat rare for the main program to have ASLR enabled, though it is being seen more frequently and is slowly becoming the default.", 
            "title": "Address Space Layout Randomization (ASLR)"
        }, 
        {
            "location": "/binary-exploitation/address-space-layout-randomization/#address-space-layout-randomization-aslr", 
            "text": "Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are. This makes can make it harder for an attacker to exploit a service, as knowledge about where the stack, heap, or libc can't be re-used between program launches. This is a partially effective way of preventing an attacker from jumping to, for example, libc without a leak.  Typically, only the stack, heap, and shared libraries are ASLR enabled. It is still somewhat rare for the main program to have ASLR enabled, though it is being seen more frequently and is slowly becoming the default.", 
            "title": "Address Space Layout Randomization (ASLR)"
        }, 
        {
            "location": "/binary-exploitation/stack-canaries/", 
            "text": "Stack Canaries\n\n\nStack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immeadiately. \n\n\n\n\nBypassing Stack Canaries\n\n\nStack Canaries seem like a clear cut way to mitigate any stack smashing as it is fairly impossible to just guess a random 64-bit value. However, leaking the address and bruteforcing the canary are two methods which would allow us to get through the canary check.\n\n\nStack Canary Leaking\n\n\nIf we can read the data in the stack canary, we can send it back to the program later because the canary stays the same throughout execution. However Linux makes this slightly tricky by making the first byte of the stack canary a NULL, meaning that string functions will stop when they hit it. A method around this would be to partially overwrite and then put the NULL back or find a way to leak bytes at an arbitrary stack offset.\n\n\nA few situations where you might be able to leak a canary:\n\n\n\n\nUser-controlled format string \n\n\nUser-controlled length of an output\n\n\n\u201cHey, can you send me 1000000 bytes? thx!\u201d\n\n\n\n\n\n\n\n\nBruteforcing a Stack Canary\n\n\nThe canary is determined when the program starts up for the first time which means that if the program forks, it keeps the same stack cookie in the child process. This means that if the input that can overwrite the canary is sent to the child, we can use whether it crashes as an oracle and brute-force 1 byte at a time! \n\n\nThis method can be used on fork-and-accept servers where connections are spun off to child processes, but only under certain conditions such as when the input accepted by the program does not append a NULL byte (\nread\n or \nrecv\n).\n\n\n\n\n\n\n\n\nBuffer (N Bytes)\n\n\n?? ?? ?? ?? ?? ?? ?? ??\n\n\nRBP\n\n\nRIP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFill the buffer N Bytes + 0x00 results in no crash\n\n\n\n\n\n\n\n\nBuffer (N Bytes)\n\n\n00 ?? ?? ?? ?? ?? ?? ??\n\n\nRBP\n\n\nRIP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFill the buffer N Bytes + 0x00 + 0x00 results in a crash\n\n\nN Bytes + 0x00 + 0x01 results in a crash\n\n\nN Bytes + 0x00 + 0x02 results in a crash\n\n\n...\n\n\nN Bytes + 0x00 + 0x51 results in no crash\n\n\n\n\n\n\n\n\nBuffer (N Bytes)\n\n\n00 51 ?? ?? ?? ?? ?? ??\n\n\nRBP\n\n\nRIP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRepeat this bruteforcing process for 6 more bytes...\n\n\n\n\n\n\n\n\nBuffer (N Bytes)\n\n\n00 51 FE 0A 31 D2 7B 3C\n\n\nRBP\n\n\nRIP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have the stack cookie, we can overwrite the RIP register and take control of the program!", 
            "title": "Stack Canaries"
        }, 
        {
            "location": "/binary-exploitation/stack-canaries/#stack-canaries", 
            "text": "Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immeadiately.", 
            "title": "Stack Canaries"
        }, 
        {
            "location": "/binary-exploitation/stack-canaries/#bypassing-stack-canaries", 
            "text": "Stack Canaries seem like a clear cut way to mitigate any stack smashing as it is fairly impossible to just guess a random 64-bit value. However, leaking the address and bruteforcing the canary are two methods which would allow us to get through the canary check.", 
            "title": "Bypassing Stack Canaries"
        }, 
        {
            "location": "/binary-exploitation/stack-canaries/#stack-canary-leaking", 
            "text": "If we can read the data in the stack canary, we can send it back to the program later because the canary stays the same throughout execution. However Linux makes this slightly tricky by making the first byte of the stack canary a NULL, meaning that string functions will stop when they hit it. A method around this would be to partially overwrite and then put the NULL back or find a way to leak bytes at an arbitrary stack offset.  A few situations where you might be able to leak a canary:   User-controlled format string   User-controlled length of an output  \u201cHey, can you send me 1000000 bytes? thx!\u201d", 
            "title": "Stack Canary Leaking"
        }, 
        {
            "location": "/binary-exploitation/stack-canaries/#bruteforcing-a-stack-canary", 
            "text": "The canary is determined when the program starts up for the first time which means that if the program forks, it keeps the same stack cookie in the child process. This means that if the input that can overwrite the canary is sent to the child, we can use whether it crashes as an oracle and brute-force 1 byte at a time!   This method can be used on fork-and-accept servers where connections are spun off to child processes, but only under certain conditions such as when the input accepted by the program does not append a NULL byte ( read  or  recv ).     Buffer (N Bytes)  ?? ?? ?? ?? ?? ?? ?? ??  RBP  RIP             Fill the buffer N Bytes + 0x00 results in no crash     Buffer (N Bytes)  00 ?? ?? ?? ?? ?? ?? ??  RBP  RIP             Fill the buffer N Bytes + 0x00 + 0x00 results in a crash  N Bytes + 0x00 + 0x01 results in a crash  N Bytes + 0x00 + 0x02 results in a crash  ...  N Bytes + 0x00 + 0x51 results in no crash     Buffer (N Bytes)  00 51 ?? ?? ?? ?? ?? ??  RBP  RIP             Repeat this bruteforcing process for 6 more bytes...     Buffer (N Bytes)  00 51 FE 0A 31 D2 7B 3C  RBP  RIP             Now that we have the stack cookie, we can overwrite the RIP register and take control of the program!", 
            "title": "Bruteforcing a Stack Canary"
        }, 
        {
            "location": "/binary-exploitation/relocation-read-only/", 
            "text": "Relocation Read-Only (RELRO)\n\n\nRelocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.\n\n\nThere are two RELRO \"modes\": partial and full.\n\n\nPartial RELRO\n\n\nPartial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.\n\n\nFrom an attackers point-of-view, partial RELRO makes almost no difference, other than it forces the GOT to come before the BSS in memory, eliminating the risk of a \nbuffer overflows\n on a global variable overwriting GOT entries.\n\n\nFull RELRO\n\n\nFull RELRO makes the entire GOT read-only which removes the ability to perform a \"GOT overwrite\" attack, where the GOT address of a function is overwritten with the location of another function or a ROP gadget an attacker wants to run.\n\n\nFull RELRO is not a default compiler setting as it can greatly increase program startup time since all symbols must be resolved before the program is started. In large programs with thousands of symbols that need to be linked, this could cause a noticable delay in startup time.", 
            "title": "Relocation Read-Only (RELRO)"
        }, 
        {
            "location": "/binary-exploitation/relocation-read-only/#relocation-read-only-relro", 
            "text": "Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.  There are two RELRO \"modes\": partial and full.", 
            "title": "Relocation Read-Only (RELRO)"
        }, 
        {
            "location": "/binary-exploitation/relocation-read-only/#partial-relro", 
            "text": "Partial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.  From an attackers point-of-view, partial RELRO makes almost no difference, other than it forces the GOT to come before the BSS in memory, eliminating the risk of a  buffer overflows  on a global variable overwriting GOT entries.", 
            "title": "Partial RELRO"
        }, 
        {
            "location": "/binary-exploitation/relocation-read-only/#full-relro", 
            "text": "Full RELRO makes the entire GOT read-only which removes the ability to perform a \"GOT overwrite\" attack, where the GOT address of a function is overwritten with the location of another function or a ROP gadget an attacker wants to run.  Full RELRO is not a default compiler setting as it can greatly increase program startup time since all symbols must be resolved before the program is started. In large programs with thousands of symbols that need to be linked, this could cause a noticable delay in startup time.", 
            "title": "Full RELRO"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-heap/", 
            "text": "The Heap\n\n\nThe \nheap\n is a place in memory which a program can use to dynamically create objects. Creating objects on the heap has some advantages compared to using the stack:\n\n\n\n\nHeap allocations can be dynamically sized\n\n\nHeap allocations \"persist\" when a function returns\n\n\n\n\nThere are also some disadvantages however:\n\n\n\n\nHeap allocations can be slower\n\n\nHeap allocations must be manually cleaned up\n\n\n\n\nUsing the heap\n\n\nIn C, there are a number of functions used to interact with the heap, but we're going to focus on the two core ones:\n\n\n\n\nmalloc\n: allocate \nn\n bytes on the heap\n\n\nfree\n: free the given allocation\n\n\n\n\nLet's see how these could be used in a program:\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n#include\n \nunistd.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nunsigned\n \nalloc_size\n \n=\n \n0\n;\n\n    \nchar\n \n*\nstuff\n;\n\n\n    \nprintf\n(\nNumber of bytes? \n);\n\n    \nscanf\n(\n%u\n,\n \nalloc_size\n);\n\n\n    \nstuff\n \n=\n \nmalloc\n(\nalloc_size\n \n+\n \n1\n);\n\n    \nmemset\n(\n0\n,\n \nstuff\n,\n \nalloc_size\n \n+\n \n1\n);\n\n\n    \nread\n(\n0\n,\n \nstuff\n,\n \nalloc_size\n);\n\n\n    \nprintf\n(\nYou wrote: %s\n,\n \nstuff\n);\n\n\n    \nfree\n(\nstuff\n);\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nThis program reads in a size from the user, creates an allocation of that size on the heap, reads in that many bytes, then prints it back out to the user.", 
            "title": "What is the Heap"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-heap/#the-heap", 
            "text": "The  heap  is a place in memory which a program can use to dynamically create objects. Creating objects on the heap has some advantages compared to using the stack:   Heap allocations can be dynamically sized  Heap allocations \"persist\" when a function returns   There are also some disadvantages however:   Heap allocations can be slower  Heap allocations must be manually cleaned up", 
            "title": "The Heap"
        }, 
        {
            "location": "/binary-exploitation/what-is-the-heap/#using-the-heap", 
            "text": "In C, there are a number of functions used to interact with the heap, but we're going to focus on the two core ones:   malloc : allocate  n  bytes on the heap  free : free the given allocation   Let's see how these could be used in a program:  #include   stdio.h  #include   stdlib.h  #include   unistd.h  int   main ()   { \n     unsigned   alloc_size   =   0 ; \n     char   * stuff ; \n\n     printf ( Number of bytes?  ); \n     scanf ( %u ,   alloc_size ); \n\n     stuff   =   malloc ( alloc_size   +   1 ); \n     memset ( 0 ,   stuff ,   alloc_size   +   1 ); \n\n     read ( 0 ,   stuff ,   alloc_size ); \n\n     printf ( You wrote: %s ,   stuff ); \n\n     free ( stuff ); \n\n     return   0 ;  }   This program reads in a size from the user, creates an allocation of that size on the heap, reads in that many bytes, then prints it back out to the user.", 
            "title": "Using the heap"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/", 
            "text": "Heap Exploits\n\n\nOverflow\n\n\nMuch like a \nstack buffer overflow\n, a \nheap overflow\n is a vulnerability where more data than can fit in the allocated buffer is read in. This could lead to heap metadata corruption, or corruption of other heap objects, which could in turn provide new attack surface.\n\n\nUse After Free (UAF)\n\n\nOnce \nfree\n is called on an allocation, the allocator is free to re-allocate that chunk of memory in future calls to \nmalloc\n if it so chooses. However if the program author isn't careful and uses the freed object later on, the contents may be corrupt (or even attacker controlled). This is called a use after free or UAF.\n\n\nExample\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n#include\n \nunistd.h\n\n\n#include\n \nstring.h\n\n\n\ntypedef\n \nstruct\n \nstring\n \n{\n\n    \nunsigned\n \nlength\n;\n\n    \nchar\n \n*\ndata\n;\n\n\n}\n \nstring\n;\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nstruct\n \nstring\n*\n \ns\n \n=\n \nmalloc\n(\nsizeof\n(\nstring\n));\n\n    \nputs\n(\nLength:\n);\n\n    \nscanf\n(\n%u\n,\n \ns\n-\nlength\n);\n\n    \ns\n-\ndata\n \n=\n \nmalloc\n(\ns\n-\nlength\n \n+\n \n1\n);\n\n    \nmemset\n(\ns\n-\ndata\n,\n \n0\n,\n \ns\n-\nlength\n \n+\n \n1\n);\n\n    \nputs\n(\nData:\n);\n\n    \nread\n(\n0\n,\n \ns\n-\ndata\n,\n \ns\n-\nlength\n);\n\n\n    \nfree\n(\ns\n-\ndata\n);\n\n    \nfree\n(\ns\n);\n\n\n    \nchar\n \n*\ns2\n \n=\n \nmalloc\n(\n16\n);\n\n    \nmemset\n(\ns2\n,\n \n0\n,\n \n16\n);\n\n    \nputs\n(\nMore data:\n);\n\n    \nread\n(\n0\n,\n \ns2\n,\n \n15\n);\n\n\n    \n// Now using s again, a UAF\n\n\n    \nputs\n(\ns\n-\ndata\n);\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nIn this example, we have a \nstring\n structure with a length and a pointer to the actual string data. We properly allocate, fill, and then free an instance of this structure. Then we make another allocation, fill it, and then improperly reference the freed \nstring\n. Due to how glibc's allocator works, \ns2\n will actually get the same memory as the original \ns\n allocation, which in turn gives us the ability to control the \ns-\ndata\n pointer. This could be used to leak program data.\n\n\nAdvanced Heap Exploitation\n\n\nNot only can the heap be exploited by the data in allocations, but exploits can also use the underlying mechanisms in \nmalloc\n, \nfree\n, etc. to exploit a program. This is beyond the scope of CTF 101, but here are a few recommended resources:\n\n\n\n\nsploitFUN's glibc overview\n\n\nShellphish's how2heap", 
            "title": "Heap Exploitation"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/#heap-exploits", 
            "text": "", 
            "title": "Heap Exploits"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/#overflow", 
            "text": "Much like a  stack buffer overflow , a  heap overflow  is a vulnerability where more data than can fit in the allocated buffer is read in. This could lead to heap metadata corruption, or corruption of other heap objects, which could in turn provide new attack surface.", 
            "title": "Overflow"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/#use-after-free-uaf", 
            "text": "Once  free  is called on an allocation, the allocator is free to re-allocate that chunk of memory in future calls to  malloc  if it so chooses. However if the program author isn't careful and uses the freed object later on, the contents may be corrupt (or even attacker controlled). This is called a use after free or UAF.", 
            "title": "Use After Free (UAF)"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/#example", 
            "text": "#include   stdio.h  #include   stdlib.h  #include   unistd.h  #include   string.h  typedef   struct   string   { \n     unsigned   length ; \n     char   * data ;  }   string ;  int   main ()   { \n     struct   string *   s   =   malloc ( sizeof ( string )); \n     puts ( Length: ); \n     scanf ( %u ,   s - length ); \n     s - data   =   malloc ( s - length   +   1 ); \n     memset ( s - data ,   0 ,   s - length   +   1 ); \n     puts ( Data: ); \n     read ( 0 ,   s - data ,   s - length ); \n\n     free ( s - data ); \n     free ( s ); \n\n     char   * s2   =   malloc ( 16 ); \n     memset ( s2 ,   0 ,   16 ); \n     puts ( More data: ); \n     read ( 0 ,   s2 ,   15 ); \n\n     // Now using s again, a UAF \n\n     puts ( s - data ); \n\n     return   0 ;  }   In this example, we have a  string  structure with a length and a pointer to the actual string data. We properly allocate, fill, and then free an instance of this structure. Then we make another allocation, fill it, and then improperly reference the freed  string . Due to how glibc's allocator works,  s2  will actually get the same memory as the original  s  allocation, which in turn gives us the ability to control the  s- data  pointer. This could be used to leak program data.", 
            "title": "Example"
        }, 
        {
            "location": "/binary-exploitation/heap-exploitation/#advanced-heap-exploitation", 
            "text": "Not only can the heap be exploited by the data in allocations, but exploits can also use the underlying mechanisms in  malloc ,  free , etc. to exploit a program. This is beyond the scope of CTF 101, but here are a few recommended resources:   sploitFUN's glibc overview  Shellphish's how2heap", 
            "title": "Advanced Heap Exploitation"
        }, 
        {
            "location": "/binary-exploitation/what-is-a-format-string-vulnerability/", 
            "text": "Format String Vulnerability\n\n\nA format string vulnerability is a bug where user input is passed as the format argument to \nprintf\n, \nscanf\n, or another function in that family.\n\n\nThe format argument has many different specifies which could allow an attacker to leak data if they control the format argument to \nprintf\n. Since \nprintf\n and similar are \nvariadic\n functions, they will continue popping data off of the stack according to the format.\n\n\nFor example, if we can make the format argument \"%x.%x.%x.%x\", \nprintf\n will pop off four stack values and print them in hexadecimal, potentially leaking sensitive information.\n\n\nprintf\n can also index to an arbitrary \"argument\" with the following syntax: \"%n$x\" (where \nn\n is the decimal index of the argument you want).\n\n\nWhile these bugs are powerful, they're very rare nowadays, as all modern compilers warn when \nprintf\n is called with a non-constant string.\n\n\nExample\n\n\n#include\n \nstdio.h\n\n\n#include\n \nunistd.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nint\n \nsecret_num\n \n=\n \n0x8badf00d\n;\n\n\n    \nchar\n \nname\n[\n64\n]\n \n=\n \n{\n0\n};\n\n    \nread\n(\n0\n,\n \nname\n,\n \n64\n);\n\n    \nprintf\n(\nHello \n);\n\n    \nprintf\n(\nname\n);\n\n    \nprintf\n(\n! You\nll never get my secret!\n\\n\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nDue to how GCC decided to lay out the stack, \nsecret_num\n is actually at a lower address on the stack than \nname\n, so we only have to go to the 7th \"argument\" in \nprintf\n to leak the secret:\n\n\n$ ./fmt_string\n%7\n$llx\n\nHello 8badf00d3ea43eef\n! You\nll never get my secret!", 
            "title": "What is a Format String Vulnerability"
        }, 
        {
            "location": "/binary-exploitation/what-is-a-format-string-vulnerability/#format-string-vulnerability", 
            "text": "A format string vulnerability is a bug where user input is passed as the format argument to  printf ,  scanf , or another function in that family.  The format argument has many different specifies which could allow an attacker to leak data if they control the format argument to  printf . Since  printf  and similar are  variadic  functions, they will continue popping data off of the stack according to the format.  For example, if we can make the format argument \"%x.%x.%x.%x\",  printf  will pop off four stack values and print them in hexadecimal, potentially leaking sensitive information.  printf  can also index to an arbitrary \"argument\" with the following syntax: \"%n$x\" (where  n  is the decimal index of the argument you want).  While these bugs are powerful, they're very rare nowadays, as all modern compilers warn when  printf  is called with a non-constant string.", 
            "title": "Format String Vulnerability"
        }, 
        {
            "location": "/binary-exploitation/what-is-a-format-string-vulnerability/#example", 
            "text": "#include   stdio.h  #include   unistd.h  int   main ()   { \n     int   secret_num   =   0x8badf00d ; \n\n     char   name [ 64 ]   =   { 0 }; \n     read ( 0 ,   name ,   64 ); \n     printf ( Hello  ); \n     printf ( name ); \n     printf ( ! You ll never get my secret! \\n ); \n     return   0 ;  }   Due to how GCC decided to lay out the stack,  secret_num  is actually at a lower address on the stack than  name , so we only have to go to the 7th \"argument\" in  printf  to leak the secret:  $ ./fmt_string\n%7 $llx \nHello 8badf00d3ea43eef\n! You ll never get my secret!", 
            "title": "Example"
        }
    ]
}