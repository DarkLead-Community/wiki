{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Capture The Flag 101", "text": ""}, {"location": "#overview", "title": "Overview", "text": "<p>Capture the Flags, or CTFs, are computer security competitions. </p> <p>Teams of competitors (or just individuals) are pitted against each other in various challenges across multiple security disciplines, competing to earn the most points.</p> <p>CTFs are often the beginning of one's cyber security career due to their team building nature and competitive aspect. In addition, there isn't a lot of commitment required beyond a weekend. </p> <p>Info</p> <p>For information about ongoing CTFs, check out CTFTime.</p> <p>In this handbook you'll learn the basics\u2122 behind the methodologies and techniques needed to succeed in Capture the Flag competitions.</p>"}, {"location": "binary-exploitation/address-space-layout-randomization/", "title": "Address Space Layout Randomization (ASLR)", "text": "<p>Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are. This makes can make it harder for an attacker to exploit a service, as knowledge about where the stack, heap, or libc can't be re-used between program launches. This is a partially effective way of preventing an attacker from jumping to, for example, libc without a leak.</p> <p>Typically, only the stack, heap, and shared libraries are ASLR enabled. It is still somewhat rare for the main program to have ASLR enabled, though it is being seen more frequently and is slowly becoming the default.</p>"}, {"location": "binary-exploitation/buffer-overflow/", "title": "Buffer Overflow", "text": "<p>A Buffer Overflow is a vulnerability in which data can be written which exceeds the allocated space, allowing an attacker to overwrite other data.</p>"}, {"location": "binary-exploitation/buffer-overflow/#stack-buffer-overflow", "title": "Stack buffer overflow", "text": "<p>The simplest and most common buffer overflow is one where the buffer is on the stack. Let's look at an example.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int secret = 0xdeadbeef;\n    char name[100] = {0};\n    read(0, name, 0x100);\n    if (secret == 0x1337) {\n        puts(\"Wow! Here's a secret.\");\n    } else {\n        puts(\"I guess you're not cool enough to see my secret\");\n    }\n}\n</code></pre> <p>There's a tiny mistake in this program which will allow us to see the secret. <code>name</code> is decimal 100 bytes, however we're reading in hex 100 bytes (=256 decimal bytes)! Let's see how we can use this to our advantage.</p> <p>If the compiler chose to layout the stack like this:</p> <pre><code>        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x0\nESP -&gt;  0xffff0000: 0x0         // name\n</code></pre> <p>let's look at what happens when we read in 0x100 bytes of 'A's.</p> <p>The first decimal 100 bytes are saved properly:</p> <pre><code>        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbeef  // secret\n...\n        0xffff0004: 0x41414141\nESP -&gt;  0xffff0000: 0x41414141  // name\n</code></pre> <p>However when the 101st byte is read in, we see an issue:</p> <pre><code>        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0xdeadbe41  // secret\n...\n        0xffff0004: 0x41414141\nESP -&gt;  0xffff0000: 0x41414141  // name\n</code></pre> <p>The least significant byte of <code>secret</code> has been overwritten! If we follow the next 3 bytes to be read in, we'll see the entirety of <code>secret</code> is \"clobbered\" with our 'A's</p> <pre><code>        0xffff006c: 0xf7f7f7f7  // Saved EIP\n        0xffff0068: 0xffff0100  // Saved EBP\n        0xffff0064: 0x41414141  // secret\n...\n        0xffff0004: 0x41414141\nESP -&gt;  0xffff0000: 0x41414141  // name\n</code></pre> <p>The remaining 152 bytes would continue clobbering values up the stack.</p>"}, {"location": "binary-exploitation/buffer-overflow/#passing-an-impossible-check", "title": "Passing an impossible check", "text": "<p>How can we use this to pass the seemingly impossible check in the original program? Well, if we carefully line up our input so that the bytes that overwrite <code>secret</code> happen to be the bytes that represent 0x1337 in little-endian, we'll see the secret message.</p> <p>A small Python one-liner will work nicely: <code>python -c \"print 'A'*100 + '\\x31\\x13\\x00\\x00'\"</code></p> <p>This will fill the <code>name</code> buffer with 100 'A's, then overwrite <code>secret</code> with the 32-bit little-endian encoding of 0x1337.</p>"}, {"location": "binary-exploitation/buffer-overflow/#going-one-step-further", "title": "Going one step further", "text": "<p>As discussed on the stack page, the instruction that the current function should jump to when it is done is also saved on the stack (denoted as \"Saved EIP\" in the above stack diagrams). If we can overwrite this, we can control where the program jumps after <code>main</code> finishes running, giving us the ability to control what the program does entirely.</p> <p>Usually, the end objective in binary exploitation is to get a shell (often called \"popping a shell\") on the remote computer. The shell provides us with an easy way to run anything we want on the target computer.</p> <p>Say there happens to be a nice function that does this defined somewhere else in the program that we normally can't get to:</p> <pre><code>void give_shell() {\n    system(\"/bin/sh\");\n}\n</code></pre> <p>Well with our buffer overflow knowledge, now we can! All we have to do is overwrite the saved EIP on the stack to the address where <code>give_shell</code> is. Then, when main returns, it will pop that address off of the stack and jump to it, running <code>give_shell</code>, and giving us our shell.</p> <p>Assuming <code>give_shell</code> is at 0x08048fd0, we could use something like this: <code>python -c \"print 'A'*108 + '\\xd0\\x8f\\x04\\x08'\"</code></p> <p>We send 108 'A's to overwrite the 100 bytes that is allocated for <code>name</code>, the 4 bytes for <code>secret</code>, and the 4 bytes for the saved EBP. Then we simply send the little-endian form of <code>give_shell</code>'s address, and we would get a shell!</p> <p>This idea is extended on in Return Oriented Programming</p>"}, {"location": "binary-exploitation/heap-exploitation/", "title": "Heap Exploits", "text": ""}, {"location": "binary-exploitation/heap-exploitation/#overflow", "title": "Overflow", "text": "<p>Much like a stack buffer overflow, a heap overflow is a vulnerability where more data than can fit in the allocated buffer is read in. This could lead to heap metadata corruption, or corruption of other heap objects, which could in turn provide new attack surface.</p>"}, {"location": "binary-exploitation/heap-exploitation/#use-after-free-uaf", "title": "Use After Free (UAF)", "text": "<p>Once <code>free</code> is called on an allocation, the allocator is free to re-allocate that chunk of memory in future calls to <code>malloc</code> if it so chooses. However if the program author isn't careful and uses the freed object later on, the contents may be corrupt (or even attacker controlled). This is called a use after free or UAF.</p>"}, {"location": "binary-exploitation/heap-exploitation/#example", "title": "Example", "text": "<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct string {\n    unsigned length;\n    char *data;\n} string;\n\nint main() {\n    struct string* s = malloc(sizeof(string));\n    puts(\"Length:\");\n    scanf(\"%u\", &amp;s-&gt;length);\n    s-&gt;data = malloc(s-&gt;length + 1);\n    memset(s-&gt;data, 0, s-&gt;length + 1);\n    puts(\"Data:\");\n    read(0, s-&gt;data, s-&gt;length);\n\n    free(s-&gt;data);\n    free(s);\n\n    char *s2 = malloc(16);\n    memset(s2, 0, 16);\n    puts(\"More data:\");\n    read(0, s2, 15);\n\n    // Now using s again, a UAF\n\n    puts(s-&gt;data);\n\n    return 0;\n}\n</code></pre> <p>In this example, we have a <code>string</code> structure with a length and a pointer to the actual string data. We properly allocate, fill, and then free an instance of this structure. Then we make another allocation, fill it, and then improperly reference the freed <code>string</code>. Due to how glibc's allocator works, <code>s2</code> will actually get the same memory as the original <code>s</code> allocation, which in turn gives us the ability to control the <code>s-&gt;data</code> pointer. This could be used to leak program data.</p>"}, {"location": "binary-exploitation/heap-exploitation/#advanced-heap-exploitation", "title": "Advanced Heap Exploitation", "text": "<p>Not only can the heap be exploited by the data in allocations, but exploits can also use the underlying mechanisms in <code>malloc</code>, <code>free</code>, etc. to exploit a program. This is beyond the scope of CTF 101, but here are a few recommended resources:</p> <ul> <li>sploitFUN's glibc overview</li> <li>Shellphish's how2heap</li> </ul>"}, {"location": "binary-exploitation/no-execute/", "title": "No eXecute (NX Bit)", "text": "<p>The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code. This is significant because it prevents attackers from being able to jump to custom shellcode that they've stored on the stack or in a global variable.</p>"}, {"location": "binary-exploitation/overview/", "title": "Overview", "text": ""}, {"location": "binary-exploitation/overview/#binary-exploitation", "title": "Binary Exploitation", "text": "<p>Binaries, or executables, are machine code for a computer to execute. For the most part, the binaries that you will face in CTFs are Linux ELF files or the occasional windows executable. Binary Exploitation is a broad topic within Cyber Security which really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program's functions.</p> <p>Common topics addressed by Binary Exploitation or 'pwn' challenges include:</p> <ul> <li>Registers</li> <li>The Stack</li> <li>Calling Conventions</li> <li>Global Offset Table (GOT)</li> <li>Buffers<ul> <li>Buffer Overflow</li> </ul> </li> <li>Return Oriented Programming (ROP)</li> <li>Binary Security<ul> <li>No eXecute (NX)</li> <li>Address Space Layout Randomization (ASLR)</li> <li>Stack Canaries</li> <li>Relocation Read-Only (RELRO)</li> </ul> </li> <li>The Heap<ul> <li>Heap Exploitation</li> </ul> </li> <li>Format String Vulnerability</li> </ul>"}, {"location": "binary-exploitation/relocation-read-only/", "title": "Relocation Read-Only (RELRO)", "text": "<p>Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.</p> <p>There are two RELRO \"modes\": partial and full.</p>"}, {"location": "binary-exploitation/relocation-read-only/#partial-relro", "title": "Partial RELRO", "text": "<p>Partial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.</p> <p>From an attackers point-of-view, partial RELRO makes almost no difference, other than it forces the GOT to come before the BSS in memory, eliminating the risk of a buffer overflows on a global variable overwriting GOT entries.</p>"}, {"location": "binary-exploitation/relocation-read-only/#full-relro", "title": "Full RELRO", "text": "<p>Full RELRO makes the entire GOT read-only which removes the ability to perform a \"GOT overwrite\" attack, where the GOT address of a function is overwritten with the location of another function or a ROP gadget an attacker wants to run.</p> <p>Full RELRO is not a default compiler setting as it can greatly increase program startup time since all symbols must be resolved before the program is started. In large programs with thousands of symbols that need to be linked, this could cause a noticable delay in startup time.</p>"}, {"location": "binary-exploitation/return-oriented-programming/", "title": "Return Oriented Programming", "text": "<p>Return Oriented Programming (or ROP) is the idea of chaining together small snippets of assembly with stack control to cause the program to do more complex things.</p> <p>As we saw in buffer overflows, having stack control can be very powerful since it allows us to overwrite saved instruction pointers, giving us control over what the program does next. Most programs don't have a convenient <code>give_shell</code> function however, so we need to find a way to manually invoke <code>system</code> or another <code>exec</code> function to get us our shell.</p>"}, {"location": "binary-exploitation/return-oriented-programming/#32-bit", "title": "32 bit", "text": "<p>Imagine we have a program similar to the following:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nchar name[32];\n\nint main() {\n    printf(\"What's your name? \");\n    read(0, name, 32);\n\n    printf(\"Hi %s\\n\", name);\n\n    printf(\"The time is currently \");\n    system(\"/bin/date\");\n\n    char echo[100];\n    printf(\"What do you want me to echo back? \");\n    read(0, echo, 1000);\n    puts(echo);\n\n    return 0;\n}\n</code></pre> <p>We obviously have a stack buffer overflow on the <code>echo</code> variable which can give us EIP control when <code>main</code> returns. But we don't have a <code>give_shell</code> function! So what can we do?</p> <p>We can call <code>system</code> with an argument we control! Since arguments are passed in on the stack in 32-bit Linux programs (see calling conventions), if we have stack control, we have argument control.</p> <p>When main returns, we want our stack to look like something had normally called <code>system</code>. Recall what is on the stack after a function has been called:</p> <pre><code>        ...                                 // More arguments\n        0xffff0008: 0x00000002              // Argument 2\n        0xffff0004: 0x00000001              // Argument 1\nESP -&gt;  0xffff0000: 0x080484d0              // Return address\n</code></pre> <p>So <code>main</code>'s stack frame needs to look like this:</p> <pre><code>        0xffff0008: 0xdeadbeef              // system argument 1\n        0xffff0004: 0xdeadbeef              // return address for system\nESP -&gt;  0xffff0000: 0x08048450              // return address for main (system's PLT entry)\n</code></pre> <p>Then when <code>main</code> returns, it will jump into <code>system</code>'s PLT entry and the stack will appear just like <code>system</code> had been called normally for the first time.</p> <p>Note: we don't care about the return address <code>system</code> will return to because we will have already gotten our shell by then!</p>"}, {"location": "binary-exploitation/return-oriented-programming/#arguments", "title": "Arguments", "text": "<p>This is a good start, but we need to pass an argument to <code>system</code> for anything to happen. As mentioned in the page on ASLR, the stack and dynamic libraries \"move around\" each time a program is run, which means we can't easily use data on the stack or a string in libc for our argument. In this case however, we have a very convenient <code>name</code> global which will be at a known location in the binary (in the BSS segment).</p>"}, {"location": "binary-exploitation/return-oriented-programming/#putting-it-together", "title": "Putting it together", "text": "<p>Our exploit will need to do the following:</p> <ol> <li>Enter \"sh\" or another command to run as <code>name</code></li> <li>Fill the stack with<ol> <li>Garbage up to the saved EIP</li> <li>The address of <code>system</code>'s PLT entry</li> <li>A fake return address for system to jump to when it's done</li> <li>The address of the <code>name</code> global to act as the first argument to <code>system</code></li> </ol> </li> </ol>"}, {"location": "binary-exploitation/return-oriented-programming/#64-bit", "title": "64 bit", "text": "<p>In 64-bit binaries we have to work a bit harder to pass arguments to functions. The basic idea of overwriting the saved RIP is the same, but as discussed in calling conventions, arguments are passed in registers in 64-bit programs. In the case of running <code>system</code>, this means we will need to find a way to control the RDI register.</p> <p>To do this, we'll use small snippets of assembly in the binary, called \"gadgets.\" These gadgets usually <code>pop</code> one or more registers off of the stack, and then call <code>ret</code>, which allows us to chain them together by making a large fake call stack.</p> <p>For example, if we needed control of both RDI and RSI, we might find two gadgets in our program that look like this (using a tool like rp++ or ROPgadget):</p> <pre><code>0x400c01: pop rdi; ret\n0x400c03: pop rsi; pop r15; ret\n</code></pre> <p>We can setup a fake call stack with these gadets to sequentially execute them, <code>pop</code>ing values we control into registers, and then end with a jump to <code>system</code>.</p>"}, {"location": "binary-exploitation/return-oriented-programming/#example", "title": "Example", "text": "<pre><code>        0xffff0028: 0x400d00            // where we want the rsi gadget's ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget's ret will return to - the pop rsi gadget\n        0xffff0008: 0xdeadbeef          // value to be popped into rdi\nRSP -&gt;  0xffff0000: 0x400c01            // address of rdi gadget\n</code></pre> <p>Stepping through this one instruction at a time, <code>main</code> returns, jumping to our <code>pop rdi</code> gadget:</p> <pre><code>RIP = 0x400c01 (pop rdi)\nRDI = UNKNOWN\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget's ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\n        0xffff0010: 0x400c03            // address that the rdi gadget's ret will return to - the pop rsi gadget\nRSP -&gt;  0xffff0008: 0xdeadbeef          // value to be popped into rdi\n</code></pre> <p><code>pop rdi</code> is then executed, popping the top of the stack into RDI:</p> <pre><code>RIP = 0x400c02 (ret)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget's ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\n        0xffff0018: 0x1337beef          // value we want in rsi\nRSP -&gt;  0xffff0010: 0x400c03            // address that the rdi gadget's ret will return to - the pop rsi gadget\n</code></pre> <p>The RDI gadget then <code>ret</code>s into our RSI gadget:</p> <pre><code>RIP = 0x400c03 (pop rsi)\nRDI = 0xdeadbeef\nRSI = UNKNOWN\n\n        0xffff0028: 0x400d00            // where we want the rsi gadget's ret to jump to now that rdi and rsi are controlled\n        0xffff0020: 0x1337beef          // value we want in r15 (probably garbage)\nRSP -&gt;  0xffff0018: 0x1337beef          // value we want in rsi\n</code></pre> <p>RSI and R15 are popped:</p> <pre><code>RIP = 0x400c05 (ret)\nRDI = 0xdeadbeef\nRSI = 0x1337beef\n\nRSP -&gt;  0xffff0028: 0x400d00            // where we want the rsi gadget's ret to jump to now that rdi and rsi are controlled\n</code></pre> <p>And finally, the RSI gadget <code>ret</code>s, jumping to whatever function we want, but now with RDI and RSI set to values we control.</p>"}, {"location": "binary-exploitation/stack-canaries/", "title": "Stack Canaries", "text": "<p>Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immeadiately. </p> <p></p>"}, {"location": "binary-exploitation/stack-canaries/#bypassing-stack-canaries", "title": "Bypassing Stack Canaries", "text": "<p>Stack Canaries seem like a clear cut way to mitigate any stack smashing as it is fairly impossible to just guess a random 64-bit value. However, leaking the address and bruteforcing the canary are two methods which would allow us to get through the canary check.</p>"}, {"location": "binary-exploitation/stack-canaries/#stack-canary-leaking", "title": "Stack Canary Leaking", "text": "<p>If we can read the data in the stack canary, we can send it back to the program later because the canary stays the same throughout execution. However Linux makes this slightly tricky by making the first byte of the stack canary a NULL, meaning that string functions will stop when they hit it. A method around this would be to partially overwrite and then put the NULL back or find a way to leak bytes at an arbitrary stack offset.</p> <p>A few situations where you might be able to leak a canary:</p> <ul> <li>User-controlled format string </li> <li>User-controlled length of an output<ul> <li>\u201cHey, can you send me 1000000 bytes? thx!\u201d</li> </ul> </li> </ul>"}, {"location": "binary-exploitation/stack-canaries/#bruteforcing-a-stack-canary", "title": "Bruteforcing a Stack Canary", "text": "<p>The canary is determined when the program starts up for the first time which means that if the program forks, it keeps the same stack cookie in the child process. This means that if the input that can overwrite the canary is sent to the child, we can use whether it crashes as an oracle and brute-force 1 byte at a time! </p> <p>This method can be used on fork-and-accept servers where connections are spun off to child processes, but only under certain conditions such as when the input accepted by the program does not append a NULL byte (read or recv).</p> Buffer (N Bytes) ?? ?? ?? ?? ?? ?? ?? ?? RBP RIP <p>Fill the buffer N Bytes + 0x00 results in no crash</p> Buffer (N Bytes) 00 ?? ?? ?? ?? ?? ?? ?? RBP RIP <p>Fill the buffer N Bytes + 0x00 + 0x00 results in a crash</p> <p>N Bytes + 0x00 + 0x01 results in a crash</p> <p>N Bytes + 0x00 + 0x02 results in a crash</p> <p>...</p> <p>N Bytes + 0x00 + 0x51 results in no crash</p> Buffer (N Bytes) 00 51 ?? ?? ?? ?? ?? ?? RBP RIP <p>Repeat this bruteforcing process for 6 more bytes...</p> Buffer (N Bytes) 00 51 FE 0A 31 D2 7B 3C RBP RIP <p>Now that we have the stack cookie, we can overwrite the RIP register and take control of the program!</p>"}, {"location": "binary-exploitation/what-are-buffers/", "title": "Buffers", "text": "<p>A buffer is any allocated space in memory where data (often user input) can be stored. For example, in the following C program <code>name</code> would be considered a stack buffer:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char name[64] = {0};\n    read(0, name, 63);\n    printf(\"Hello %s\", name);\n    return 0;\n}\n</code></pre> <p>Buffers could also be global variables:</p> <pre><code>#include &lt;stdio.h&gt;\n\nchar name[64] = {0};\n\nint main() {\n    read(0, name, 63);\n    printf(\"Hello %s\", name);\n    return 0;\n}\n</code></pre> <p>Or dynamically allocated on the heap:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    char *name = malloc(64);\n    memset(name, 0, 64);\n    read(0, name, 63);\n    printf(\"Hello %s\", name);\n    return 0;\n}\n</code></pre>"}, {"location": "binary-exploitation/what-are-buffers/#exploits", "title": "Exploits", "text": "<p>Given that buffers commonly hold user input, mistakes when writing to them could result in attacker controlled data being written outside of the buffer's space. See the page on buffer overflows for more.</p>"}, {"location": "binary-exploitation/what-are-calling-conventions/", "title": "Calling Conventions", "text": "<p>To be able to call functions, there needs to be an agreed-upon way to pass arguments. If a program is entirely self-contained in a binary, the compiler would be free to decide the calling convention. However in reality, shared libraries are used so that common code (e.g. libc) can be stored once and dynamically linked in to programs that need it, reducing program size.</p> <p>In Linux binaries, there are really only two commonly used calling conventions: cdecl for 32-bit binaries, and SysV for 64-bit</p>"}, {"location": "binary-exploitation/what-are-calling-conventions/#cdecl", "title": "cdecl", "text": "<p>In 32-bit binaries on Linux, function arguments are passed in on the stack in reverse order. A function like this:</p> <pre><code>int add(int a, int b, int c) {\n    return a + b + c;\n}\n</code></pre> <p>would be invoked by pushing <code>c</code>, then <code>b</code>, then <code>a</code>.</p>"}, {"location": "binary-exploitation/what-are-calling-conventions/#sysv", "title": "SysV", "text": "<p>For 64-bit binaries, function arguments are first passed in certain registers:</p> <ol> <li>RDI</li> <li>RSI</li> <li>RDX</li> <li>RCX</li> <li>R8</li> <li>R9</li> </ol> <p>then any leftover arguments are pushed onto the stack in reverse order, as in cdecl.</p>"}, {"location": "binary-exploitation/what-are-calling-conventions/#other-conventions", "title": "Other Conventions", "text": "<p>Any method of passing arguments could be used as long as the compiler is aware of what the convention is. As a result, there have been many calling conventions in the past that aren't used frequently anymore. See Wikipedia for a comprehensive list.</p>"}, {"location": "binary-exploitation/what-are-registers/", "title": "Registers", "text": "<p>A register is a location within the processor that is able to store data, much like RAM. Unlike RAM however, accesses to registers are effectively instantaneous, whereas reads from main memory can take hundreds of CPU cycles to return.</p> <p>Registers can hold any value: addresses (pointers), results from mathematical operations, characters, etc. Some registers are reserved however, meaning they have a special purpose and are not \"general purpose registers\" (GPRs). On x86, the only 2 reserved registers are <code>rip</code> and <code>rsp</code> which hold the address of the next instruction to execute and the address of the stack respectively.</p> <p>On x86, the same register can have different sized accesses for backwards compatability. For example, the <code>rax</code> register is the full 64-bit register, <code>eax</code> is the low 32 bits of <code>rax</code>, <code>ax</code> is the low 16 bits, <code>al</code> is the low 8 bits, and <code>ah</code> is the high 8 bits of <code>ax</code> (bits 8-16 of <code>rax</code>).</p>"}, {"location": "binary-exploitation/what-is-a-format-string-vulnerability/", "title": "Format String Vulnerability", "text": "<p>A format string vulnerability is a bug where user input is passed as the format argument to <code>printf</code>, <code>scanf</code>, or another function in that family.</p> <p>The format argument has many different specifies which could allow an attacker to leak data if they control the format argument to <code>printf</code>. Since <code>printf</code> and similar are variadic functions, they will continue popping data off of the stack according to the format.</p> <p>For example, if we can make the format argument \"%x.%x.%x.%x\", <code>printf</code> will pop off four stack values and print them in hexadecimal, potentially leaking sensitive information.</p> <p><code>printf</code> can also index to an arbitrary \"argument\" with the following syntax: \"%n$x\" (where <code>n</code> is the decimal index of the argument you want).</p> <p>While these bugs are powerful, they're very rare nowadays, as all modern compilers warn when <code>printf</code> is called with a non-constant string.</p>"}, {"location": "binary-exploitation/what-is-a-format-string-vulnerability/#example", "title": "Example", "text": "<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int secret_num = 0x8badf00d;\n\n    char name[64] = {0};\n    read(0, name, 64);\n    printf(\"Hello \");\n    printf(name);\n    printf(\"! You'll never get my secret!\\n\");\n    return 0;\n}\n</code></pre> <p>Due to how GCC decided to lay out the stack, <code>secret_num</code> is actually at a lower address on the stack than <code>name</code>, so we only have to go to the 7th \"argument\" in <code>printf</code> to leak the secret:</p> <pre><code>$ ./fmt_string\n%7$llx\nHello 8badf00d3ea43eef\n! You'll never get my secret!\n</code></pre>"}, {"location": "binary-exploitation/what-is-binary-security/", "title": "Binary Security", "text": "<p>Binary Security is using tools and methods in order to secure programs from being manipulated and exploited. This tools are not infallible, but when used together and implemented properly, they can raise the difficulty of exploitation greatly.</p> <p>Some methods covered include:</p> <ul> <li>No eXecute (NX)</li> <li>Address Space Layout Randomization (ASLR)</li> <li>Relocation Read-Only (RELRO)</li> <li>Stack Canaries/Cookies</li> </ul>"}, {"location": "binary-exploitation/what-is-the-got/", "title": "GOT", "text": "<p>The Global Offset Table (or GOT) is a section inside of programs that holds addresses of functions that are dynamically linked. As mentioned in the page on calling conventions, most programs don't include every function they use to reduce binary size. Instead, common functions (like those in libc) are \"linked\" into the program so they can be saved once on disk and reused by every program.</p> <p>Unless a program is marked full RELRO, the resolution of function to address in dynamic library is done lazily. All dynamic libraries are loaded into memory along with the main program at launch, however functions are not mapped to their actual code until they're first called. For example, in the following C snippet <code>puts</code> won't be resolved to an address in libc until after it has been called once:</p> <pre><code>int main() {\n    puts(\"Hi there!\");\n    puts(\"Ok bye now.\");\n    return 0;\n}\n</code></pre> <p>To avoid searching through shared libraries each time a function is called, the result of the lookup is saved into the GOT so future function calls \"short circuit\" straight to their implementation bypassing the dynamic resolver.</p> <p>This has two important implications:</p> <ol> <li>The GOT contains pointers to libraries which move around due to ASLR</li> <li>The GOT is writable</li> </ol> <p>These two facts will become very useful to use in Return Oriented Programming</p>"}, {"location": "binary-exploitation/what-is-the-got/#plt", "title": "PLT", "text": "<p>Before a functions address has been resolved, the GOT points to an entry in the Procedure Linkage Table (PLT). This is a small \"stub\" function which is responsible for calling the dynamic linker with (effectively) the name of the function that should be resolved.</p>"}, {"location": "binary-exploitation/what-is-the-heap/", "title": "The Heap", "text": "<p>The heap is a place in memory which a program can use to dynamically create objects. Creating objects on the heap has some advantages compared to using the stack:</p> <ul> <li>Heap allocations can be dynamically sized</li> <li>Heap allocations \"persist\" when a function returns</li> </ul> <p>There are also some disadvantages however:</p> <ul> <li>Heap allocations can be slower</li> <li>Heap allocations must be manually cleaned up</li> </ul>"}, {"location": "binary-exploitation/what-is-the-heap/#using-the-heap", "title": "Using the heap", "text": "<p>In C, there are a number of functions used to interact with the heap, but we're going to focus on the two core ones:</p> <ul> <li><code>malloc</code>: allocate <code>n</code> bytes on the heap</li> <li><code>free</code>: free the given allocation</li> </ul> <p>Let's see how these could be used in a program:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    unsigned alloc_size = 0;\n    char *stuff;\n\n    printf(\"Number of bytes? \");\n    scanf(\"%u\", &amp;alloc_size);\n\n    stuff = malloc(alloc_size + 1);\n    memset(0, stuff, alloc_size + 1);\n\n    read(0, stuff, alloc_size);\n\n    printf(\"You wrote: %s\", stuff);\n\n    free(stuff);\n\n    return 0;\n}\n</code></pre> <p>This program reads in a size from the user, creates an allocation of that size on the heap, reads in that many bytes, then prints it back out to the user.</p>"}, {"location": "binary-exploitation/what-is-the-stack/", "title": "The Stack", "text": "<p>In computer architecture, the stack is a hardware manifestation of the stack data structure (a Last In, First Out queue).</p> <p>In x86, the stack is simply an area in RAM that was chosen to be the stack - there is no special hardware to store stack contents. The <code>esp</code>/<code>rsp</code> register holds the address in memory where the bottom of the stack resides. When something is <code>push</code>ed to the stack, <code>esp</code> decrements by 4 (or 8 on 64-bit x86), and the value that was <code>push</code>ed is stored at that location in memory. Likewise, when a <code>pop</code> instruction is executed, the value at <code>esp</code> is retrieved (i.e. <code>esp</code> is dereferenced), and <code>esp</code> is then incremented by 4 (or 8).</p> <p>N.B. The stack \"grows\" down to lower memory addresses!</p> <p>Conventionally, <code>ebp</code>/<code>rbp</code> contains the address of the top of the current stack frame, and so sometimes local variables are referenced as an offset relative to <code>ebp</code> rather than an offset to <code>esp</code>. A stack frame is essentially just the space used on the stack by a given function.</p>"}, {"location": "binary-exploitation/what-is-the-stack/#uses", "title": "Uses", "text": "<p>The stack is primarily used for a few things:</p> <ul> <li>Storing function arguments</li> <li>Storing local variables</li> <li>Storing processor state between function calls</li> </ul>"}, {"location": "binary-exploitation/what-is-the-stack/#example", "title": "Example", "text": "<p>Let's see what the stack looks like right after <code>say_hi</code> has been called in this 32-bit x86 C program:</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid say_hi(const char * name) {\n    printf(\"Hello %s!\\n\", name);\n}\n\nint main(int argc, char ** argv) {\n    char * name;\n    if (argc != 2) {\n        return 1;\n    }\n    name = argv[1];\n    say_hi(name);\n    return 0;\n}\n</code></pre> <p>And the relevant assembly:</p> <pre><code>0804840b &lt;say_hi&gt;:\n 804840b:   55                      push   ebp\n 804840c:   89 e5                   mov    ebp,esp\n 804840e:   83 ec 08                sub    esp,0x8\n 8048411:   83 ec 08                sub    esp,0x8\n 8048414:   ff 75 08                push   DWORD PTR [ebp+0x8]\n 8048417:   68 f0 84 04 08          push   0x80484f0\n 804841c:   e8 bf fe ff ff          call   80482e0 &lt;printf@plt&gt;\n 8048421:   83 c4 10                add    esp,0x10\n 8048424:   90                      nop\n 8048425:   c9                      leave\n 8048426:   c3                      ret\n\n08048427 &lt;main&gt;:\n 8048427:   8d 4c 24 04             lea    ecx,[esp+0x4]\n 804842b:   83 e4 f0                and    esp,0xfffffff0\n 804842e:   ff 71 fc                push   DWORD PTR [ecx-0x4]\n 8048431:   55                      push   ebp\n 8048432:   89 e5                   mov    ebp,esp\n 8048434:   51                      push   ecx\n 8048435:   83 ec 14                sub    esp,0x14\n 8048438:   89 c8                   mov    eax,ecx\n 804843a:   83 38 02                cmp    DWORD PTR [eax],0x2\n 804843d:   74 07                   je     8048446 &lt;main+0x1f&gt;\n 804843f:   b8 01 00 00 00          mov    eax,0x1\n 8048444:   eb 1c                   jmp    8048462 &lt;main+0x3b&gt;\n 8048446:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 8048449:   8b 40 04                mov    eax,DWORD PTR [eax+0x4]\n 804844c:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax\n 804844f:   83 ec 0c                sub    esp,0xc\n 8048452:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n 8048455:   e8 b1 ff ff ff          call   804840b &lt;say_hi&gt;\n 804845a:   83 c4 10                add    esp,0x10\n 804845d:   b8 00 00 00 00          mov    eax,0x0\n 8048462:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\n 8048465:   c9                      leave\n 8048466:   8d 61 fc                lea    esp,[ecx-0x4]\n 8048469:   c3                      ret\n</code></pre> <p>Skipping over the bulk of <code>main</code>, you'll see that at <code>0x8048452</code> <code>main</code>'s <code>name</code> local is pushed to the stack because it's the first argument to <code>say_hi</code>. Then, a <code>call</code> instruction is executed. <code>call</code> instructions first push the current instruction pointer to the stack, then jump to their destination. So when the processor begins executing <code>say_hi</code> at <code>0x0804840b</code>, the stack looks like this:</p> <pre><code>EIP = 0x0804840b (push ebp)\nESP = 0xffff0000\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -&gt;  0xffff0000: 0x0804845a              // Return address for say_hi\n</code></pre> <p>The first thing <code>say_hi</code> does is save the current <code>ebp</code> so that when it returns, <code>ebp</code> is back where <code>main</code> expects it to be. The stack now looks like this:</p> <pre><code>EIP = 0x0804840c (mov ebp, esp)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nESP -&gt;  0xfffefffc: 0xffff002c              // Saved EBP\n</code></pre> <p>Again, note how <code>esp</code> gets smaller when values are pushed to the stack.</p> <p>Next, the current <code>esp</code> is saved into <code>ebp</code>, marking the top of the new stack frame.</p> <pre><code>EIP = 0x0804840e (sub esp, 0x8)\nESP = 0xfffefffc\nEBP = 0xfffefffc\n\n            0xffff0004: 0xffffa0a0              // say_hi argument 1\n            0xffff0000: 0x0804845a              // Return address for say_hi\nESP, EBP -&gt; 0xfffefffc: 0xffff002c              // Saved EBP\n</code></pre> <p>Then, the stack is \"grown\" to accommodate local variables inside <code>say_hi</code>.</p> <pre><code>EIP = 0x08048414 (push [ebp + 0x8])\nESP = 0xfffeffec\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -&gt;  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\nESP -&gt;  0xfffefffc: UNDEFINED\n</code></pre> <p>NOTE: stack space is not implictly cleared!</p> <p>Now, the 2 arguments to <code>printf</code> are pushed in reverse order.</p> <pre><code>EIP = 0x0804841c (call printf@plt)\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -&gt;  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\nESP -&gt;  0xfffeffe4: 0x080484f0              // printf argument 1\n</code></pre> <p>Finally, <code>printf</code> is called, which pushes the address of the next instruction to execute.</p> <pre><code>EIP = 0x080482e0\nESP = 0xfffeffe4\nEBP = 0xfffefffc\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\n        0xffff0000: 0x0804845a              // Return address for say_hi\nEBP -&gt;  0xfffefffc: 0xffff002c              // Saved EBP\n        0xfffefff8: UNDEFINED\n        0xfffefff4: UNDEFINED\n        0xfffefff0: UNDEFINED\n        0xfffeffec: UNDEFINED\n        0xfffeffe8: 0xffffa0a0              // printf argument 2\n        0xfffeffe4: 0x080484f0              // printf argument 1\nESP -&gt;  0xfffeffe0: 0x08048421              // Return address for printf\n</code></pre> <p>Once <code>printf</code> has returned, the <code>leave</code> instruction moves <code>ebp</code> into <code>esp</code>, and pops the saved EBP.</p> <pre><code>EIP = 0x08048426 (ret)\nESP = 0xfffefffc\nEBP = 0xffff002c\n\n        0xffff0004: 0xffffa0a0              // say_hi argument 1\nESP -&gt;  0xffff0000: 0x0804845a              // Return address for say_hi\n</code></pre> <p>And finally, <code>ret</code> pops the saved instruction pointer into <code>eip</code> which causes the program to return to main with the same <code>esp</code>, <code>ebp</code>, and stack contents as when <code>say_hi</code> was initially called.</p> <pre><code>EIP = 0x0804845a (add esp, 0x10)\nESP = 0xffff0000\nEBP = 0xffff002c\n\nESP -&gt;  0xffff0004: 0xffffa0a0              // say_hi argument 1\n</code></pre>"}, {"location": "cryptography/overview/", "title": "Overview", "text": ""}, {"location": "cryptography/overview/#cryptography", "title": "Cryptography", "text": "<p>Cryptography is the reason we can use banking apps, transmit sensitive information over the web, and in general protect our privacy. However, a large part of CTFs is breaking widely used encryption schemes which are improperly implemented. The math may seem daunting, but more often than not, a simple understanding of the underlying principles will allow you to find flaws and crack the code.</p> <p>The word \u201ccryptography\u201d technically means the art of writing codes. When it comes to digital forensics, it\u2019s a method you can use to understand how data is constructed for your analysis.</p>"}, {"location": "cryptography/overview/#what-is-cryptography-used-for", "title": "What is cryptography used for?", "text": "<p>Uses in every day software</p> <ul> <li>Securing web traffic (passwords, communication, etc.)</li> <li>Securing copyrighted software code</li> </ul> <p>Malicious uses</p> <ul> <li>Hiding malicious communication</li> <li>Hiding malicious code</li> </ul>"}, {"location": "cryptography/overview/#topics", "title": "Topics", "text": "<ul> <li>XOR</li> <li>Cesear Cipher</li> <li>Substitution Cipher</li> <li>Vigenere Cipher</li> <li>Hashing Functions</li> <li>Block Ciphers</li> <li>Stream Ciphers</li> <li>RSA</li> </ul>"}, {"location": "cryptography/what-are-block-ciphers/", "title": "Block Ciphers", "text": "<p>A Block Cipher is an algorithm which is used in conjunction with a cryptosystem in order to package a message into evenly distributed 'blocks' which are encrypted one at a time.</p>"}, {"location": "cryptography/what-are-block-ciphers/#definitions", "title": "Definitions", "text": "<ul> <li>Mode of Operation: How a block cipher is applied to an amount of data which exceeds a block's size</li> <li>Initialization Vector (IV): A sequence of bytes which is used to randomize encryption even if the same plaintext is encrypted</li> <li>Starting Variable (SV): Similar to the IV, except it is used during the first block to provide a random seed during encryption</li> <li>Padding: Padding is used to ensure that the block sizes all line up and ensure the last block fits the block cipher</li> <li>Plaintext: Unencrypted text; Data without obfuscation</li> <li>Key: A secret used to encrypt plaintext</li> <li>Ciphertext: Plaintext encrypted with a key</li> </ul>"}, {"location": "cryptography/what-are-block-ciphers/#common-block-ciphers", "title": "Common Block Ciphers", "text": "Mode Formulas Ciphertext ECB Y~i~ = F(PlainText~i~, Key) Y~i~ CBC Y~i~ = PlainText~i~ XOR Ciphertext~i-1~ F(Y, key); Ciphertext~0~ = IV PCBC Y~i~ = PlainText~i~ XOR (Ciphertext~i-1~ XOR PlainText~i-1~) F(Y, key); Ciphertext~0~ = IV CFB Y~i~ = Ciphertext~i-1~ Plaintext XOR F(Y, key); Ciphertext~0~ = IV OFB Y~i~ = F(Key, I~i-1~);Y~0~=IV Plaintext XOR Y~i~ CTR Y~i~ = F(Key, IV + g(i));IV = token(); Plaintext XOR Y~i~ <p>Note</p> <p>In this case ~i~ represents an index over the # of blocks in the plaintext. F() and g() represent the function used to convert plaintext into ciphertext.</p>"}, {"location": "cryptography/what-are-block-ciphers/#electronic-codebook-ecb", "title": "Electronic Codebook (ECB)", "text": "<p>ECB is the most basic block cipher, it simply chunks up plaintext into blocks and independently encrypts those blocks and chains them all into a ciphertext.</p> <p> </p>"}, {"location": "cryptography/what-are-block-ciphers/#flaws", "title": "Flaws", "text": "<p>Because ECB independently encrypts the blocks, patterns in data can still be seen clearly, as shown in the CBC Penguin image below.</p> Original Image ECB Image Other Block Cipher Modes"}, {"location": "cryptography/what-are-block-ciphers/#cipher-block-chaining-cbc", "title": "Cipher Block Chaining (CBC)", "text": "<p>CBC is an improvement upon ECB where an Initialization Vector is used in order to add randomness. The encrypted previous block is used as the IV for each sequential block meaning that the encryption process cannot be parallelized. CBC has been declining in popularity due to a variety of</p> <p> </p> <p>Note</p> <p>Even though the encryption process cannot be parallelized, the decryption process can be parallelized. If the wrong IV is used for decryption it will only affect the first block as the decryption of all other blocks depends on the ciphertext not the plaintext.</p>"}, {"location": "cryptography/what-are-block-ciphers/#propogating-cipher-block-chaining-pcbc", "title": "Propogating Cipher Block Chaining (PCBC)", "text": "<p>PCBC is a less used cipher which modifies CBC so that decryption is also not parallelizable. It also cannot be decrypted from any point as changes made during the decryption and encryption process \"propogate\" throughout the blocks, meaning that both the plaintext and ciphertext are used when encrypting or decrypting as seen in the images below.</p> <p> </p>"}, {"location": "cryptography/what-are-block-ciphers/#counter-ctr", "title": "Counter (CTR)", "text": "<p>Note</p> <p>Counter is also known as CM, integer counter mode (ICM), and segmented integer counter (SIC)</p> <p>CTR mode makes the block cipher similar to a stream cipher and it functions by adding a counter with each block in combination with a nonce and key to XOR the plaintext to produce the ciphertext. Similarly, the decryption process is the exact same except instead of XORing the plaintext, the ciphertext is XORed. This means that the process is parallelizable for both encryption and decryption and you can begin from anywhere as the counter for any block can be deduced easily.</p> <p> </p>"}, {"location": "cryptography/what-are-block-ciphers/#security-considerations", "title": "Security Considerations", "text": "<p>If the nonce chosen is non-random, it is important to concatonate the nonce with the counter (high 64 bits to the nonce, low 64 bits to the counter) as adding or XORing the nonce with the counter would break security as an attacker can cause a collisions with the nonce and counter. An attacker with access to providing a plaintext, nonce and counter can then decrypt a block by using the ciphertext as seen in the decryption image.</p>"}, {"location": "cryptography/what-are-block-ciphers/#padding-oracle-attack", "title": "Padding Oracle Attack", "text": "<p>A Padding Oracle Attack sounds complex, but essentially means abusing a block cipher by changing the length of input and being able to determine the plaintext.</p>"}, {"location": "cryptography/what-are-block-ciphers/#requirements", "title": "Requirements", "text": "<ul> <li>An oracle, or program, which encrypts data using CBC</li> <li>Continual use of the same key</li> </ul>"}, {"location": "cryptography/what-are-block-ciphers/#execution", "title": "Execution", "text": "<ol> <li>If we have two blocks of ciphertext, C~1~ and C~2~, we can get the plaintext P~2~</li> <li>Since we know that CBC decryptionis dependent on the prior ciphertext, if we change the last byte of C~1~ we can see if C~2~ has correct padding</li> <li>If it is correctly padded we know that the last byte of the plaintext</li> <li>If not, we can increase our byte by one and repeat until we have a successful padding</li> <li>We then repeat this for all successive bytes following C~1~ and if the block is 16 bytes we can expect a maximum of 4080 attempts which is trivial</li> </ol>"}, {"location": "cryptography/what-are-hashing-functions/", "title": "Hashing Functions", "text": "<p>Hashing functions are one way functions which theoretically provide a unique output for every input. MD5, SHA-1, and other hashes which were considered secure are now found to have collisions or two different pieces of data which produce the same supposed unique output.</p>"}, {"location": "cryptography/what-are-hashing-functions/#string-hashing", "title": "String Hashing", "text": "<p>A string hash is a number or string generated using an algorithm that runs on text or data.</p> <p>The idea is that each hash should be unique to the text or data (although sometimes it isn\u2019t). For example, the hash for \u201cdog\u201d should be different from other hashes.</p> <p>You can use command line tools tools or online resources such as this one. Example: <code>$ echo -n password | md5  5f4dcc3b5aa765d61d8327deb882cf99</code> Here, \u201cpassword\u201d is hashed with different hashing algorithms:</p> <ul> <li>SHA-1: 5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8</li> <li>SHA-2: 5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8</li> <li>MD5: 5F4DCC3B5AA765D61D8327DEB882CF99</li> <li>CRC32: BBEDA74F</li> </ul> <p>Generally, when verifying a hash visually, you can simply look at the first and last four characters of the string.</p>"}, {"location": "cryptography/what-are-hashing-functions/#file-hashing", "title": "File Hashing", "text": "<p>A file hash is a number or string generated using an algorithm that is run on text or data. The premise is that it should be unique to the text or data. If the file or text changes in any way, the hash will change.</p> <p>What is it used for? - File and data identification - Password/certificate storage comparison</p> <p>How can we determine the hash of a file? You can use the md5sum command (or similar).</p> <pre><code>$ md5sum samplefile.txt\n3b85ec9ab2984b91070128be6aae25eb samplefile.txt\n</code></pre>"}, {"location": "cryptography/what-are-hashing-functions/#hash-collisions", "title": "Hash Collisions", "text": "<p>A collision is when two pieces of data or text have the same cryptographic hash. This is very rare.</p> <p>What\u2019s significant about collisions is that they can be used to crack password hashes. Passwords are usually stored as hashes on a computer, since it\u2019s hard to get the passwords from hashes.</p> <p></p> <p>If you bruteforce by trying every possible piece of text or data, eventually you\u2019ll find something with the same hash. Enter it, and the computer accepts it as if you entered the actual password.</p> <p>Two different files on the same hard drive with the same cryptographic hash can be very interesting.</p> <p>\u201cIt\u2019s now well-known that the cryptographic hash function MD5 has been broken,\u201d said Peter Selinger of Dalhousie University. \u201cIn March 2005, Xiaoyun Wang and Hongbo Yu of Shandong University in China published an article in which they described an algorithm that can find two different sequences of 128 bytes with the same MD5 hash.\u201d</p> <p>For example, he cited this famous pair:</p> <p></p> <p>and</p> <p></p> <p>Each of these blocks has MD5 hash 79054025255fb1a26e4bc422aef54eb4.</p> <p>Selinger said that \u201cthe algorithm of Wang and Yu can be used to create files of arbitrary length that have identical MD5 hashes, and that differ only in 128 bytes somewhere in the middle of the file. Several people have used this technique to create pairs of interesting files with identical MD5 hashes.\u201d</p> <p>Ben Laurie has a nice website that visualizes this MD5 collision. For a non-technical, though slightly outdated, introduction to hash functions, see Steve Friedl\u2019s Illustrated Guide. And here\u2019s a good article from DFI News that explores the same topic.</p>"}, {"location": "cryptography/what-are-stream-ciphers/", "title": "Stream Ciphers", "text": "<p>A Stream Cipher is used for symmetric key cryptography, or when the same key is used to encrypt and decrypt data. Stream Ciphers encrypt pseudorandom sequences with bits of plaintext in order to generate ciphertext, usually with XOR. A good way to think about Stream Ciphers is to think of them as generating one-time pads from a given state. </p>"}, {"location": "cryptography/what-are-stream-ciphers/#definitions", "title": "Definitions", "text": "<ul> <li>A keystream is a sequence of pseudorandom digits which extend to the length of the plaintext in order to uniquely encrypt each character based on the corresponding digit in the keystream</li> </ul>"}, {"location": "cryptography/what-are-stream-ciphers/#one-time-pads", "title": "One Time Pads", "text": "<p>A one time pad is an encryption mechanism whereby the entire plaintext is XOR'd with a random sequence of numbers in order to generate a random ciphertext. The advantage of the one time pad is that it offers an immense amount of security BUT in order for it to be useful, the randomly generated key must be distributed on a separate secure channel, meaning that one time pads have little use in modern day cryptographic applications on the internet. Stream ciphers extend upon this idea by using a key, usually 128 bit in length, in order to seed a pseudorandom keystream which is used to encrypt the text.</p>"}, {"location": "cryptography/what-are-stream-ciphers/#types-of-stream-ciphers", "title": "Types of Stream Ciphers", "text": ""}, {"location": "cryptography/what-are-stream-ciphers/#synchronous-stream-ciphers", "title": "Synchronous Stream Ciphers", "text": "<p>A Synchronous Stream Cipher generates a keystream based on internal states not related to the plaintext or ciphertext. This means that the stream is generated pseudorandomly outside of the context of what is being encrypted. A binary additive stream cipher is the term used for a stream cipher which XOR's the bits with the bits of the plaintext. Encryption and decryption require that the synchronus state cipher be in the same state, otherwise the message cannot be decrypted. </p>"}, {"location": "cryptography/what-are-stream-ciphers/#self-synchronizing-stream-ciphers", "title": "Self-synchronizing Stream Ciphers", "text": "<p>A Self-synchronizing Stream Cipher, also known as an asynchronous stream cipher or ciphertext autokey (CTAK), is a stream cipher which uses the previous N digits in order to compute the keystream used for the next N characters.</p> <p>Note</p> <p>Seems a lot like block ciphers doesn't it? That's because block cipher feedback mode (CFB) is an example of a self-synchronizing stream ciphers.</p>"}, {"location": "cryptography/what-are-stream-ciphers/#stream-cipher-vulnerabilities", "title": "Stream Cipher Vulnerabilities", "text": ""}, {"location": "cryptography/what-are-stream-ciphers/#key-reuse", "title": "Key Reuse", "text": "<p>The key tenet of using stream ciphers securely is to NEVER repeat key use because of the communative property of XOR. If C~1~ and C~2~ have been XOR'd with a key K, retrieving that key K is trivial because C~1~ XOR C~2~ = P~1~ XOR P~2~ and having an english language based XOR means that cryptoanalysis tools such as a character frequency analysis will work well due to the low entropy of the english language.</p>"}, {"location": "cryptography/what-are-stream-ciphers/#bit-flipping-attack", "title": "Bit-flipping Attack", "text": "<p>Another key tenet of using stream ciphers securely is considering that just because a message has been decrypted, it does not mean the message has not been tampered with. Because decryption is based on state, if an attacker knows the layout of the plaintext, a Man in the Middle (MITM) attack can flip a bit during transit altering the underlying ciphertext. If a ciphertext decrypts to 'Transfer $1000', then a middleman can flip a single bit in order for the ciphertext to decrypt to 'Transfer $9000' because changing a single character in the ciphertext does not affect the state in a synchronus stream cipher.</p>"}, {"location": "cryptography/what-is-a-substitution-cipher/", "title": "Substitution Cipher", "text": "<p>A Substitution Cipher is system of encryption where different symobls substitute a normal alphabet.</p> <p></p>"}, {"location": "cryptography/what-is-a-vigenere-cipher/", "title": "Vigenere Cipher", "text": "<p>A Vigenere Cipher is an extended Caesar Cipher where a message is encrypted using various Caesar shifted alphabets.</p> <p>The following table can be used to encode a message: </p>"}, {"location": "cryptography/what-is-a-vigenere-cipher/#encryption", "title": "Encryption", "text": "<p>For example, encrypting the text <code>SUPERSECRET</code> with <code>CODE</code> would follow this process:</p> <ol> <li><code>CODE</code> gets padded to the length of <code>SUPERSECRET</code> so the key becomes <code>CODECODECOD</code></li> <li>For each letter in <code>SUPERSECRET</code> we use the table to get the Alphabet to use, in this instance row <code>C</code> and column <code>S</code></li> <li>The ciphertext's first letter then becomes <code>U</code></li> <li>We eventually get <code>UISITGHGTSW</code></li> </ol>"}, {"location": "cryptography/what-is-a-vigenere-cipher/#decryption", "title": "Decryption", "text": "<ol> <li>Go to the row of the key, in this case <code>C</code> </li> <li>Find the letter of the cipher text in this row, in this case <code>U</code></li> <li>The column is the first letter of the decrypted ciphertext, so we get <code>S</code></li> <li>After repeating this process we get back to <code>SUPERSECRET</code></li> </ol>"}, {"location": "cryptography/what-is-caesar-cipher-rot-13/", "title": "Caesar Cipher/ROT 13", "text": "<p>The Caesar Cipher or Caesar Shift is a cipher which uses the alphabet in order to encode texts.</p> <p><code>CAESAR</code> encoded with a shift of 8 is <code>KIMAIZ</code> so <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> becomes <code>IJKLMNOPQRSTUVWXYZABCDEFGH</code></p> <p>ROT13 is the same thing but a fixed shift of 13, this is a trivial cipher to bruteforce because there are only 25 shifts.</p> <p></p>"}, {"location": "cryptography/what-is-rsa/", "title": "RSA", "text": "<p>RSA, which is an abbreviation of the author's names (Rivest\u2013Shamir\u2013Adleman), is a cryptosystem which allows for asymmetric encryption. Asymmetric cryptosystems are alos commonly referred to as Public Key Cryptography where a public key is used to encrypt data and only a secret, private key can be used to decrypt the data.</p>"}, {"location": "cryptography/what-is-rsa/#definitions", "title": "Definitions", "text": "<ul> <li>The Public Key is made up of (n, e)</li> <li>The Private Key is made up of (n, d)</li> <li>The message is represented as m and is converted into a number</li> <li>The encrypted message or ciphertext is represented by c</li> <li>p and q are prime numbers which make up n</li> <li>e is the public exponent</li> <li>n is the modulus and its length in bits is the bit length (i.e. 1024 bit RSA)</li> <li>d is the private exponent</li> <li>The totient \u03bb(n) is used to compute d and is equal to the lcm(p-1, q-1), another definition for \u03bb(n) is that \u03bb(pq) = lcm(\u03bb(p), \u03bb(q))</li> </ul>"}, {"location": "cryptography/what-is-rsa/#what-makes-rsa-viable", "title": "What makes RSA viable?", "text": "<p>If public n, public e, private d are all very large numbers and a message m holds true for 0 &lt; m &lt; n, then we can say:</p> <p>(m^e^)^d^ \u2261 m (mod n)</p> <p>Note</p> <p>The triple equals sign in this case refers to modular congruence which in this case means that there exists an integer k such that (m^e^)^d^ = kn + m</p> <p>RSA is viable because it is incredibly hard to find d even with m, n, and e because factoring large numbers is an arduous process.</p>"}, {"location": "cryptography/what-is-rsa/#implementation", "title": "Implementation", "text": "<p>RSA follows 4 steps to be implemented: 1. Key Generation 2. Encryption 3. Decryption</p>"}, {"location": "cryptography/what-is-rsa/#key-generation", "title": "Key Generation", "text": "<p>We are going to follow along Wikipedia's small numbers example in order to make this idea a bit easier to understand.</p> <p>Note</p> <p>In This example we are using Carmichael's totient function where \u03bb(n) = lcm(\u03bb(p), \u03bb(q)), but Euler's totient function is perfectly valid to use with RSA. Euler's totient is \u03c6(n) = (p \u2212 1)(q \u2212 1)</p> <ol> <li>Choose two prime numbers such as: <ul> <li>p = 61 and q = 53</li> </ul> </li> <li>Find n: <ul> <li>n = pq = 3233</li> </ul> </li> <li> <p>Calculate \u03bb(n) = lcm(p-1, q-1) </p> <ul> <li>\u03bb(3233) = lcm(60, 52) = 780</li> </ul> </li> <li> <p>Choose a public exponent such that 1 &lt; e &lt; \u03bb(n) and is coprime (not a factor of) \u03bb(n). The standard is most cases is 65537, but we will be using: </p> <ul> <li>e = 17</li> </ul> </li> <li>Calculate d as the modular multiplicative inverse or in english find d such that: d x e mod \u03bb(n) = 1<ul> <li>d x 17 mod 780 = 1</li> <li>d = 413</li> </ul> </li> </ol> <p>Now we have a public key of (3233, 17) and a private key of (3233, 413)</p>"}, {"location": "cryptography/what-is-rsa/#encryption", "title": "Encryption", "text": "<p>With the public key, m can be encrypted trivially</p> <p>The ciphertext is equal to m^e^ mod n or:</p> <p>c = m^17^ mod 3233</p>"}, {"location": "cryptography/what-is-rsa/#decryption", "title": "Decryption", "text": "<p>With the private key, m can be decrypted trivially as well</p> <p>The plaintext is equal to c^d^ mod n or:</p> <p>m = c^413^ mod 3233</p>"}, {"location": "cryptography/what-is-rsa/#exploitation", "title": "Exploitation", "text": "<p>From the RsaCtfTool README</p> <p>Attacks:</p> <ul> <li>Weak public key factorization</li> <li>Wiener's attack</li> <li>Hastad's attack (Small public exponent attack)</li> <li>Small q (q &lt; 100,000)</li> <li>Common factor between ciphertext and modulus attack</li> <li>Fermat's factorisation for close p and q</li> <li>Gimmicky Primes method</li> <li>Past CTF Primes method</li> <li>Self-Initializing Quadratic Sieve (SIQS) using Yafu</li> <li>Common factor attacks across multiple keys</li> <li>Small fractions method when p/q is close to a small fraction</li> <li>Boneh Durfee Method when the private exponent d is too small compared to the modulus (i.e d &lt; n^0.292^)</li> <li>Elliptic Curve Method</li> <li>Pollards p-1 for relatively smooth numbers</li> <li>Mersenne primes factorization</li> </ul>"}, {"location": "cryptography/what-is-xor/", "title": "XOR", "text": ""}, {"location": "cryptography/what-is-xor/#data-representation", "title": "Data Representation", "text": "<p>Data can be represented in different bases, an 'A' needs to be a numerical representation of Base 2 or binary so computers can understand them</p> <p></p>"}, {"location": "cryptography/what-is-xor/#xor-basics", "title": "XOR Basics", "text": "<p>An XOR or eXclusive OR is a bitwise operation indicated by <code>^</code> and shown by the following truth table:</p> A B A ^ B 0 0 0 0 1 1 1 0 1 1 1 0 <p>So what XOR'ing bytes in the action <code>0xA0 ^ 0x2C</code> translates to is:</p> 1 0 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0 1 1 0 0 <p><code>0b10001100</code> is equivelent to <code>0x8C</code>, a cool property of XOR is that it is reversable meaning <code>0x8C ^ 0x2C = 0xA0</code> and <code>0x8C ^ 0xA0 = 0x2C</code></p> <p></p>"}, {"location": "cryptography/what-is-xor/#what-does-this-have-to-do-with-ctf", "title": "What does this have to do with CTF?", "text": "<p>XOR is a cheap way to encrypt data with a password. Any data can be encrypted using XOR as shown in this Python example:</p> <pre><code>&gt;&gt;&gt; data = 'CAPTURETHEFLAG'\n&gt;&gt;&gt; key = 'A'\n&gt;&gt;&gt; encrypted = ''.join([chr(ord(x) ^ ord(key)) for x in data])\n&gt;&gt;&gt; encrypted\n'\\x02\\x00\\x11\\x15\\x14\\x13\\x04\\x15\\t\\x04\\x07\\r\\x00\\x06'\n&gt;&gt;&gt; decrypted = ''.join([chr(ord(x) ^ ord(key)) for x in encrypted])\n&gt;&gt;&gt; decrypted\n'CAPTURETHEFLAG'\n</code></pre> <p>This can be extended using a multibyte key by iterating in parallel with the data.</p>"}, {"location": "cryptography/what-is-xor/#exploiting-xor-encryption", "title": "Exploiting XOR Encryption", "text": ""}, {"location": "cryptography/what-is-xor/#single-byte-xor-encryption", "title": "Single Byte XOR Encryption", "text": "<p>Single Byte XOR Encryption is trivial to bruteforce as there are only 255 key combinations to try.</p>"}, {"location": "cryptography/what-is-xor/#multibyte-xor-encryption", "title": "Multibyte XOR Encryption", "text": "<p>Multibyte XOR gets exponentially harder the longer the key, but if the encrypted text is long enough, character frequency analysis is a viable method to find the key. Character Frequency Analysis means that we split the cipher text into groups based on the number of characters in the key. These groups then are bruteforced using the idea that some letters appear more frequently in the english alphabet than others.</p>"}, {"location": "forensics/overview/", "title": "Forensics", "text": "<p>Forensics is the art of recovering the digital trail left on a computer. There are plenty of methods to find data which is seemingly deleted, not stored, or worse, covertly recorded. </p> <p>An important part of forensics is having the right tools, as well as being familiar with the following topics:</p> <ul> <li>File Formats</li> <li>EXIF data</li> <li>Wireshark &amp; PCAPs<ul> <li>What is Wireshark</li> </ul> </li> <li>Stegonagraphy</li> <li>Disk Imaging</li> </ul>"}, {"location": "forensics/what-are-file-formats/", "title": "File Formats", "text": "<p>File Extensions are not the sole way to identify the type of a file, files have certain leading bytes called file signatures which allow programs to parse the data in a consistent manner. Files can also contain additional \"hidden\" data called metadata which can be useful in finding out information about the context of a file's data.</p>"}, {"location": "forensics/what-are-file-formats/#file-signatures", "title": "File Signatures", "text": "<p>File signatures (also known as File Magic Numbers) are bytes within a file used to identify the format of the file. Generally they\u2019re 2-4 bytes long, found at the beginning of a file.</p>"}, {"location": "forensics/what-are-file-formats/#what-is-it-used-for", "title": "What is it used for?", "text": "<p>Files can sometimes come without an extension, or with incorrect ones. We use file signature analysis to identify the format (file type) of the file. Programs need to know the file type in order to open it properly.</p>"}, {"location": "forensics/what-are-file-formats/#how-do-you-find-the-file-signature", "title": "How do you find the file signature?", "text": "<p>You need to be able to look at the binary data that constitutes the file you\u2019re examining. To do this, you\u2019ll use a hexadecimal editor. Once you find the file signature, you can check it against file signature repositories such as Gary Kessler\u2019s.</p>"}, {"location": "forensics/what-are-file-formats/#example", "title": "Example", "text": "<p>The file above, when opened in a Hex Editor, begins with the bytes <code>FFD8FFE0 00104A46 494600</code> or in ASCII <code>\u02c7\u00ff\u02c7\u2021  JFIF</code> where <code>\\x00</code> and <code>\\x10</code> lack symbols. </p> <p>Searching in Gary Kessler\u2019s database shows that this file signature belongs to a <code>JPEG/JFIF graphics file</code>, exactly what we suspect.</p>"}, {"location": "forensics/what-is-a-hex-editor/", "title": "Hex Editor", "text": "<p>A hexadecimal (hex) editor (also called a binary file editor or byte editor) is a computer program you can use to manipulate the fundamental binary data that constitutes a computer file. The name \u201chex\u201d comes from \u201chexadecimal,\u201d a standard numerical format for representing binary data. A typical computer file occupies multiple areas on the platter(s) of a disk drive, whose contents are combined to form the file. Hex editors that are designed to parse and edit sector data from the physical segments of floppy or hard disks are sometimes called sector editors or disk editors. A hex editor is used to see or edit the raw, exact contents of a file. Hex editors may used to correct data corrupted by a system or application. A list of editors can be found on the forensics Wiki. You can download one and install it on your system.</p>"}, {"location": "forensics/what-is-a-hex-editor/#example", "title": "Example", "text": "<p>Open fileA.jpg in a hex editor. (Most Hex editors have either a \u201cFile &gt; Open\u201d option or a simple drag and drop.)</p> <p></p> <p>When you open fileA.jpg in your hex editor, you should see something similar to this:</p> <p></p> <p>Your hex editor should also have a \u201cgo to\u201d or \u201cfind\u201d feature so you can jump to a specific byte.</p>"}, {"location": "forensics/what-is-disk-imaging/", "title": "Disk Imaging", "text": "<p>A forensic image is an electronic copy of a drive (e.g. a hard drive, USB, etc.). It\u2019s a bit-by-\u00adbit or bitstream file that\u2019s an exact, unaltered copy of the media being duplicated.</p> <p>Wikipedia said that the most straight\u00adforward disk imaging method is to read a disk from start to finish and write the data to a forensics image format. \u201cThis can be a time-consuming process, especially for disks with a large capacity,\u201d Wikipedia said.</p> <p>To prevent write access to the disk, you can use a write blocker. It\u2019s also common to calculate a cryptographic hash of the entire disk when imaging it. \u201cCommonly-used cryptographic hashes are MD5, SHA1 and/or SHA256,\u201d said Wikipedia. \u201cBy recalculating the integrity hash at a later time, one can determine if the data in the disk image has been changed. This by itself provides no protection against intentional tampering, but it can indicate that the data was altered, e.g. due to corruption.\u201d</p> <p>Why image a disk? Forensic imaging: - Prevents tampering with the original data\u00ad evidence - Allows you to play around with the copy, without worrying about messing up the original</p>"}, {"location": "forensics/what-is-disk-imaging/#forensic-image-extraction-exmple", "title": "Forensic Image Extraction Exmple", "text": "<p>This example uses the tool AccessData FTK Imager.</p> <p>Step 1: Go to <code>File &gt; Create Disk Image</code></p> <p></p> <p>Step 2: Select <code>Physical Drive</code>, because the USB or hard drive you\u2019re imaging is a physical device or drive.</p> <p></p> <p>Step 3: Select the drive you\u2019re imaging. The 1000 GB is my computer hard drive; the 128 MB is the USB that I want to image.</p> <p></p> <p>Step 4: Add a new image destination</p> <p></p> <p>Step 5: Select whichever image type you want. Choose <code>Raw (dd)</code> if you\u2019re a beginner, since it\u2019s the most common type</p> <p></p> <p>Step 6: Fill in all the evidence information</p> <p></p> <p>Step 7: Choose where you want to store it</p> <p></p> <p>Step 8: The image destination has been added. Now you can start the image extraction</p> <p></p> <p>Step 9: Wait for the image to be extracted</p> <p></p> <p>Step 10: This is the completed extraction</p> <p></p> <p>Step 11: Add the image you just created so that you can view it</p> <p></p> <p>Step 12: This time, choose image file, since that\u2019s what you just created</p> <p></p> <p>Step 13: Enter the path of the image you just created</p> <p></p> <p>Step 14: View the image.</p> <ol> <li>Evidence tree Structure of the drive image</li> <li>File list List of all the files in the drive image folder</li> <li>Properties Properties of the file/folder being examined</li> <li>Hex viewer View of the drive/folders/files in hexadecimal</li> </ol> <p></p> <p>Step 15: To view files in the USB, go to <code>Partition 1 &gt; [USB name] &gt; [root]</code> in the Evidence Tree and look in the File List</p> <p></p> <p>Step 16: Selecting fileA, fileB, fileC, or fileD gives us some properties of the files &amp; a preview of each photo</p> <p></p> <p>Step 17: Extract files of interest for further analysis by selecting, right-clicking and choosing <code>Export Files</code></p> <p></p>"}, {"location": "forensics/what-is-memory-forensics/", "title": "Memory Forensics", "text": "<p>There are plenty of traces of someone's activity on a computer, but perhaps some of the most valuble information can be found within memory dumps, that is images taken of RAM. These dumps of data are often very large, but can be analyzed using a tool called Volatility</p>"}, {"location": "forensics/what-is-memory-forensics/#volatility-basics", "title": "Volatility Basics", "text": "<p>Memory forensics isn't all that complicated, the hardest part would be using your toolset correctly. A good workflow is as follows:</p> <ol> <li>Run <code>strings</code> for clues</li> <li>Identify the image profile (which OS, version, etc.)</li> <li>Dump processes and look for suspicious processes</li> <li>Dump data related interesting processes</li> <li>View data in a format relating to the process (Word: docx, Notepad: txt, Photoshop: psd, etc.)</li> </ol>"}, {"location": "forensics/what-is-memory-forensics/#profile-identification", "title": "Profile Identification", "text": "<p>In order to properly use Volatility you must supply a profile with <code>--profile=PROFILE</code>, therefore before any sleuthing, you need to determine the profile using imageinfo:</p> <pre><code>$ python vol.py -f ~/image.raw imageinfo\nVolatility Foundation Volatility Framework 2.4\nDetermining profile based on KDBG search...\n\n          Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory (Kernel AS)\n                     AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw)\n                      PAE type : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors : 1\n     Image Type (Service Pack) : 0\n                KPCR for CPU 0 : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and time : 2012-02-22 11:29:02 UTC+0000\n     Image local date and time : 2012-02-22 03:29:02 -0800\n</code></pre>"}, {"location": "forensics/what-is-memory-forensics/#dump-processes", "title": "Dump Processes", "text": "<p>In order to view processes, the <code>pslist</code> or <code>pstree</code> or <code>psscan</code> command can be used.</p> <pre><code>$ python vol.py -f ~/image.raw pslist --profile=Win7SP0x64 pstree\nVolatility Foundation Volatility Framework 2.5\nOffset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------\n0xffffa0ee12532180 System                    4      0    108        0 ------      0 2018-04-22 20:02:33 UTC+0000\n0xffffa0ee1389d040 smss.exe                232      4      3        0 ------      0 2018-04-22 20:02:33 UTC+0000\n...\n0xffffa0ee128c6780 VBoxTray.exe           3324   1123     10        0      1      0 2018-04-22 20:02:55 UTC+0000\n0xffffa0ee14108780 OneDrive.exe           1422   1123     10        0      1      1 2018-04-22 20:02:55 UTC+0000\n0xffffa0ee14ade080 svchost.exe             228    121      1        0      1      0 2018-04-22 20:14:43 UTC+0000\n0xffffa0ee1122b080 notepad.exe            2019   1123      1        0      1      0 2018-04-22 20:14:49 UTC+0000\n</code></pre>"}, {"location": "forensics/what-is-memory-forensics/#process-memory-dump", "title": "Process Memory Dump", "text": "<p>Dumping the memory of a process can prove to be fruitful, say we want to dump the data from notepad.exe:</p> <pre><code>$ python vol.py -f ~/image.raw --profile=Win7SP0x64 memdump -p 2019 -D dump/\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nWriting System [     2019] to 2019.dmp\n\n$ ls -alh dump/2019.dmp\n-rw-r--r--  1 user  staff   111M Apr 22 20:47 dump/2019.dmp\n</code></pre>"}, {"location": "forensics/what-is-memory-forensics/#other-useful-commands", "title": "Other Useful Commands", "text": "<p>There are plenty of commands that Volatility offers but some highlights include:</p> <ul> <li><code>$ python vol.py -f IMAGE --profile=PROFILE connections</code>: view network connections</li> <li><code>$ python vol.py -f IMAGE --profile=PROFILE cmdscan</code>: view commands that were run in cmd prompt</li> </ul>"}, {"location": "forensics/what-is-metadata/", "title": "Metadata", "text": "<p>Metadata is data about data. Different types of files have different metadata. The metadata on a photo could include dates, camera information, GPS location, comments, etc. For music, it could include the title, author, track number and album.</p>"}, {"location": "forensics/what-is-metadata/#what-kind-of-file-metadata-is-useful", "title": "What kind of file metadata is useful?", "text": "<p>Potentially, any file metadata you can find could be useful.</p>"}, {"location": "forensics/what-is-metadata/#how-do-i-find-it", "title": "How do I find it?", "text": "<p>Note</p> <p>EXIF Data is metadata attached to photos which can include location, time, and device information.</p> <p>One of our favorite tools is exiftool, which displays metadata for an input file, including: - File size - Dimensions (width and height) - File type - Programs used to create (e.g. Photoshop) - OS used to create (e.g. Apple)</p> <p>Run command line: <code>exiftool(-k).exe [filename]</code> and you should see something like this:</p> <p></p>"}, {"location": "forensics/what-is-metadata/#example", "title": "Example", "text": "<p>Let's take a look at File A's metadata with exiftool: </p> <p>File type</p> <p></p> <p>Image description</p> <p></p> <p>Make and camera info</p> <p></p> <p>GPS Latitude/Longitude</p> <p></p>"}, {"location": "forensics/what-is-metadata/#timestamps", "title": "Timestamps", "text": "<p>Timestamps are data that indicate the time of certain events (MAC): - Modification \u2013 when a file was modified - Access \u2013 when a file or entries were read or accessed - Creation \u2013 when files or entries were created</p>"}, {"location": "forensics/what-is-metadata/#types-of-timestamps", "title": "Types of timestamps", "text": "<ul> <li>Modified</li> <li>Accessed</li> <li>Created</li> <li>Date Changed (MFT)</li> <li>Filename Date Created (MFT)</li> <li>Filename Date Modified (MFT)</li> <li>Filename Date Accessed (MFT)</li> <li>INDX Entry Date Created</li> <li>INDX Entry Date Modified</li> <li>INDX Entry Date Accessed</li> <li>INDX Entry Date Changed</li> </ul>"}, {"location": "forensics/what-is-metadata/#why-do-we-care", "title": "Why do we care?", "text": "<p>Certain events such as creating, moving, copying, opening, editing, etc. might affect the MAC times. If the MAC timestamps can be attained, a timeline of events could be created.</p>"}, {"location": "forensics/what-is-metadata/#timeline-patterns", "title": "Timeline Patterns", "text": "<p>There are plenty more patterns than the ones introduced below, but these are the basics you should start with to get a good understanding of how it works, and to complete this challenge.</p> <p> </p>"}, {"location": "forensics/what-is-metadata/#examples", "title": "Examples", "text": "<p>We know that the BMP files fileA and fileD are the same, but that the JPEG files fileB and fileC are different somehow. So how can we find out what went on with these files?</p> <p></p> <p>By using time stamp information from the file system, we can learn that the BMP fileD was the original file, with fileA being a copy of the original. Afterward, fileB was created by modifying fileB, and fileC was created by modifying fileA in a different way.</p> <p>Follow along as we demonstrate.</p> <p>We\u2019ll start by analyzing images in AccessData FTK Imager, where there\u2019s a Properties window that shows you some information about the file or folder you\u2019ve selected.</p> <p> </p> <p>Here are the extracted MAC times for fileA, fileB, fileC and fileD: Note, AccessData FTK Imager assumes that the file times on the drive are in UTC (Universal Coordinated Time). I subtracted four hours, since the USB was set up in Eastern Standard Time. This isn\u2019t necessary, but it helps me understand the times a bit better.</p> <p></p> <p>Highlight timestamps that are the same, if timestamps are off by a few seconds, they should be counted as the same. This lets you see a clear difference between different timestamps. Then, highlight oldest to newest to help put them in order.</p> <p> </p> <p>Identify timestamp patterns.</p> <p></p>"}, {"location": "forensics/what-is-stegonagraphy/", "title": "Steganography", "text": "<p>Steganography is the practice of hiding data in plain sight. Steganography is often embedded in images or audio.</p> <p>You could send a picture of a cat to a friend and hide text inside. Looking at the image, there\u2019s nothing to make anyone think there\u2019s a message hidden inside it.</p> <p></p> <p>You could also hide a second image inside the first.</p> <p></p>"}, {"location": "forensics/what-is-stegonagraphy/#steganography-detection", "title": "Steganography Detection", "text": "<p>So we can hide text and an image, how do we find out if there is hidden data?</p> <p></p> <p>FileA and FileD appear the same, but they\u2019re different. Also, FileD was modified after it was copied, so it\u2019s possible there might be steganography in it.</p> <p>FileB and FileC don\u2019t appear to have been modified after being created. That doesn\u2019t rule out the possibility that there\u2019s steganography in them, but you\u2019re more likely to find it in fileD. This brings up two questions:</p> <ol> <li>Can we determine that there is steganography in fileD?</li> <li>If there is, what was hidden in it?</li> </ol>"}, {"location": "forensics/what-is-stegonagraphy/#lsb-stegonagraphy", "title": "LSB Stegonagraphy", "text": "<p>File are made of bytes. Each byte is composed of eight bits.</p> <p></p> <p>Changing the least-significant bit (LSB) doesn\u2019t change the value very much.</p> <p></p> <p>So we can modify the LSB without changing the file noticeably. By doing so, we can hide a message inside.</p>"}, {"location": "forensics/what-is-stegonagraphy/#lsb-steganography-in-images", "title": "LSB Steganography in Images", "text": "<p>LSB Steganography or Least Significant Bit Steganography is a method of Steganography where data is recorded in the lowest bit of a byte.</p> <p>Say an image has a pixel with an RGB value of (255, 255, 255), the bits of those RGB values will look like</p> 1 1 1 1 1 1 1 1 <p>By modifying the lowest, or least significant, bit, we can use the 1 bit space across every RGB value for every pixel to construct a message.</p> 1 1 1 1 1 1 1 0 <p>The reason steganography is hard to detect by sight is because a 1 bit difference in color is insignificant as seen below.</p> <p></p>"}, {"location": "forensics/what-is-stegonagraphy/#example", "title": "Example", "text": "<p>Let\u2019s say we have an image, and part of it contains the following binary:</p> <p></p> <p>And let\u2019s say we want to hide the character y inside.</p> <p>First, we need to convert the hidden message to binary.</p> <p></p> <p>Now we take each bit from the hidden message and replace the LSB of the corresponding byte with it.</p> <p></p> <p>And again:</p> <p></p> <p>And again:</p> <p></p> <p>And again:</p> <p></p> <p>And again:</p> <p></p> <p>And again:</p> <p></p> <p>And again:</p> <p></p> <p>And once more:</p> <p></p> <p>Decoding LSB steganography is exactly the same as encoding, but in reverse. For each byte, grab the LSB and add it to your decoded message. Once you\u2019ve gone through each byte, convert all the LSBs you grabbed into text or a file. (You can use your file signature knowledge here!)</p>"}, {"location": "forensics/what-is-stegonagraphy/#what-other-types-of-steganography-are-there", "title": "What other types of steganography are there?", "text": "<p>Steganography is hard for the defense side, because there\u2019s practically an infinite number of ways it could be carried out. Here are a few examples: - LSB steganography: different bits, different bit combinations - Encode in every certain number of bytes  - Use a password - Hide in different places - Use encryption on top of steganography</p>"}, {"location": "forensics/what-is-wireshark/", "title": "Wireshark", "text": "<p>Note from our infrastructure team</p> <p>\"Wireshark saved me hours on my last tax return! - David\"</p> <p>\"[Wireshark] is great for ruining your weekend and fixing pesky networking problems!\" - Max\"</p> <p>\"Wireshark is the powerhouse of the cell. - Joe\"</p> <p>\"Does this cable do anything? - Ayyaz\"</p> <p>Wireshark is a network protocol analyzer which is often used in CTF challenges to look at recorded network traffic. Wireshark uses a filetype called PCAP to record traffic. PCAPs are often distributed in CTF challenges to provide recorded traffic history.</p>"}, {"location": "forensics/what-is-wireshark/#interface", "title": "Interface", "text": "<p>Upon opening Wireshark, you are greeted with the option to open a PCAP or begin capturing network traffic on your device.</p> <p></p> <p>The network traffic displayed initially shows the packets in order of which they were captured. You can filter packets by protocol, source IP address, destination IP address, length, etc. </p> <p></p> <p>In order to apply filters, simply enter the constraining factor, for example 'http', in the display filter bar. </p> <p></p> <p>Filters can be chained together using '&amp;&amp;' notation. In order to filter by IP, ensure a double equals '==' is used. </p> <p></p> <p>The most pertinent part of a packet is its data payload and protocol information.</p> <p></p>"}, {"location": "forensics/what-is-wireshark/#decrypting-ssl-traffic", "title": "Decrypting SSL Traffic", "text": "<p>By default, Wireshark cannot decrypt SSL traffic on your device unless you grant it specific certificates.</p>"}, {"location": "forensics/what-is-wireshark/#high-level-ssl-handshake-overview", "title": "High Level SSL Handshake Overview", "text": "<p>In order for a network session to be encrypted properly, the client and server must share a common secret for which they can use to encrypt and decrypt data without someone in the middle being able to guess. The SSL Handshake loosely follows this format:</p> <ol> <li>The client sends a list of available cipher suites it can use along with a random set of bytes referred to as client_random</li> <li>The server sends back the cipher suite that will be used, such as TLS_DHE_RSA_WITH_AES_128_CBC_SHA, along with a random set of bytes referred to as server_random</li> <li>The client generates a pre-master secret, encrypts it, then sends it to the server.</li> <li>The server and client then generate a common master secret using the selected cipher suite</li> <li>The client and server begin communicating using this common secret</li> </ol>"}, {"location": "forensics/what-is-wireshark/#decryption-requirements", "title": "Decryption Requirements", "text": "<p>There are several ways to be able to decrypt traffic.</p> <ul> <li>If you have the client and server random values and the pre-master secret, the master secret can be generated and used to decrypt the traffic</li> <li>If you have the master secret, traffic can be decrypted easily</li> <li>If the cipher-suite uses RSA, you can factor n in the key in order to break the encryption on the encrypted pre-master secret and generate the master secret with the client and server randoms </li> </ul> <p></p>"}, {"location": "reverse-engineering/overview/", "title": "Overview", "text": ""}, {"location": "reverse-engineering/overview/#reverse-engineering", "title": "Reverse Engineering", "text": "<p>Reverse Engineering in a CTF is typically the process of taking a compiled (machine code, bytecode) program and converting it back into a more human readable format.</p> <p>Very often the goal of a reverse engineering challenge is to understand the functionality of a given program such that you can identify deeper issues.</p> <ul> <li>Assembly / Machine Code</li> </ul> <ul> <li>The C Programming Language</li> <li>Disassemblers</li> <li>Decompilers</li> </ul>"}, {"location": "reverse-engineering/what-are-decompilers/", "title": "Decompilers", "text": "<p>Decompilers do the impossible and reverse compiled code back into psuedocode/code.</p> <p>IDA offers HexRays, which translates machine code into a higher language pseudocode.</p> <p></p>"}, {"location": "reverse-engineering/what-are-decompilers/#example-workflow", "title": "Example Workflow", "text": "<p>Let's say we are disassembling a program which has the source code:</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid printSpacer(int num){\n    for(int i = 0; i &lt; num; ++i){\n        printf(\"-\");\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    char* string = \"Hello, World!\";\n    for(int i = 0; i &lt; 13; ++i){\n        printf(\"%c\", string[i]);\n        for(int j = i+1; j &lt; 13; j++){\n            printf(\"%c\", string[j]);\n        }\n        printf(\"\\n\");\n        printSpacer(13 - i);\n    }\n    return 0;\n}\n</code></pre> <p>And creates an output of:</p> <pre><code>Hello, World!\n-------------\nello, World!\n------------\nllo, World!\n-----------\nlo, World!\n----------\no, World!\n---------\n, World!\n--------\n World!\n-------\nWorld!\n------\norld!\n-----\nrld!\n----\nld!\n---\nd!\n--\n!\n-\n</code></pre> <p>If we are given a binary compiled from that source and we want to figure out how the source looks, we can use a decompiler to get c pseudocode which we can then use to reconstruct the function. The sample decompilation can look like:</p> <pre><code>printSpacer:\nint __fastcall printSpacer(int a1)\n{\n  int i; // [rsp+8h] [rbp-8h]\n\n  for ( i = 0; i &lt; a1; ++i )\n    printf(\"-\");\n  return printf(\"\\n\");\n}\n\nmain:\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [rsp+18h] [rbp-18h]\n  signed int i; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i &lt; 13; ++i )\n  {\n    v4 = i + 1;\n    printf(\"%c\", (unsigned int)aHelloWorld[i], envp);\n    while ( v4 &lt; 13 )\n      printf(\"%c\", (unsigned int)aHelloWorld[v4++]);\n    printf(\"\\n\");\n    printSpacer(13 - i);\n  }\n  return 0;\n}\n</code></pre> <p>A good method of getting a good representation of the source is to convert the decompilation into Python since Python is basically psuedocode that runs. Starting with main often allows you to gain a good overview of what the program is doing and will help you translate the other functions.</p>"}, {"location": "reverse-engineering/what-are-decompilers/#main", "title": "Main", "text": "<p>We know we will start with a main function and some variables, if you trace the execution of the variables, you can oftentimes determine the variable type. Because i is being used as an index, we know its an int, and because v4 used as one later on, it too is an index. We can also see that we have a variable aHelloWorld being printed with \"%c\", we can determine it represents the 'Hello, World!' string. Lets define all these variables in our Python main function:</p> <pre><code>def main():\n    string = \"Hello, World!\"\n    i = 0\n    v4 = 0\n    for i in range(0, 13):\n        v4 = i + 1\n        print(string[i], end='')\n        while v4 &lt; 13:\n            print(string[v4], end='')\n            v4 += 1\n        print()\n        printSpacer(13-i)\n</code></pre>"}, {"location": "reverse-engineering/what-are-decompilers/#printspacer-function", "title": "printSpacer Function", "text": "<p>Now we can see that printSpacer is clearly being fed an int value. Translating it into python shouldn't be too hard.</p> <pre><code>def printSpacer(number):\n    i = 0\n    for i in range(0, number):\n        print(\"-\", end='')\n    print()\n</code></pre>"}, {"location": "reverse-engineering/what-are-decompilers/#results", "title": "Results", "text": "<p>Running main() gives us:</p> <pre><code>Hello, World!\n-------------\nello, World!\n------------\nllo, World!\n-----------\nlo, World!\n----------\no, World!\n---------\n, World!\n--------\n World!\n-------\nWorld!\n------\norld!\n-----\nrld!\n----\nld!\n---\nd!\n--\n!\n-\n</code></pre>"}, {"location": "reverse-engineering/what-are-disassemblers/", "title": "Disassemblers", "text": "<p>A disassembler is a tool which breaks down a compiled program into machine code.</p>"}, {"location": "reverse-engineering/what-are-disassemblers/#list-of-disassemblers", "title": "List of Disassemblers", "text": "<ul> <li>IDA</li> <li>Binary Ninja</li> <li>GNU Debugger (GDB)</li> <li>radare2</li> <li>Hopper</li> </ul>"}, {"location": "reverse-engineering/what-are-disassemblers/#ida", "title": "IDA", "text": "<p>The Interactive Disassembler (IDA) is the industry standard for binary disassembly. IDA is capable of disassembling \"virtually any popular file format\". This makes it very useful to security researchers and CTF players who often need to analyze obscure files without knowing what they are or where they came from. IDA also features the industry leading Hex Rays decompiler which can convert assembly code back into a pseudo code like format.</p> <p></p> <p>IDA also has a plugin interface which has been used to create some successful plugins that can make reverse engineering easier:</p> <ul> <li>https://github.com/google/binnavi</li> <li>https://github.com/yegord/snowman</li> <li>https://github.com/gaasedelen/lighthouse</li> <li>https://github.com/joxeankoret/diaphora</li> <li>https://github.com/REhints/HexRaysCodeXplorer</li> <li>https://github.com/osirislab/Fentanyl</li> </ul>"}, {"location": "reverse-engineering/what-are-disassemblers/#binary-ninja", "title": "Binary Ninja", "text": "<p>Binary Ninja is an up and coming disassembler that attempts to bring a new, more programmatic approach to reverse engineering. Binary Ninja brings an improved plugin API and modern features to reverse engineering. While it's less popular or as old as IDA, Binary Ninja (often called binja) is quickly gaining ground and has a small community of dedicated users and followers.</p> <p></p> <p>Binja also has some community contributed plugins which are collected here: https://github.com/Vector35/community-plugins</p>"}, {"location": "reverse-engineering/what-are-disassemblers/#gdb", "title": "gdb", "text": "<p>The GNU Debugger is a free and open source debugger which also disassembles programs. It's capable as a disassembler, but most notably it is used by CTF players for its debugging and dynamic analysis capabailities.</p> <p>gdb is often used in tandom with enhancement scripts like peda, pwndbg, and GEF</p> <p></p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/", "title": "Assembly/Machine Code", "text": "<p>Machine Code or Assembly is code which has been formatted for direct execution by a CPU. Machine Code is the why readable programming languages like C, when compiled, cannot be reversed into source code (well Decompilers can sort of, but more on that later).</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#from-source-to-compilation", "title": "From Source to Compilation", "text": "<p>Godbolt shows the differences in machine code generated by various compilers.</p> <p>For example, if we have a simple C++ function:</p> <pre><code>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    char c;\n    int fd = syscall(2, \"/etc/passwd\", 0);\n    while (syscall(0, fd, &amp;c, 1)) {\n        putchar(c);\n    }\n}\n</code></pre> <p>We can see the compilation results in some verbose instrucitons for the CPU:</p> <pre><code>.LC0:\n  .string \"/etc/passwd\"\nmain:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 16\n  mov edx, 0\n  mov esi, OFFSET FLAT:.LC0\n  mov edi, 2\n  mov eax, 0\n  call syscall\n  mov DWORD PTR [rbp-4], eax\n.L3:\n  lea rdx, [rbp-5]\n  mov eax, DWORD PTR [rbp-4]\n  mov ecx, 1\n  mov esi, eax\n  mov edi, 0\n  mov eax, 0\n  call syscall\n  test rax, rax\n  setne al\n  test al, al\n  je .L2\n  movzx eax, BYTE PTR [rbp-5]\n  movsx eax, al\n  mov edi, eax\n  call putchar\n  jmp .L3\n.L2:\n  mov eax, 0\n  leave\n  ret\n</code></pre> <p>This is a one way process for compiled languages as there is no way to generate source from machine code. While the machine code may seem unintelligble, the extremely basic functions can be interpreted with some practice.</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#x86-64", "title": "x86-64", "text": "<p>x86-64 or amd64 or i64 is a 64-bit Complex Instruction Set Computing (CISC) architecture. This basically means that the registers used for this architecture extend an extra 32-bits on Intel's x86 architecture. CISC means that a single instruction can do a bunch of diferent things at once such as memory accesses, register reads, etc. It is also a variable-length instruction set which means diferent instructions can be diferent sizes ranging from 1 to 16 bytes long. And finally x86-64 allows for multi-sized register access which means that you can access certain parts of a register which are diferent sizes.</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#x86-64-registers", "title": "x86-64 Registers", "text": "<p>x86-64 registers behave similarly to other architectures. A key component of x86-64 registers is multi-sized access which means the register RAX can have its lower 32 bits accessed with EAX. The next lower 16 bits can be accessed with AX and the lowest 8 bits can be accessed with AL which allows for the compuler to make optimizations which boost program execution. </p> <p>x86-64 has plenty of registers to use including rax, rbx, rcx, rdx, rdi, rsi, rsp, rip, r8-r15, and more! But some registers serve special purposes.</p> <p>The special registers include: - RIP: the instruction pointer - RSP: the stack pointer - RBP: the base pointer</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#instructions", "title": "Instructions", "text": "<p>An instruction represents a single operation for the CPU to perform.</p> <p>There are diferent types of instructions including:</p> <ul> <li>Data movement: <code>mov rax, [rsp - 0x40]</code></li> <li>Arithmetic: <code>add rbx, rcx</code></li> <li>Control-flow: <code>jne 0x8000400</code></li> </ul> <p>Because x86-64 is a CISC architecture, instructions can be quite complex for machine code such as <code>repne scasb</code> which repeats up to ECX times over memory at EDI looking for NULL byte (0x00), decrementing ECX each byte (Essentially strlen() in a single instruction!)</p> <p>It is important to remember that an instruction really is just memory, this idea will become useful with Return Oriented Programming or ROP.</p> <p>Note</p> <p>Instructions, numbers, strings, everything! Always represented in hex.</p> <pre><code>add rax, rbx\nmov rax, 0xdeadbeef\nmov rax, [0xdeadbeef] == 67 48 8b 05 ef be ad de\n\"Hello\" == 48 65 6c 6c 6f\n== 48 01 d8\n== 48 c7 c0 ef be ad de\n</code></pre>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#execution", "title": "Execution", "text": "<p>What should the CPU execute? This is determined by the RIP register where IP means instruction pointer. Execution follows the pattern: fetch the instruction at the address in RIP, decode it, run it.</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#examples", "title": "Examples", "text": "<ol> <li><code>mov rax, 0xdeadbeef</code></li> </ol> <p>Here the operation <code>mov</code> is moving the \"immeadiate\" <code>0xdeadbeef</code> into the register <code>RAX</code></p> <ol> <li><code>mov rax, [0xdeadbeef + rbx * 4]</code></li> </ol> <p>Here the operation <code>mov</code> is moving the data at the address of <code>[0xdeadbeef + RBX*4]</code> into the register <code>RAX</code>. When brackets are used, you can think of the program as getting the content from that effective address.</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#example-execution", "title": "Example Execution", "text": "<pre><code>-&gt; 0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804000\n   0x080400a: add, rax, rbx                  RAX = 0x0\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n-&gt; 0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x0\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400a\n-&gt; 0x080400a: add, rax, rbx                  RAX = 0xdeadbeef\n   0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x080400d\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n-&gt; 0x080400d: inc rbx                        RBX = 0x1234\n   0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804010\n   0x080400a: add, rax, rbx                  RAX = 0xdeadd123\n   0x080400d: inc rbx                        RBX = 0x1235\n-&gt; 0x0804010: sub rax, rbx                   RCX = 0x0\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804013\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0x0\n-&gt; 0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre> <pre><code>   0x0804000: mov eax, 0xdeadbeef            Register Values:\n   0x0804005: mov ebx, 0x1234                RIP = 0x0804005\n   0x080400a: add, rax, rbx                  RAX = 0xdeadbeee\n   0x080400d: inc rbx                        RBX = 0x1235\n   0x0804010: sub rax, rbx                   RCX = 0xdeadbeee\n   0x0804013: mov rcx, rax                   RDX = 0x0\n</code></pre>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#control-flow", "title": "Control Flow", "text": "<p>How can we express conditionals in x86-64? We use conditional jumps such as:</p> <ul> <li><code>jnz &lt;address&gt;</code></li> <li><code>je &lt;address&gt;</code></li> <li><code>jge &lt;address&gt;</code></li> <li><code>jle &lt;address&gt;</code></li> <li>etc.</li> </ul> <p>They jump if their condition is true, and just go to the next instruction otherwise. These conditionals are checking EFLAGS which are special registers which store flags on certain instructions such as <code>add rax, rbx</code> which sets the o (overflow) flag if the sum is greater than a 64-bit register can hold, and wraps around. You can jump based on that with a <code>jo</code> instruction. The most important thing to remember is the cmp instruction: <pre><code>cmp rax, rbx\njle error\n</code></pre> This assembly jumps if RAX &lt;= RBX</p>"}, {"location": "reverse-engineering/what-is-assembly-machine-code/#addresses", "title": "Addresses", "text": "<p>Memory acts similarly to a big array where the indices of this \"array\" are memory addresses. Remember from earlier:</p> <p><code>mov rax, [0xdeadbeef]</code></p> <p>The square brackets mean \"get the data at this address\". This is analagous to the C/C++ syntax: <code>rax = *0xdeadbeef;</code></p>"}, {"location": "reverse-engineering/what-is-bytecode/", "title": "What is bytecode", "text": ""}, {"location": "reverse-engineering/what-is-c/", "title": "The C Programming Language", "text": ""}, {"location": "reverse-engineering/what-is-c/#history", "title": "History", "text": "<p>The C programming language iwas written by Dennis Ritchie in the 1970s while he was working at Bell Labs. It was first used to reimplement the Unix operating system which was purely written in assembly language. At first, the Unix developers were considering using a language called \"B\" but because B wasn't optimized for the target computer, the C language was created.</p> <p>Note</p> <p>C is the letter and the programming language after B!</p> <p>C was designed to be close to assembly and is still widely used in lower level programming where speed and control are needed (operating systems, embedded systems). C was also very influential to other programming langauges used today. Notable languages include C++, Objective-C, Golang, Java, JavaScript, PHP, Python, and Rust.</p>"}, {"location": "reverse-engineering/what-is-c/#hello-world", "title": "Hello World", "text": "<p>C is an ancestor of many other programming languages and if you are familiar with programming, it's likely that C will be at least someewhat familiar.</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n   printf(\"Hello, World!\");\n   return 0;\n}\n</code></pre>"}, {"location": "reverse-engineering/what-is-c/#today", "title": "Today", "text": "<p>Today C is widely used either as a low level programming langauge or is the base language that other programming languages are implemented in.</p> <p>While it can be difficult to see, the C language compiles down directly into machine code. The compiler is programmed to process the provided C code and emit assembly that's targetted to whatever operating system and architecture the compiler is set to use.</p> <p>Some common compilers include:</p> <ul> <li>gcc</li> <li>clang</li> </ul> <p>A good way to explore this relationship is to use this online GCC Explorer from Matt Godbolt.</p> <p></p> <p>In regards to CTF, many reverse engineering and exploitation CTF challenges are written in C because the language compiles down directly to assembly and there are little to no safeguards in the language. This means developers must manually handle both. Of course, this can lead to mistakes which can sometimes lead to security issues.</p> <p>Note</p> <p>Other higher level langauges like Python manage memory and garbage collection for you. Google Golang was inspired by C but adds in functionality like garbage collection, and memory safety.</p> <p>There are some examples of famously vulnerable functions in C which are still available and can still result in vulnerabilities:</p> <ul> <li><code>gets</code> - Can result in buffer overflows</li> <li><code>strcpy</code> - Can result in buffer overflows</li> <li><code>strcat</code> - Can result in buffer overflows</li> <li><code>strcmp</code> - Can result in timing attacks</li> </ul>"}, {"location": "reverse-engineering/what-is-c/#types", "title": "Types", "text": "<p>C has four basic types:</p> <ul> <li>char - characters</li> <li>int - integers (e.g. 125)</li> <li>float - 32 bit floating point number (e.g. 2.4)</li> <li>double - 64 bit floating point number (like a float but more precise in terms of decimal points)</li> </ul>"}, {"location": "reverse-engineering/what-is-c/#pointers", "title": "Pointers", "text": "<p>C uses an idea known as pointers. A pointer is a variable which contains the address of another variable.</p> <p>To understand this idea we should first understand that memory is laid out in terms of addresses and data gets stored at these addresses.</p> <p>Take the following example of defining an integer in C:</p> <pre><code>int x = 4;\n</code></pre> <p>To the programmer this is the variable <code>x</code> receiving the value of 4. The computer stores this value in some location in memory. For example we can say that address <code>0x1000</code> now holds the value <code>4</code>. The computer knows to directly access the memory and retrieve the value <code>4</code> whenever the programmer tries to use the <code>x</code> variable. If we were to say <code>x + 4</code>, the computer would give you <code>8</code> instead of <code>0x1004</code>.</p> <p>But in C we can retrieve the memory address being used to hold the 4 value (i.e. 0x1000) by using the <code>&amp;</code> character and using <code>*</code> to create an \"integer pointer\" type.</p> <pre><code>int* y = &amp;x;\n</code></pre> <p>The <code>y</code> variable will store the address pointed to by the <code>x</code>variable (0x1000).</p> <p>Note</p> <p>The <code>*</code> character allows us to declare pointer variables but also allows us to access the value stored at a pointer. For example, entering <code>*y</code> allows us to access the 4 value instead of 0x1000.</p> <p>Whenever we use the <code>y</code> variable we are using the memory address, but if we use the x variable we use the value stored at the memory address.</p>"}, {"location": "reverse-engineering/what-is-c/#arrays", "title": "Arrays", "text": "<p>Arrays are a grouping of objects of the same type. They are typically created with the following syntax:</p> <pre><code>type arrayName [ arraySize ];\n</code></pre> <p>To initialize values in the array we can do:</p> <pre><code>int integers[ 10 ] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n</code></pre> <p>Arrays allow programmers to group data into logical containers.</p> <p>To access the indiviual elements of an array we access the contents by their \"index\". Most programming langauges today start counting from 0. So to take our previous example:</p> <pre><code>int integers[ 10 ] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n/*     indexes        0  1  2  3  4  5  6  7  8   9\n</code></pre> <p>To access the value 6 we would use index 5:</p> <pre><code>integers[5];\n</code></pre>"}, {"location": "reverse-engineering/what-is-c/#how-do-arrays-work", "title": "How do arrays work?", "text": "<p>Arrays are a clever combination of multiplication, pointers, and programming.</p> <p>Because the computer knows the data type used for every element in the array, the computer needs to simply multiply the size of the data type by the index you are looking for and then add this value to the address of the beginning of the array.</p> <p>For example if we know that the base address of an array is 1000 and we know that each integer takes 8 bytes, we know that if we have 8 integers right next to each other, we can get the integer at the 4th index with the following math:</p> <pre><code>1000 + (4 * 8) =  1032\n</code></pre> <pre><code>array [ 1   , 2   , 3   , 4   , 5   , 6   , 7   , 8   ]\nindex   0     1     2     3     4     5     6     7\naddrs  1000  1008  1016  1024  1032  1040  1048  1056\n</code></pre>"}, {"location": "reverse-engineering/what-is-c/#memory-management", "title": "Memory Management", "text": ""}, {"location": "reverse-engineering/what-is-gdb/", "title": "The GNU Debugger (GDB)", "text": "<p>The GNU Debugger or GDB is a powerful debugger which allows for step-by-step execution of a program. It can be used to trace program execution and is an important part of any reverse engineering toolkit.</p>"}, {"location": "reverse-engineering/what-is-gdb/#vanilla-gdb", "title": "Vanilla GDB", "text": "<p>GDB without any modifications is unintuitive and obscures a lot of useful information. The plug-in pwndb solves a lot of these problems and makes for a much more pleasant experience. But if you are constrained and have to use vanilla gdb, here are several things to make your life easier.</p>"}, {"location": "reverse-engineering/what-is-gdb/#starting-gdb", "title": "Starting GDB", "text": "<p>To execute GBD and attach it to a program simply run <code>gdb [program]</code></p>"}, {"location": "reverse-engineering/what-is-gdb/#disassembly", "title": "Disassembly", "text": "<p><code>(gdb) disassemble [address/symbol]</code> will display the disassembly for that function/frame</p> <p>GDB will autocomplete functions, so saying <code>(gdb) disas main</code> suffices if you'd like to see the disassembly of main</p>"}, {"location": "reverse-engineering/what-is-gdb/#view-disassembly-during-execution", "title": "View Disassembly During Execution", "text": "<p>Another handy thing to see while stepping through a program is the disassembly of nearby instructions:</p> <p><code>(gdb) display/[# of instructions]i $pc [\u00b1 offset]</code></p> <ul> <li><code>display</code> shows data with each step</li> <li><code>/[#]i</code> shows how much data in the format i for instruction </li> <li><code>$pc</code> means the pc, program counter, register</li> <li><code>[\u00b1 offset]</code> allows you to specify how you would like the data offset from the current instruction</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#example-usage", "title": "Example Usage", "text": "<p><code>(gdb) display/10i $pc - 0x5</code></p> <p>This command will show 10 instructions on screen with an offset from the next instruction of 5, giving us this display:</p> <pre><code>   0x8048535 &lt;main+6&gt;:  lock pushl -0x4(%ecx)\n   0x8048539 &lt;main+10&gt;: push   %ebp\n=&gt; 0x804853a &lt;main+11&gt;: mov    %esp,%ebp\n   0x804853c &lt;main+13&gt;: push   %ecx\n   0x804853d &lt;main+14&gt;: sub    $0x14,%esp\n   0x8048540 &lt;main+17&gt;: sub    $0xc,%esp\n   0x8048543 &lt;main+20&gt;: push   $0x400\n   0x8048548 &lt;main+25&gt;: call   0x80483a0 &lt;malloc@plt&gt;\n   0x804854d &lt;main+30&gt;: add    $0x10,%esp\n   0x8048550 &lt;main+33&gt;: sub    $0xc,%esp\n</code></pre>"}, {"location": "reverse-engineering/what-is-gdb/#deleting-views", "title": "Deleting Views", "text": "<p>If for whatever reason, a view no long suits your needs simply call <code>(gdb) info display</code> which will give you a list of active displays:</p> <pre><code>Auto-display expressions now in effect:\nNum Enb Expression\n1:   y  /10bi $pc-0x5\n</code></pre> <p>Then simply execute <code>(gdb) delete display 1</code> and your execution will resume without the display.</p>"}, {"location": "reverse-engineering/what-is-gdb/#registers", "title": "Registers", "text": "<p>In order to view the state of registers with vanilla gdb, you need to run the command <code>info registers</code> which will display the state of all the registers:</p> <pre><code>eax            0xf77a6ddc   -142971428\necx            0xffe06b10   -2069744\nedx            0xffe06b34   -2069708\nebx            0x0  0\nesp            0xffe06af8   0xffe06af8\nebp            0x0  0x0\nesi            0xf77a5000   -142979072\nedi            0xf77a5000   -142979072\neip            0x804853a    0x804853a &lt;main+11&gt;\neflags         0x286    [ PF SF IF ]\ncs             0x23 35\nss             0x2b 43\nds             0x2b 43\nes             0x2b 43\nfs             0x0  0\ngs             0x63 99\n</code></pre> <p>If you simply would like to see the contents of a single register, the notation <code>x/x $[register]</code> where:</p> <ul> <li><code>x/x</code> means display the address in hex notation</li> <li><code>$[register]</code> is the register code such as eax, rax, etc.</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#pwndbg", "title": "Pwndbg", "text": "<p>These commands work with vanilla gdb as well.</p>"}, {"location": "reverse-engineering/what-is-gdb/#setting-breakpoints", "title": "Setting Breakpoints", "text": "<p>Setting breakpoints in GDB uses the format <code>b*[Address/Symbol]</code></p>"}, {"location": "reverse-engineering/what-is-gdb/#example-usage_1", "title": "Example Usage", "text": "<ul> <li><code>(gdb) b*main</code>: Break at the start</li> <li><code>(gdb) b*0x804854d</code>: Break at 0x804854d</li> <li><code>(gdb) b*0x804854d-0x100</code>: Break at 0x804844d</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#deleting-breakpoints", "title": "Deleting Breakpoints", "text": "<p>As before, in order to delete a view, you can list the available breakpoints using <code>(gdb) info breakpoints</code> (don't forget about GDB's autocomplete, you don't always need to type out every command!) which will display all breakpoints:</p> <pre><code>Num     Type           Disp Enb Address    What\n1       breakpoint     keep y   0x0804852f &lt;main&gt;\n3       breakpoint     keep y   0x0804864d &lt;__libc_csu_init+61&gt;\n</code></pre> <p>Then simply execute <code>(gdb) delete 1</code></p> <p>Note</p> <p>GDB creates breakpoints chronologically and does NOT reuse numbers.</p>"}, {"location": "reverse-engineering/what-is-gdb/#stepping", "title": "Stepping", "text": "<p>What good is a debugger if you can't control where you are going? In order to begin execution of a program, use the command <code>r [arguments]</code> similar to how if you ran it with dot-slash notation you would execute it <code>./program [arguments]</code>. In this case the program will run normally and if no breakpoints are set, you will execute normally. If you have breakpoints set, you will stop at that instruction.</p> <ul> <li><code>(gdb) continue [# of breakpoints]</code>: Resumes the execution of the program until it finishes or until another breakpoint is hit (shorthand <code>c</code>)</li> <li><code>(gdb) step[# of instructions]</code>: Steps into an instruction the specified number of times, default is 1 (shorthand <code>s</code>)</li> <li><code>(gdb) next instruction [# of instructions]</code>: Steps over an instruction meaning it will not delve into called functions (shorthand <code>ni</code>)</li> <li><code>(gdb) finish</code>: Finishes a function and breaks after it gets returned (shorthand <code>fin</code>)</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#examining", "title": "Examining", "text": "<p>Examining data in GDB is also very useful for seeing how the program is affecting data. The notation may seem complex at first, but it is flexible and provides powerful functionality.</p> <p><code>(gdb) x/[#][size][format] [Address/Symbol/Register][\u00b1 offset]</code></p> <ul> <li><code>x/</code> means examine</li> <li><code>[#]</code> means how much</li> <li><code>[size]</code> means what size the data should be such as a word w (2 bytes), double word d (4 bytes), or giant word g (8 bytes)</li> <li><code>[format]</code> means how the data should be interpreted such as an instruction i, a string s, hex bytes x</li> <li><code>[Address/Symbol][\u00b1 offset]</code> means where to start interpreting the data</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#example-usage_2", "title": "Example Usage", "text": "<ul> <li><code>(gdb) x/x $rax</code>: Displays the content of the register RAX as hex bytes</li> <li><code>(gdb) x/i 0xdeadbeef</code>: Displays the instruction at address 0xdeadbeef</li> <li><code>(gdb) x/10s 0x893e10</code>: Displays 10 strings at the address</li> <li><code>(gdb) x/10gx 0x7fe10</code>: Displays 10 giant words as hex at the address</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#forking", "title": "Forking", "text": "<p>If the program happens to be an accept-and-fork server, gdb will have issues following the child or parent processes. In order to specify how you want gdb to function you can use the command <code>set follow-fork-mode [on/off]</code></p>"}, {"location": "reverse-engineering/what-is-gdb/#setting-data", "title": "Setting Data", "text": "<p>If you would like to set data at any point, it is possible using the command <code>set [Address/Register]=[Hex Data]</code></p>"}, {"location": "reverse-engineering/what-is-gdb/#example-usage_3", "title": "Example Usage", "text": "<ul> <li><code>set $rax=0x0</code>: Sets the register rax to 0</li> <li><code>set 0x1e4a70=0x123</code>: Sets the data at 0x1e4a70 to 0x123</li> </ul>"}, {"location": "reverse-engineering/what-is-gdb/#process-mapping", "title": "Process Mapping", "text": "<p>A handy way to find the process's mapped address spaces is to use <code>info proc map</code>:</p> <pre><code>Mapped address spaces:\n\n    Start Addr   End Addr       Size     Offset objfile\n     0x8048000  0x8049000     0x1000        0x0 /directory/program\n     0x8049000  0x804a000     0x1000        0x0 /directory/program\n     0x804a000  0x804b000     0x1000     0x1000 /directory/program\n    0xf75cb000 0xf75cc000     0x1000        0x0\n    0xf75cc000 0xf7779000   0x1ad000        0x0 /lib32/libc-2.23.so\n    0xf7779000 0xf777b000     0x2000   0x1ac000 /lib32/libc-2.23.so\n    0xf777b000 0xf777c000     0x1000   0x1ae000 /lib32/libc-2.23.so\n    0xf777c000 0xf7780000     0x4000        0x0\n    0xf778b000 0xf778d000     0x2000        0x0 [vvar]\n    0xf778d000 0xf778f000     0x2000        0x0 [vdso]\n    0xf778f000 0xf77b1000    0x22000        0x0 /lib32/ld-2.23.so\n    0xf77b1000 0xf77b2000     0x1000        0x0\n    0xf77b2000 0xf77b3000     0x1000    0x22000 /lib32/ld-2.23.so\n    0xf77b3000 0xf77b4000     0x1000    0x23000 /lib32/ld-2.23.so\n    0xffc59000 0xffc7a000    0x21000        0x0 [stack]\n</code></pre> <p>This will show you where the stack, heap (if there is one), and libc are located.</p>"}, {"location": "reverse-engineering/what-is-gdb/#attaching-processes", "title": "Attaching Processes", "text": "<p>Another useful feature of GDB is to attach to processes which are already running. Simply launch gdb using <code>gdb</code>, then find the process id of the program you would like to attach to an execute <code>attach [pid]</code>. </p>"}, {"location": "web-exploitation/overview/", "title": "Overview", "text": ""}, {"location": "web-exploitation/overview/#web-exploitation", "title": "Web Exploitation", "text": "<p>Websites all around the world are programmed using various programming languages. While there are specific vulnerabilities in each programming langage that the developer should be aware of, there are issues fundamental to the internet that can show up regardless of the chosen language or framework.</p> <p>These vulnerabilities often show up in CTFs as web security challenges where the user needs to exploit a bug to gain some kind of higher level privelege.</p> <p>Common vulnerabilities to see in CTF challenges:</p> <ul> <li>SQL Injection</li> <li>Command Injection</li> <li>Directory Traversal</li> <li>Cross Site Request Forgery</li> <li>Cross Site Scripting</li> <li>Server Side Request Forgery</li> </ul>"}, {"location": "web-exploitation/command-injection/what-is-command-injection/", "title": "Command Injection", "text": "<p>Command Injection is a vulnerability that allows an attacker to submit system commands to a computer running a website. This happens when the application fails to encode user input that goes into a system shell. It is very common to see this vulnerability when a developer uses the <code>system()</code> command or its equivalent in the programming language of the application.</p> <pre><code>import os\n\ndomain = user_input() # ctf101.org\n\nos.system('ping ' + domain)\n</code></pre> <p>The above code when used normally will ping the <code>ctf101.org</code> domain.</p> <p>But consider what would happen if the <code>user_input()</code> function returned different data?</p> <pre><code>import os\n\ndomain = user_input() # ; ls\n\nos.system('ping ' + domain)\n</code></pre> <p>Because of the additional semicolon, the <code>os.system()</code> function is instructed to run two commands.</p> <p>It looks to the program as:</p> <pre><code>ping ; ls\n</code></pre> <p>Note</p> <p>The semicolon terminates a command in bash and allows you to put another command after it.</p> <p>Because the <code>ping</code> command is being terminated and the <code>ls</code> command is being added on, the <code>ls</code> command will be run in addition to the empty ping command!</p> <p>This is the core concept behind command injection. The <code>ls</code> command could of course be switched with another command (e.g. wget, curl, bash, etc.)</p> <p>Command injection is a very common means of privelege escalation within web applications and applications that interface with system commands. Many kinds of home routers take user input and directly append it to a system command. For this reason, many of those home router models are vulnerable to command injection.</p>"}, {"location": "web-exploitation/command-injection/what-is-command-injection/#example-payloads", "title": "Example Payloads", "text": "<ul> <li><code>;ls</code></li> <li><code>$(ls)</code></li> <li><code>`ls`</code></li> </ul>"}, {"location": "web-exploitation/command-injection/what-is-command-injection/#related-challenges", "title": "Related Challenges", "text": ""}, {"location": "web-exploitation/cross-site-request-forgery/what-is-cross-site-request-forgery/", "title": "Cross Site Request Forgery (CSRF)", "text": "<p>A Cross Site Request Forgery or CSRF Attack, pronounced see surf, is an attack on an authenticated user which uses a state session in order to perform state changing attacks like a purchase, a transfer of funds, or a change of email address.</p> <p>The entire premise of CSRF is based on session hijacking, usually by injecting malicious elements within a webpage through an <code>&lt;img&gt;</code> tag or an <code>&lt;iframe&gt;</code> where references to external resources are unverified.</p>"}, {"location": "web-exploitation/cross-site-request-forgery/what-is-cross-site-request-forgery/#using-csrf", "title": "Using CSRF", "text": "<p><code>GET</code> requests are often used by websites to get user input. Say a user signs in to an banking site which assigns their browser a cookie which keeps them logged in. If they transfer some money, the URL that is sent to the server might have the pattern:</p> <p><code>http://securibank.com/transfer.do?acct=[RECEPIENT]&amp;amount=[DOLLARS]</code></p> <p>Knowing this format, an attacker can send an email with a hyperlink to be clicked on or they can include an image tag of 0 by 0 pixels which will automatically be requested by the browser such as:</p> <p><code>&lt;img src=\"http://securibank.com/transfer.do?acct=[RECEPIENT]&amp;amount=[DOLLARS]\" width=\"0\" height=\"0\" border=\"0\"&gt;</code></p>"}, {"location": "web-exploitation/cross-site-scripting/what-is-cross-site-scripting/", "title": "Cross Site Scripting (XSS)", "text": "<p>Cross Site Scripting or XSS is a vulnerability where on user of an application can send JavaScript that is executed by the browser of another user of the same application.</p> <p>This is a vulnerability because JavaScript has a high degree of control over a user's web browser.</p> <p>For example JavaScript has the ability to:</p> <ul> <li>Modify the page (called the DOM)</li> <li>Send more HTTP requests</li> <li>Access cookies</li> </ul> <p>By combining all of these abilities, XSS can maliciously use JavaScript to extract user's cookies and send them to an attacker controlled server. XSS can also modify the DOM to phish users for their passwords. This only scratches the surface of what XSS can be used to do.</p> <p>XSS is typically broken down into three categories:</p> <ul> <li>Reflected XSS</li> <li>Stored XSS</li> <li>DOM XSS</li> </ul>"}, {"location": "web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#reflected-xss", "title": "Reflected XSS", "text": "<p>Reflected XSS is when an XSS exploit is provided through a URL paramater.</p> <p>For example:</p> <pre><code>https://ctf101.org?data=&lt;script&gt;alert(1)&lt;/script&gt;\n</code></pre> <p>You can see the XSS exploit provided in the <code>data</code> GET parameter. If the application is vulnerable to reflected XSS, the application will take this data parameter value and inject it into the DOM.</p> <p>For example:</p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;script&gt;alert(1)&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Depending on where the exploit gets injected, it may need to be constructed differently.</p> <p>Also, the exploit payload can change to fit whatever the attacker needs it to do. Whether that is to extract cookies and submit it to an external server, or to simply modify the page to deface it.</p> <p>One of the deficiencies of reflected XSS however is that it requires the victim to access the vulnerable page from an attacker controlled resource. Notice that if the data paramter, wasn't provided the exploit wouldn't work.</p> <p>In many situations, reflected XSS is detected by the browser because it is very simple for a browser to detect malicous XSS payloads in URLs.</p>"}, {"location": "web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#stored-xss", "title": "Stored XSS", "text": "<p>Stored XSS is different from reflected XSS in one key way. In reflected XSS, the exploit is provided through a GET parameter. But in stored XSS, the exploit is provided from the website itself.</p> <p>Imagine a website that allows users to post comments. If a user can submit an XSS payload as a comment, and then have others view that malicious comment, it would be an example of stored XSS.</p> <p>The reason being that the web site itself is serving up the XSS payload to other users. This makes it very difficult to detect from the browser's perspective and no browser is capable of generically preventing stored XSS from exploiting a user.</p>"}, {"location": "web-exploitation/cross-site-scripting/what-is-cross-site-scripting/#dom-xss", "title": "DOM XSS", "text": "<p>DOM XSS is XSS that is due to the browser itself injecting an XSS payload into the DOM. While the server itself may properly prevent XSS, it's possible that the client side scripts may accidentally take a payload and insert it into the DOM and cause the payload to trigger.</p> <p>The server itself is not to blame, but the client side JavaScript files are causing the issue.</p>"}, {"location": "web-exploitation/directory-traversal/what-is-directory-traversal/", "title": "Directory Traversal", "text": "<p>Directory Traversal is a vulnerability where an application takes in user input and uses it in a directory path.</p> <p>Any kind of path controlled by user input that isn't properly sanitized or properly sandboxed could be vulnerable to directory traversal.</p> <p>For example, consider an application that allows the user to choose what page to load from a GET parameter.</p> <pre><code>&lt;?php\n    $page = $_GET['page']; // index.php\n    include(\"/var/www/html/\" . $page);\n?&gt;\n</code></pre> <p>Under normal operation the page would be <code>index.php</code>. But what if a malicious user gave in something different?</p> <pre><code>&lt;?php\n    $page = $_GET['page']; // ../../../../../../../../etc/passwd\n    include(\"/var/www/html/\" . $page);\n?&gt;\n</code></pre> <p>Here the user is submitting <code>../../../../../../../../etc/passwd</code>.</p> <p>This will result in the PHP interpreter leaving the directory that it is coded to look in ('/var/www/html') and instead be forced up to the root folder.</p> <pre><code>include(\"/var/www/html/../../../../../../../../etc/passwd\");\n</code></pre> <p>Ultimately this will become <code>/etc/passwd</code> because the computer will not go a directory above its top directory.</p> <p>Thus the application will load the <code>/etc/passwd</code> file and emit it to the user like so:</p> <pre><code>root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\nsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false\nsystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false\nsystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false\nsystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false\n_apt:x:104:65534::/nonexistent:/bin/false\n</code></pre> <p>This same concept can be applied to applications where some input is taken from a user and then used to access a file or path or similar. This vulnerability very often can be used to leak sensitive data or extract application source code to find other vulnerabilities.</p>"}, {"location": "web-exploitation/php/what-is-php/", "title": "PHP", "text": "<p>PHP is one of the most used languages for back-end web development and therefore it has become a target by hackers. PHP is a language which makes it painful to be secure for most instances, making it every hacker's dream target.</p>"}, {"location": "web-exploitation/php/what-is-php/#overview", "title": "Overview", "text": "<p>PHP is a C-like language which uses tags enclosed by <code>&lt;?php ... ?&gt;</code> (sometimes just <code>&lt;? ... ?&gt;</code>). It is inlined into HTML. A word of advice is to keep the php docs open because function names are strange due to the fact that the length of function name is used to be the key in PHP's internal dictionary, so function names were shortened/lengthened to make the lookup faster. Other things include:</p> <ul> <li>Variables start with $: <code>$name</code></li> <li>Variable variables: <code>$$name</code></li> <li>Request-specific dictionaries: <code>$_GET, $_POST, $_SERVER</code></li> </ul>"}, {"location": "web-exploitation/php/what-is-php/#example", "title": "Example", "text": "<pre><code>&lt;?php\n    if ($_SERVER['REQUEST_METHOD'] === 'POST' &amp;&amp; isset($_POST['email']) &amp;&amp; isset($_POST['password'])) {\n        $db = new mysqli('127.0.0.1', 'cs3284', 'cs3284', 'logmein');\n        $email = $_POST['email'];\n        $password = sha1($_POST['password']);\n        $res = $db-&gt;query(\"SELECT * FROM users WHERE email = '$email' AND password = '$password'\");\n        if ($row = $res-&gt;fetch_assoc()) {\n            $_SESSION['id'] = $row['id'];\n            header('Location: index.php');\n            die();\n        }\n   }\n?&gt;\n&lt;html&gt;...\n</code></pre> <p>This example PHP simply checks the POST data for an email and password. If the password is equal to the hashed password in the database, the use is logged in and redirected to the index page.</p> <p>The line <code>email = '$email'</code> uses automatic string interpolation in order to convert $email into a string to compare with the database.</p>"}, {"location": "web-exploitation/php/what-is-php/#type-juggling", "title": "Type Juggling", "text": "<p>PHP will do just about anything to match with a loose comparison (\\=\\=) which means things can be 'equal' (\\=\\=) or really equal (\\=\\=\\=). The implicit integer parsing to strings is the root cause of a lot of issues in PHP.</p>"}, {"location": "web-exploitation/php/what-is-php/#type-comparison-table", "title": "Type Comparison Table", "text": ""}, {"location": "web-exploitation/php/what-is-php/#comparisons-of-x-with-php-functions", "title": "Comparisons of $x with PHP Functions", "text": "Expression gettype() empty() is_null() isset() boolean: <code>if($x)</code> $x = \"\"; string TRUE FALSE TRUE FALSE $x = null; NULL TRUE TRUE FALSE FALSE var $x; NULL TRUE TRUE FALSE FALSE $x is undefined NULL TRUE TRUE FALSE FALSE $x = array(); array TRUE FALSE TRUE FALSE $x = array('a', 'b'); array FALSE FALSE TRUE TRUE $x = false; boolean TRUE FALSE TRUE FALSE $x = true; boolean FALSE FALSE TRUE TRUE $x = 1; integer FALSE FALSE TRUE TRUE $x = 42; integer FALSE FALSE TRUE TRUE $x = 0; integer TRUE FALSE TRUE FALSE $x = -1; integer FALSE FALSE TRUE TRUE $x = \"1\"; string FALSE FALSE TRUE TRUE $x = \"0\"; string TRUE FALSE TRUE FALSE $x = \"-1\"; string FALSE FALSE TRUE TRUE $x = \"php\"; string FALSE FALSE TRUE TRUE $x = \"true\"; string FALSE FALSE TRUE TRUE $x = \"false\"; string FALSE FALSE TRUE TRUE"}, {"location": "web-exploitation/php/what-is-php/#comparisons", "title": "\"==\" Comparisons", "text": "TRUE FALSE 1 0 -1 \"1\" \"0\" \"-1\" NULL array() \"php\" \"\" TRUE ==TRUE== FALSE ==TRUE== FALSE ==TRUE== ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE ==TRUE== ==TRUE== FALSE ==TRUE== 1 ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE 0 FALSE ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE ==TRUE== FALSE ==TRUE== ==TRUE== -1 ==TRUE== FALSE FALSE FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE \"1\" ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE \"0\" FALSE ==TRUE== FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE \"-1\" ==TRUE== FALSE FALSE FALSE ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE NULL FALSE ==TRUE== FALSE ==TRUE== FALSE FALSE FALSE FALSE ==TRUE== ==TRUE== FALSE ==TRUE== array() FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== ==TRUE== FALSE FALSE \"php\" ==TRUE== FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE \"\" FALSE ==TRUE== FALSE ==TRUE== FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE ==TRUE=="}, {"location": "web-exploitation/php/what-is-php/#comparisons_1", "title": "\"===\" Comparisons", "text": "TRUE FALSE 1 0 -1 \"1\" \"0\" \"-1\" NULL array() \"php\" \"\" TRUE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 1 FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 0 FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE -1 FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE FALSE \"1\" FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE FALSE \"0\" FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE FALSE \"-1\" FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE FALSE NULL FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE FALSE array() FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE FALSE \"php\" FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE== FALSE \"\" FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ==TRUE=="}, {"location": "web-exploitation/php/what-is-php/#file-inclusion", "title": "File Inclusion", "text": "<p>PHP has multiple ways to include other source files such as require, require_once and include. These can take a dynamic string such as <code>require $_GET['page'] . \".php\";</code> which is usually seen in templating.</p>"}, {"location": "web-exploitation/php/what-is-php/#php-stream-filters", "title": "PHP Stream Filters", "text": "<p>PHP has its own URL scheme: <code>php://...</code> and  its main purpose is to filter output automatically. It can automatically remove certain HTML tags and can base64 encode as well.</p>"}, {"location": "web-exploitation/php/what-is-php/#example_1", "title": "Example", "text": "<pre><code>$fp = fopen('php://output', 'w');\nstream_filter_append(\n       $fp,\n       'string.strip_tags',\n       STREAM_FILTER_WRITE,\n       array('b','i','u'));\nfwrite($fp, \"&lt;b&gt;bolded text&lt;/b&gt; enlarged to a &lt;h1&gt;level 1 heading&lt;/h1&gt;\\n\");\n/* &lt;b&gt;bolded text&lt;/b&gt; enlarged to a level 1 heading */\n</code></pre>"}, {"location": "web-exploitation/php/what-is-php/#exploitation", "title": "Exploitation", "text": "<p>These filters can also be used on input such as:</p> <ul> <li><code>php://filter/convert.base64-encode/resource={file}</code></li> <li><code>include</code>, <code>file_get_contents()</code>, etc. support URLs including PHP stream filter URLs (<code>php://</code>)</li> <li><code>include</code> normally evaluates any PHP code (in tags) it finds, but if it\u2019s base64 encoded it can be used to leak source</li> </ul>"}, {"location": "web-exploitation/server-side-request-forgery/what-is-server-side-request-forgery/", "title": "Server Side Request Forgery (SSRF)", "text": "<p>Server Side Request Forgery or SSRF is where an attacker is able to cause a web application to send a request that the attacker defines.</p> <p>For example, say there is a website that lets you take a screenshot of any site on the internet.</p> <p>Under normal usage a user might ask it to take a screenshot of a page like Google, or The New York Times. But what if a user does something more nefarious? What if they asked the site to take a picture of http://localhost ? Or perhaps tries to access something more useful like http://localhost/server-status ?</p> <p>Note</p> <p>127.0.0.1 (also known as localhost or loopback) represents the computer itself. Accessing localhost means you are accessing the computer's own internal network. Developers often use localhost as a way to access the services they have running on their own computers.</p> <p>Depending on what the response from the site is the attacker may be able to gain additional information about what's running on the computer itself.</p> <p>In addition, the requests originating from the server would come from the server's IP not the attackers IP. Because of that, it is possible that the attacker might be able to access internal resources that he wouldn't normally be able to access.</p> <p>Another usage for SSRF is to create a simple port scanner to scan the internal network looking for internal services.</p>"}, {"location": "web-exploitation/sql-injection/what-is-sql-injection/", "title": "SQL Injection", "text": "<p>SQL Injection is a vulnerability where an application takes input from a user and doesn't vaildate that the user's input doesn't contain additional SQL.</p> <pre><code>&lt;?php\n    $username = $_GET['username']; // kchung\n    $result = mysql_query(\"SELECT * FROM users WHERE username='$username'\");\n?&gt;\n</code></pre> <p>If we look at the $username variable, under normal operation we might expect the username parameter to be a real username (e.g. kchung).</p> <p>But a malicious user might submit different kind of data. For example, consider if the input was <code>'</code>?</p> <p>The application would crash because the resulting SQL query is incorrect.</p> <pre><code>SELECT * FROM users WHERE username='''\n</code></pre> <p>Note</p> <p>Notice the extra single quote at the end.</p> <p>With the knowledge that a single quote will cause an error in the application we can expand a little more on SQL Injection.</p> <p>What if our input was <code>' OR 1=1</code>?</p> <pre><code>SELECT * FROM users WHERE username='' OR 1=1\n</code></pre> <p>1 is indeed equal to 1. This equates to true in SQL. If we reinterpret this the SQL statement is really saying</p> <pre><code>SELECT * FROM users WHERE username='' OR true\n</code></pre> <p>This will return every row in the table because each row that exists must be true.</p> <p>We can also inject comments and termination characters like <code>--</code> or <code>/*</code> or <code>;</code>. This allows you to terminate SQL queries after your injected statements. For example <code>'--</code> is a common SQL injection payload.</p> <pre><code>SELECT * FROM users WHERE username=''-- '\n</code></pre> <p>This payload sets the username parameter to an empty string to break out of the query and then adds a comment (<code>--</code>) that effectively hides the second single quote.</p> <p>Using this technique of adding SQL statements to an existing query we can force databases to return data that it was not meant to return.</p>"}]}